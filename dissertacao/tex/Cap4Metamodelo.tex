
\chapter{Metamodelo do Intermediador de Serviços}
\label{cap:metamodelo}

%provides an independent API to the middleware and interfaces with the underlying frameworks and controllers to realize the services required. The broker removes the heterogeneity of the frameworks and controllers that provide the low-level services in the respective domains. The broker also interprets events from the underlying frameworks and controllers and generates events and exceptions to be handled by the upper layers.

%1) how to provide middleware with the ability to integrate diverse underlying high-level services, both existing and new ones under a common infrastructure while abstracting away the details of the un- derlying service implementations;
%2) how to provide middleware with the ability to adapt service provision according to user/organization requirements and context; and
%3) how to provide middleware with the ability to support the earlier discussed issues in dynamic and uncertain environments.


% Apresentar um certo grau de auto-gerenciamento (ver referencias dissertacao Andrew ou artigo Autonomic Framework...) (Isto talvez deve vir no capítulo anterior, assim como os comentários acima que definem claramente o que é um broker)


A camada de intermediação de serviços é responsável pelo gerenciamento dos recursos que serão efetivamente utilizados para provisão de serviços. Um intermediador de serviços gerencia um conjunto heterogêneo de recursos, e provê à camada superior uma interface uniforme, capaz de abstrair as diferenças existentes entre os recursos gerenciados.

Além de disponibilizar uma interface uniforme para uso dos recursos, a camada de intermediação de serviços deve apresentar um certo grau de auto-gerenciamento. O auto-gerenciamento, permite que detalhes relacionados à manutenção de recursos sejam abstraídos para a camada superior. Uma camada auto-gerenciável é capaz de monitorar seus recursos e se adaptar automaticamente para atender aos serviços demandados.

Este capítulo apresenta o metamodelo proposto para definição da camada de intermediação de serviços para máquinas de execução de modelos baseadas na arquitetura proposta. As construções presentes no metamodelo em questão estão diretamente relacionadas às responsabilidades identificadas para essa camada. O capítulo inicia com uma visão geral do metamodelo e prossegue abordando em detalhes os elemento que o compõem.

%\begin{comment}
%
%A ser colocado no início dessa seção:
%
%- Como mencionado anteriormente, o Intermediador de Serviços é a camada que possui a responsabilidade de prover uma interface uniforme que abstraia a heterogeneidade dos recursos disponíveis e a dinâmica envolvida em sua utilização.
%
%- Assim sendo, ao definirmos o comportamento dessa camada, precisamos descrever como serão tratadas as chamadas realizadas pela camada superior, e em que situações serão gerados determinados eventos. Mas além disso, também precisamos descrever como outras tarefas serão realizadas, incluindo o monitoramento e seleção de recursos, manutenção de informações, adaptação da camada, entre outros.
%
%
%descrever a idéia por trás do metamodelo:
%	- definir como serão tratados os eventos/chamadas;
%	- definir quais os recursos que serão gerenciados e suas características;
%	- definir quais os tipos de dados serão manipulados;
%	- definir como serão monitorados os recursos de forma autonômica;
%	- definir como serão escolhidos recursos de acordo com políticas;
%	
%Com o intuito de permitir a instanciação do metamodelo e sua execução
%	- construído o metamodelo usando EMF;
%	- restrições de semântica estática;
%	- construído ambiente de execução que define a semântica operacional;
%	
%\end{comment}


%Estrutura geral do metamodelo:
%	- Manager principal que é composto de:
%		* interface provides/signals,
%		* outros managers específicos,
%		* descrição dos sinais a serem tratados;
%	- Este manager pode ser tratado como um recurso por outros managers

\section{Visão geral}
\label{sec:metamodelo-visao-geral}

Como observado anteriormente, a camada de intermediação de serviços provê uma interface uniforme para utilização de um conjunto heterogêneo de recursos subjacentes. Um intermediador de serviços atua interceptando as solicitações recebidas por meio de sua interface e determinando quais operações devem ser efetuadas sobre os recursos. Além disso, um intermediador também intercepta eventos provenientes dos recursos por ele monitorados e determina se devem ser sinalizados para a camada superior, se uma adaptação na camada é necessária, ou se alguma outra ação deve ser tomada.

No metamodelo proposto, a definição de um intermediador de serviços se dá pela descrição de como ele deve se comportar em resposta a cada uma das possíveis solicitações que podem vir da camada superior e dos eventos que podem ser gerados pelos recursos gerenciados.
Deste modo, o comportamento de um intermediador de serviços é determinado pela forma como eventos e solicitações recebidos são tratados.
Neste trabalho, as solicitações recebidas da camada superior são denominadas \emph{chamadas} e utilizamos o termo \emph{sinal} para designar de forma generalizada um \emph{evento} ou \emph{chamada}.
%Esta abordagem se baseia em uma arquitetura dirigida por eventos \cite{eda}, onde o comportamento é determinado pela forma como os eventos são tratados. 
%Neste trabalho, utilizamos o termo \emph{sinal} para designar de forma generalizada um evento ou chamada.
Assim, um sinal pode representar tanto uma solicitação recebida da camada superior quanto um evento gerado por um recurso gerenciado.

%Esta abordagem se baseia em uma arquitetura dirigida por eventos \cite{eda}, onde o comportamento é determinado pela forma como os eventos são tratados. 
%Neste trabalho, utilizamos o termo \emph{sinal} para designar de forma generalizada um evento. 
%Assim, um sinal pode representar tanto uma solicitação recebida quanto um evento gerado.

Além disso, o metamodelo possui abstrações para descrição de outras características indispensáveis em uma camada de intermediação de serviços. Essas abstrações compreendem a definição de recursos, manutenção de estado, auto-gerenciamento e políticas para seleção de recursos.

Para a construção do metamodelo, foi empregado o metamodelo Ecore, que integra o Eclipse Modeling Framework (EMF) \cite{emf}. O emprego do Ecore, que nesse caso atua como um meta-metamodelo, permite o uso de várias ferramentas disponibilizadas pelo EMF que auxiliam na construção, armazenamento e processamento de modelos.
%Por empregar essa tecnologia, o metamodelo projetado não só usufrui de suas vantagens, mas também está sujeito às suas restrições. 

O metamodelo projetado está estruturado em torno de uma classe principal, chamada \textsf{Manager}. Uma instância dessa classe representa um gerenciador de intermediação, que define um escopo para o gerenciamento de recursos e agrupa outros elementos que definem as atribuições específicas da camada de intermediação de serviços.

\begin{figure}
 \centering
 \includegraphics[width=0.8\textwidth]{./fig/manager2}
 \caption{Principais elementos do metamodelo do intermediador de serviços.}
 \label{fig:metamodelo-principal}
\end{figure}

A Figura~\ref{fig:metamodelo-principal} ilustra os principais elementos que compõem o metamodelo. Nesta figura é possível identificar a classe \textsf{Manager} e os seguintes elementos associados:

\begin{itemize}

\item \textsf{Interface}: define as operações disponibilizadas por um gerenciador e os eventos que podem ser gerados por ele. 

\item \textsf{Action}/\textsf{Handler}:  define como sinais serão tratados.

\item \textsf{ResourceManager}: define os recursos que serão gerenciados por um determinado \textsf{Manager}, incluindo suas interfaces e como eles são obtidos.

\item \textsf{StateManager}: define os tipos de dados que precisam ser mantidos pela camada para prover seus serviços.

\item \textsf{AutonomicManager}: define elementos associados ao auto-gerenciamento da camada.

\item \textsf{PolicyManager}: define políticas para seleção de recursos e como estas devem ser avaliadas

\end{itemize}

Uma vez construída uma instância da classe \textsf{Manager}, esta pode ser utilizada como um recurso por outra instância de \textsf{Manager}.
Isto possibilita a construção de uma hierarquia de gerenciadores, que podem ser empregados sucessivamente para prover serviços a partir de recursos e de outros gerenciadores de intermediação mais básicos.
Além disso, essa característica possibilita a modularização da camada e a reutilização de gerenciadores de intermediação na construção de outros gerenciadores de mais alto nível.
% Ref: Design concepts & considerations: http://en.wikipedia.org/wiki/Software_design

%\begin{comment}
%- Colocar exemplos de utilização dessa hierarquia de gerenciadores.
%
%- Também deixar mais claro que a camada e a interface da camada é definida pelo se gerenciador principal
%\end{comment}

A construção de uma camada de intermediação de serviços se dá a partir da indicação de qual será o seu gerenciador principal que por sua vez pode empregar outros gerenciadores como recursos subjacentes.

%As seções seguintes descrevem em detalhes as partes do metamodelo identificadas acima. Como observado anteriormente, a abordagem proposta se baseia nas soluções empregadas no desenvolvimento da CVM. Portanto, as abstrações existentes no metamodelo também guardam semelhanças com aquelas empregadas pela camada NCB na CVM \cite{Andrew}.
% com as empregadas pela camada de intermediação de serviços da CVM = com o trabalho existente na NCB

%% Como resolver a sobrecarga de nomes? e.g. classe no metamodelo e classe da implementação do ambiente de execução?

As seções seguintes descrevem em detalhes as partes do metamodelo identificadas acima. Como já observado, a abordagem proposta se baseia nas soluções empregadas no desenvolvimento da CVM. Devido a isso, o metamodelo proposto incorpora conceitos independentes de domínio presentes na CVM, e assim sua organização e abstrações guardam semelhanças com aquelas da camada NCB \cite{Andrew}.


%As seções seguintes descrevem em detalhes as partes do metamodelo identificadas acima. Como observado anteriormente, a abordagem proposta se baseia nas soluções empregadas no desenvolvimento da CVM. Portanto, as abstrações existentes no metamodelo também guardam semelhanças com aquelas empregadas pela camada NCB na CVM \cite{Andrew}.

\section{Interface}

No metamodelo proposto, a interface para utilização de um gerenciador de intermediação é definida por meio de \emph{chamadas} que podem ser realizadas ao gerenciador e \emph{eventos} que podem ser sinalizados por ele.
Este tipo de interface segue a mesma abordagem empregada pela CVM para comunicação entre camadas \cite{cvm}. Dessa forma, a utilização de um gerenciador se dá através da realização de chamadas e tratamento de eventos gerados.

Como a interface de uma camada de intermediação de serviços é definida pela interface do gerenciador principal na hierarquia de gerenciadores, a interação com as camadas superiores ocorre da mesma forma descrita acima. Além disso, as interfaces para utilização dos recursos gerenciados também é descrita da mesma forma, o que possibilita que um gerenciador de intermediação seja tratado como um recurso por parte de outros gerenciadores.

A Figura~\ref{fig:metamodelo-interface} ilustra as classes do metamodelo relacionadas com a descrição de interfaces.
A classe \textsf{Interface} é utilizada para descrever a interface de um gerenciador de intermediação ou recurso. %Essa classe agrupa um conjunto de chamadas disponibilizadas e eventos que podem ser sinalizados.
Chamadas e eventos que fazem parte da interface são conjuntamente denominados \emph{sinais} e são representados, respectivamente, pelas classes \textsf{Call} e \textsf{Event}. Ambas as classes apresentam como característica comum o fato de possuírem um nome e um conjunto de parâmetros e, por isso, herdam esses atributos da classe \textsf{Signal}. Os parâmetros de um sinal, por sua vez, são identificados por um nome, e são definidos por meio da classe \textsf{Parameter}.

\begin{figure}
 \centering
 \includegraphics[width=0.48\textwidth]{./fig/iface}
 \caption{Elementos do metamodelo para descrição de interfaces.}
 \label{fig:metamodelo-interface}
\end{figure}


\section{Tratamento de sinais}
\label{sec:metamodelo-sinais}

Como mencionado na Seção~\ref{sec:metamodelo-visao-geral}, o comportamento de uma camada de intermediação de serviços é definido pela forma como esta reage às chamadas recebidas da camada superior e aos eventos sinalizados pelos recursos. O metamodelo proposto disponibiliza construções que permitem definir quais ações devem ser tomadas pela camada em resposta aos sinais recebidos.

O tratamento de sinais na camada de intermediação é definido por meio das classes \textsf{Signal}, \textsf{Handler} e \textsf{Action}. Enquanto os sinais a serem tratados por um gerenciador são descritos como parte da interface do gerenciador e dos recursos gerenciados, os demais elementos (tratadores e ações) são diretamente agrupados no gerenciador. A Figura~\ref{fig:metamodelo-sinais} mostra como esses elementos estão organizados no metamodelo.

\begin{figure}
 \centering
 \includegraphics[width=0.85\textwidth]{./fig/sinais}
 \caption{Principais elementos do metamodelo relacionados ao tratamento de sinais .}
 \label{fig:metamodelo-sinais}
\end{figure}

Uma ação representa uma operação que pode ser executada por um gerenciador, e é definida por meio da classe abstrata \textsf{Action}, que possui as seguintes subclasses:

\begin{itemize}

\item \textsf{CallAction}: define uma ação que especifica uma chamada a ser realizada aos recursos gerenciados ou ao próprio gerenciador.

\item \textsf{EventAction}: define uma ação que especifica um evento a ser gerado pelo gerenciador.

\item  \textsf{MacroAction}: permite ao usuário definir uma classe Java que implementa a ação desejada. Por meio de ações desse tipo, é possível definir ações que implementam uma lógica arbitrária, e executam operações que vão além da intermediação direta de chamadas e eventos.

\item \textsf{SequenceAction}: combina uma lista de ações a serem executadas em sequência.

\end{itemize}

Uma ação também define um contexto necessário para a sua execução por meio de um conjunto de parâmetros. Os parâmetros de uma ação, descritos através da classe \textsf{ActionParameter}, representam as informações necessárias para a execução da operação definida pela ação. 

Um tratador de sinais, representado pela classe \textsf{Handler}, é utilizado para indicar a ação que deve ser tomada quando um determinado sinal é identificado.
Uma instância de \textsf{Handler} descreve o sinal a ser tratado, se este tratador está habilitado, e a ação a ser tomada.

Além disso, ao definir um tratador, é necessário descrever como serão atribuídos valores aos parâmetros da ação associada. Esta ligação entre o contexto no qual um sinal é identificado e o contexto exigido por uma ação, é definida pela classe \textsf{ActionExecution}. A Figura~\ref{fig:metamodelo-binding} mostra as classes do metamodelo que estão relacionadas com a ligação de contexto.


A classe \textsf{ActionExecution} intermedia a associação entre um tratador de sinal e uma ação, e define um conjunto de associações de parâmetros, descritas através classe \textsf{ParameterBinding}. Uma associação de parâmetro define como será atribuído valor a um parâmetro de uma ação. Um parâmetro pode ser associado a diferentes fontes de valores, que são definidas por meio de subtipos do tipo \textsf{Value}.

%\begin{itemize}
%
%\item \textsf{FixedValue}: define uma fonte valor fixa, o que possibilita que um valor arbitrário seja passado como parâmetro para uma ação.
%
%\item \textsf{ParameterValue}: define uma fonte valor que está associado à um parâmetro que faz parte do sinal tratado. Este tipo de fonte de valor permite que seja atribuído o valor passado como parâmetro para um sinal, à um parâmetro exigido pela ação que tratará este sinal.
%
%\item \textsf{SignalSource}: o uso desta fonte de valor indica que o identificador da origem do sinal, ou seja, o recurso que gerou o sinal a ser tratado será atribuído à um atributo da ação que tratará este sinal. 
%
%\item \textsf{ExpressionValue}: permite que o resultado da avaliação de uma expressão seja utilizado como fonte de valor. O contexto para avaliação da expressão inclui os parâmetros e a origem do sinal a ser tratado. O capítulo~\ref{cap:ambiente} descreve em mais detalhes o contexto de avaliação destas expressões.
%
%\item \textsf{ActionExecution}: possibilita que o resultado da execução de uma ação seja atribuído à um parâmetro de uma outra ação. O uso desta fonte de valores permite a definição de tratadores complexos que utilizam uma combinação de ações para responder a um sinal.
%
%\end{itemize}


O metamodelo inclui as classes \textsf{FixedValue} e \textsf{ParameterValue} para definição de fontes com um valor fixo e fontes cujo valor é obtido a partir de um parâmetro do sinal tratado.
A classe \textsf{ExpressionValue}, por sua vez, permite que o resultado da avaliação de uma expressão seja utilizado como fonte de valor.
% O contexto para avaliação da expressão inclui os parâmetros e a origem do sinal a ser tratado.
 Por fim, um outro tipo de fonte de valor, representado pela classe \textsf{ActionExecution}, possibilita que o resultado da execução de uma ação seja atribuído a um parâmetro de uma outra ação. O uso desta fonte de valores permite a definição de tratadores complexos, que utilizam uma combinação de ações para responder a um sinal.

\begin{figure}
 \centering
 \includegraphics[width=1\textwidth]{./fig/binding}
 \caption{Elementos do metamodelo para associação de parâmetros.}
 \label{fig:metamodelo-binding}
\end{figure}


Além de possibilitarem a definição de ações e tratadores de sinal, as construções descritas nesta seção permitem que ações sejam reutilizadas na composição de ações mais complexas, favorecendo a modularização do tratamento de sinais.
A utilização dessas construções do metamodelo é melhor ilustrada no Capítulo~\ref{cap:instancia}, onde são utilizadas para construir um modelo que representa a camada de intermediação de serviços presente na arquitetura da CVM.

\section{Recursos}
\label{sec:metamodelo-recursos}

No metamodelo proposto, os recursos gerenciados por uma camada de intermediação de serviços são descritos por meio de um gerenciador de recursos, definido pelo tipo \textsf{ResourceManager}. Um gerenciador de recursos define as interfaces dos recursos gerenciados e como estes podem ser obtidos. A Figura~\ref{fig:metamodelo-recursos} apresenta as classes do metamodelo envolvidas na descrição de recursos.

As interfaces dos recursos são descritas através da classe \textsf{Interface}, da mesma forma que a interface de um gerenciador da camada.
A obtenção dos recursos, por sua vez, é definida, de acordo com a sua natureza, por meio de classes que são subtipos de \textsf{ResourceManager}. O metamodelo proposto conta com uma classe denominada \textsf{InstanceResourceManager}, que permite a descrição de um conjunto fixo de recursos e suas características.
Outras classes que implementam a interface \textsf{ResourceManager} poderiam ser incluídas ao metamodelo para possibilitar a obtenção de recursos de formas mais elaboradas como, por exemplo, através de repositórios de objetos distribuídos.
% ??? Ponto de questionamento: que outras formas de se obter?

Uma instância da classe \textsf{InstanceResourceManager} agrupa um conjunto de objetos do tipo \textsf{Instance}.
A classe \textsf{Instance}, por sua vez, representa um recurso que pode ser obtido diretamente a partir da instanciação de uma implementação do recurso.

%A classe \textsf{Instance} define a implementação do recurso instanciada em tempo de execução.
%Além disso, uma instância de \textsf{Instance} também define qual das interfaces descritas pelo \textsf{ResourceManager} correspondente é a interface do recurso. 
A classe \textsf{Instance} define qual a implementação do recurso que será instanciada em tempo de execução e qual das interfaces descritas pelo \textsf{ResourceManager} correspondente é a interface do recurso. 
Por fim, a classe \textsf{Instance} implementa a interface \textsf{Annotable}, o que permite que metadados sejam associados aos recursos.
Esses metadados podem ser posteriormente utilizados para definição de políticas de seleção de recursos.

\begin{figure}
 \centering
 \includegraphics[width=0.88\textwidth]{./fig/resource}
 \caption{Elementos do metamodelo para descrição dos recursos gerenciados pela camada.}
 \label{fig:metamodelo-recursos}
\end{figure}


%Durante a execução da camada, um recurso descrito a partir da classe mm \textsf{Instance} tem sua implementação instanciada. Além disso, a interface associada à este objeto é utilizada para controlar a comunicação com essa implementação recém instanciada. 
%Para possibilitar a integração entre o ambiente de execução e a implementação do recurso, os métodos da classe rt de implementação que representam chamadas disponibilizadas pela interface associada devem incluir a anotação \textsf{@Call}, de forma a estabelecer o relacionamento entre interface e implementação. Além disso, essa mesma classe deve implementar a interface \textsf{Manageable} que possibilita que um recurso sinalize eventos à camada.
%% - Devemos: omitir os nomes Manageable e Call? ou explicar-los? ou mantê-los dessa forma?


\section{Manutenção de estado}

Muitas vezes, o processamento de um determinado sinal pela camada de intermediação de serviços pode depender de fatores que não estão diretamente ligados àquele sinal.
A ocorrência de um evento, parâmetros advindos de uma chamada recebida anteriormente, resultados do processamento de outros sinais, entre outros, são informações que podem determinar como um determinado sinal deve ser processado.

Para possibilitar essa variabilidade no processamento de sinais, é preciso que a camada de intermediação de serviços seja capaz de manter dados entre sucessivas ocorrências de sinais. As construções relacionadas à manutenção de estado, presentes no metamodelo proposto, têm como intuito possibilitar a definição de quais tipos de dados precisam ser mantidos pela camada durante a sua execução.

A classe \textsf{StateManager} agrupa os tipos de dados que podem ser mantidos pela camada. Os tipos de dados podem ser descritos através de uma estrutura simples, baseada em atributos e subtipos. Assim como no modelo relacional de dados, a descrição de um tipo de dados também exige a escolha de um atributo chave que identifique unicamente um registro desse tipo. 

A Figura~\ref{fig:metamodelo-estado} mostra as classes envolvidas na definição dos tipos de dados a serem mantidos pela camada durante sua execução. A classe \textsf{State} é utilizada para definir um tipo de dados, que agrupa atributos e subtipos. Cada atributo, por sua vez, é definido por meio da classe \textsf{Property}. Os subtipos são definidos a partir da mesma classe \textsf{State}, o que possibilita a definição de tipos de dados compostos.

\begin{figure}
 \centering
 \includegraphics[width=0.5\textwidth]{./fig/state}
 \caption{Elementos do metamodelo para descrição dos tipos de dados mantidos pela camada.}
 \label{fig:metamodelo-estado}
\end{figure}


\section{Gerenciamento Autônomo}
\label{sec:metamodelo-autonomo}

%- A camada de intermediação de serviços deve abstrair os detalhes da dinâmica envolvida no gerenciamento dos recursos da camada superior.

Além de abstrair as diferenças de capacidade entre os recursos existentes, a camada de intermediação de serviços também tem como responsabilidade ocultar da camada superior os detalhes relacionados à dinâmica de utilização dos recursos. Deste modo, para a camada superior, é indiferente o recurso que está sendo utilizado, suas capacidades, como e quando foi selecionado e todos os detalhes envolvidos em sua preparação para realizar as tarefas solicitadas.

%- Para isto deve ser capaz de se auto gerenciar (require self-healing behavior to adapt to changes in user needs, business goals, and environmental conditions such that self-healing decisions are made dynamically and adaptively according to the system context.)

Para atender a esta demanda, a camada de intermediação de serviços deve ser capaz de se auto-gerenciar, adaptando-se automaticamente para realizar o serviço solicitado dentro das restrições impostas pelo seu ambiente operacional.
O auto-gerenciamento dessa camada envolve o constante monitoramento dos recursos e das solicitações dos usuários para identificar situações que exigem uma ação e escolher a ação apropriada a ser tomada para que a camada atenda aos serviços solicitados.


%- O auto gerenciamento envolve a capacidade de  selecionar, preparar, monitorar, desativar e reativar recursos com o objetivo de prover o serviço solicitado pelo usuário.

%- Através das construções de tratamento de eventos advindos dos recursos, e chamadas realizadas à camada unidos com a manutenção de estado, é possível monitorar os recursos e tomar ações de acordo com o estado destes.

Através das abstrações presentes no metamodelo é possível definir o tratamento de eventos gerados pelos recursos e  das chamadas realizadas através da interface da camada. 
Estes mecanismos, associados à manutenção de estado, possibilitam definir como os recursos e solicitações serão monitorados para identificar variados cenários que exigem a execução de uma ação.

%- Apesar de isso ser possível, estas abstrações não são apropriadas para este tipo de tarefa.


Apesar disso, essas abstrações não são apropriadas para a descrição de situações mais complexas, que podem envolver diversos recursos, o estado da camada, dados de chamadas realizadas, entre outros. 
%- O metamodelo dispõe de abstrações baseadas na arquitetura de computação autonômica da IBM para descrever o comportamento autonomo.
Com o intuito de facilitar a definição de como se dará o auto-gerenciamento da camada, o metamodelo proposto incorpora um conjunto de abstrações baseadas na arquitetura de computação autônoma proposta pela IBM \cite{ibmac}.

Como observado no Capítulo~\ref{cap:referencial}, o principal bloco de construção da arquitetura de computação autônoma é o gerenciador autônomo. O gerenciador autônomo implementa as funções MAPE, que permitem monitorar informações sobre recursos gerenciados, analisar essas informações e identificar se uma mudança é necessária. Em caso afirmativo, o gerenciador autônomo ainda cria um plano para realizar a mudança e, em seguida, o executa.
%Ao serem executadas, essas funções podem fazer uso de um conhecimento compartilhado entre elas.
A interação entre essas funções é dirigida pela troca de conhecimento, que representa sintomas, solicitações de mudança e planos de mudança.

%- Em tal arquitetura o gerenciamento se dá através de um control loop MAPE-K
% Explicar MAPE e Knowledge, que inclui os sintomas, change requests, change plans

%The Autonomic Computing Architectural Blueprint (see Resources for a link) describes an autonomic manager as: an implementation that automates some management function and externalizes this function according to the behavior defined by management interfaces. 
%The autonomic manager is a component that implements the control loop ... For a system component to be self-managing, it must have an automated method to collect the details it needs from the system; to analyze those details to determine if something needs to change; to create a plan, or sequence of actions, that specifies the necessary changes; and to perform those actions. When these functions can be automated, an intelligent control loop is formed.


%- No metamodelo proposto, as funções tem seu comportamento descrito a partir dos elementos que elas devem gerar.

As abstrações presentes no metamodelo proposto permitem descrever regras que determinam a geração e propagação de conhecimento entre as funções MAPE. Desta forma, ao construir uma camada de intermediação de serviços, devem ser descritas regras para identificação de sintomas, solicitações de mudanças e planos de mudança. Em tempo de execução, o monitor utiliza essas regras para identificar a ocorrência de um sintoma. De forma semelhante o analisador e planejador se baseiam nos sintomas identificados e nas solicitações de mudança geradas para realizarem sua tarefa.
A Figura~\ref{fig:metamodelo-autonomo} ilustra as construções associadas à definição do mecanismo autônomo em um intermediador de serviços.

\begin{figure}
 \centering
 \includegraphics[width=0.85\textwidth]{./fig/autonomo}
 \caption{Elementos do metamodelo para descrição do comportamento autônomo.}
 \label{fig:metamodelo-autonomo}
\end{figure}

% A classe AutonomicManager agrupa os elementos relacionados à gerenciamento autonomico.

A classe \textsf{AutonomicManager} agrupa os elementos relacionados ao gerenciamento autônomo de recursos. Essa classe agrupa elementos que descrevem as regras para geração de sintomas, solicitações de mudanças e planos de mudança. 
A classe \textsf{Symptom} descreve um sintoma a ser monitorado com o intuito de identificar mudanças no contexto da camada. Um sintoma define um conjunto de condições para que este seja identificado. Em tempo de execução, os recursos e o estado da camada são monitorados e as condições de um sintoma avaliadas. Se todas as condições definidas em um sintoma são atingidas uma ocorrência deste sintoma é gerada e passada ao analisador.

As condições agrupadas pela classe \textsf{Symptom} são descritas a partir de expressões. Além das condições, a classe \textsf{Symptom} também define o contexto em que estas expressões serão avaliadas através da classe \textsf{Binding}, que associa um nome (a ser usado na expressão) a um elemento do tipo \textsf{Bindable}. A interface \textsf{Bindable}, por sua vez, é implementada pelas classes \textsf{Signal} e \textsf{State}. Essas abstrações permitem definir condições que envolvam, além de dados de chamadas e eventos, o estado mantido pela camada.

% TODO: separar symptons devem monitorar só os recursos e change request deve relacionar symptons com calls and state

A classe \textsf{ChangeRequest} define uma requisição de mudança que deve ser gerada quando um determinado sintoma é identificado. Associado a uma requisição de mudança podemos ter um plano de mudança definido por instâncias da classe \textsf{ChangePlan}.
%Um plano de mudança pode assumir diversas formas, desde um complexo \emph{workflow} envolvendo várias atividades até um simples comando. % \cite{ibmac} 
 No metamodelo proposto, um plano de mudança define uma ação a ser executada. Uma ação, por sua vez, pode ser definida por meio dos tipos de ação disponíveis e suas combinações, conforme descrito na Seção \ref{sec:metamodelo-sinais}.

% Enquanto a função de planejamento pode empregar algoritmos complexos que geram dinâmicamente planos  de mudança que podem envolver um workflow completo de execução, no trabalho em questão optamos por uma abordagem simples, onde um plano é diretamente associado a uma solicitação de mudança

%Referencia: The plan function can take on many forms, ranging from a single command to a complex workflow. 

%\begin{comment}
%É possível estabelecer um relacionamento entre a arquitetura de computação autônoma como um todo e o metamodelo. Ao mencionar a arquitetura de computação autônoma como um todo me refiro à todas as suas camadas (ManagedResources, Touchpoints, TouchpointsAutonomicManagers, OrchestratingAutonomicManagers, ManualManagers). Não sei se seria interessante colocar isso, e onde colocar, mas fazendo uma comparação entre a arquitetura de AC da IBM e o metamodelo podemos considerar o seguinte:
%
%- ManagedResources são descritos no metamodelo por meio do ResourceManager.
%
%- Touchpoints representam uma interface comum para interação com os recursos e são descritos por meio da Interface (que inclui Calls/Signals)
%
%- TouchpointAutonomicManagers são descritos por meio das contruções dessa seção
%
%- O conceito de OrchestratingAutonomicManagers pode ser descrito no metamodelo proposto por meio do uso de um gerenciador como um recurso para outro gerenciador.
%\end{comment}

\section{Políticas para seleção de recursos}
\label{sec:metamodelo-politicas}

No metamodelo, políticas são empregadas com o intuito de direcionar a seleção de recursos. As abstrações contempladas pelo metamodelo compreendem, além da descrição de políticas, a definição do momento onde estas devem ser avaliadas e como os resultados dessa avaliação devem ser tratados.

A Figura~\ref{fig:metamodelo-politicas} mostra as abstrações relacionadas à utilização de políticas, que se estruturam em torno da classe \textsf{PolicyManager}.
Os principais elementos da definição de políticas são representados por meio das classes \textsf{Policy}, \textsf{PolicyEvaluationContext}, \textsf{PolicyEvaluationPoint}, e \textsf{PolicyEvaluationHandler}.



\begin{figure}
 \centering
 \includegraphics[width=0.95\textwidth]{./fig/policy}
 \caption{Elementos do metamodelo para descrição de políticas.}
 \label{fig:metamodelo-politicas}
\end{figure}


A classe \textsf{Policy} representa uma política, que é definida por meio de um nome e uma condição a ser avaliada sobre um recurso.
Uma política também define um valor de negócio que identifica o grau de importância atribuído aos recursos capazes de satisfazer a condição definida.
Durante a avaliação das políticas, a seleção de recursos se baseia no seu valor de negócio, acumulado de acordo com a avaliação das políticas definidas.

As políticas são agrupadas por contextos de avaliação de políticas, definidos por meio da classe \textsf{PolicyEvaluationContext}. Um contexto de avaliação define os parâmetros necessários para avaliação das políticas que o integram.
Assim, as condições que definem uma política, definidas por expressões, podem envolver metadados definidos sobre os recursos e parâmetros definidos no contexto de avaliação.

Um ponto de avaliação de políticas, definido por meio da classe \textsf{PolicyEvaluationPoint}, especifica um sinal que desencadeia a avaliação de um conjunto de políticas. Por meio deste elemento é possível especificar o momento em que as políticas devem ser avaliadas ou reavaliadas em relação aos recursos.
Além disso, um ponto de avaliação de políticas também é responsável por definir como o contexto do sinal é mapeado para o contexto de avaliação de políticas. Esse mapeamento é realizado da mesma forma utilizada na definição de tratadores de sinais, empregando associações de parâmetros descritas por meio da classe \textsf{ParameterBinding}.

Um tratador de avaliação de políticas, representado por meio da classe \textsf{PolicyEvaluationHandler}, define uma ação a ser executada após a avaliação de políticas. Esse tratador tem como função definir como o resultado da avaliação de políticas será utilizado. Um tratador de avaliação de políticas está relacionado a um contexto de avaliação e será acionado sempre que as políticas nesse contexto forem reavaliadas.

O metamodelo descrito neste capítulo fornece um conjunto de abstrações para a construção de modelos que descrevem uma camada de intermediação de serviços que se enquadra na arquitetura proposta para construção de máquinas de execução de modelos. No Capítulo~\ref{cap:ambiente}, apresentamos o ambiente de execução desenvolvido para possibilitar a execução de modelos construídos em conformidade com o metamodelo descrito neste capítulo. O Capítulo~\ref{cap:instancia}, por sua vez, demonstra como o metamodelo aqui descrito pode ser empregado na construção de um modelo que descreve uma camada de intermediação de serviços equivalente à camada NCB que integra a CVM.
