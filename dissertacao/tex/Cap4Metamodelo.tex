
\chapter{Metamodelo do Intermediador de Serviços}
\label{cap:metamodelo}

%provides an independent API to the middleware and interfaces with the underlying frameworks and controllers to realize the services required. The broker removes the heterogeneity of the frameworks and controllers that provide the low-level services in the respective domains. The broker also interprets events from the underlying frameworks and controllers and generates events and exceptions to be handled by the upper layers.

%1) how to provide middleware with the ability to integrate diverse underlying high-level services, both existing and new ones under a common infrastructure while abstracting away the details of the un- derlying service implementations;
%2) how to provide middleware with the ability to adapt service provision according to user/organization requirements and context; and
%3) how to provide middleware with the ability to support the earlier discussed issues in dynamic and uncertain environments.


% Apresentar um certo grau de auto-gerenciamento (ver referencias dissertacao Andrew ou artigo Autonomic Framework...) (Isto talvez deve vir no capítulo anterior, assim como os comentários acima que definem claramente o que é um broker)


A camada de intermediação de serviços é a responsável pelo gerenciamento dos recursos que serão efetivamente utilizados para provisão de serviços. Um intermediador de serviços gerencia um conjunto heterogêneo de recursos, e provê à camada superior uma interface uniforme, que abstraia as diferenças existentes entre os recursos.

Além de disponibilizar uma interface uniforme sobre os recursos, a camada de intermediação de serviços deve apresentar um certo grau de auto gerenciamento. O auto gerenciamento, permite que detalhes envolvidos na manutenção de recursos sejam abstraídos da camada superior. Uma camada auto gerenciável é capaz de monitorar seus recursos e se adaptar automaticamente para atender aos serviços demandados.

Este capítulo apresenta o metamodelo proposto para definição de camadas de intermediação de serviços. As construções presentes no metamodelo em questão estão diretamente relacionadas às responsabilidades identificadas para essa camada. O capítulo inicia com uma visão geral do metamodelo e prossegue abordando em detalhes os (aspectos/assuntos/temas/áreas/partes) que o compõem.

%\begin{comment}
%
%A ser colocado no início dessa seção:
%
%- Como mencionado anteriormente, o Intermediador de Serviços é a camada que possui a responsabilidade de prover uma interface uniforme que abstraia a heterogeneidade dos recursos disponíveis e a dinâmica envolvida em sua utilização.
%
%- Assim sendo, ao definirmos o comportamento dessa camada, precisamos descrever como serão tratadas as chamadas realizadas pela camada superior, e em que situações serão gerados determinados eventos. Mas além disso, também precisamos descrever como outras tarefas serão realizadas, incluindo o monitoramento e seleção de recursos, manutenção de informações, adaptação da camada, entre outros.
%
%
%descrever a idéia por trás do metamodelo:
%	- definir como serão tratados os eventos/chamadas;
%	- definir quais os recursos que serão gerenciados e suas características;
%	- definir quais os tipos de dados serão manipulados;
%	- definir como serão monitorados os recursos de forma autonômica;
%	- definir como serão escolhidos recursos de acordo com políticas;
%	
%Com o intuito de permitir a instanciação do metamodelo e sua execução
%	- construído o metamodelo usando EMF;
%	- restrições de semântica estática;
%	- construído ambiente de execução que define a semântica operacional;
%	
%\end{comment}


%Estrutura geral do metamodelo:
%	- Manager principal que é composto de:
%		* interface provides/signals,
%		* outros managers específicos,
%		* descrição dos sinais a serem tratados;
%	- Este manager pode ser tratado como um recurso por outros managers

\section{Visão geral}

Como observado anteriormente, a camada de intermediação de serviços provê uma interface uniforme para utilização de um conjunto heterogêneo de recursos subjacentes. Um intermediador de serviços atua interceptando as solicitações recebidas por meio da interface disponibilizada, e determinando quais operações devem ser efetuadas nos recursos. Além disso, um intermediador também intercepta eventos advindos dos recursos por ele monitorados, e determina se este deve ser sinalizado para a camada superior, se uma adaptação na camada é necessária, ou se alguma outra ação deve ser tomada.

No metamodelo proposto, a definição de um intermediador de serviços se dá pela descrição de como este deve se comportar em resposta a cada uma das possíveis solicitações que podem advir da camada superior, e dos eventos que podem ser gerados pelos recursos gerenciados. Esta abordagem se baseia em uma arquitetura dirigida por eventos \cite{eda}, onde o comportamento é determinado pela forma como os eventos são tratados. Neste trabalho, utilizamos o termo \emph{sinal} para identificar de forma generalizada um evento. Portanto, um sinal pode representar tanto uma solicitação recebida quanto um evento gerado.

Além disso, o metamodelo possui abstrações para descrição de outras características indispensáveis em uma camada de intermediação de serviços. Essas abstrações compreendem a definição de recursos, manutenção de estado, auto gerenciamento, e políticas para seleção de recursos.

Para a construção do metamodelo proposto, foi empregado o metamodelo Ecore \cite{ecore}, que integra o Eclipse Modeling Framework (EMF). O EMF Ecore, permite o uso de várias ferramentas que auxiliam na construção, armazenamento e processamento de modelos. Por empregar essa tecnologia, o metamodelo projetado não só usufrui de suas vantagens, mas também está sujeito às suas restrições. 

O metamodelo projetado se estrutura em torno de uma classe principal, denominada \textsf{Manager}. Uma instância dessa classe, aqui tratado como um gerenciador de intermediação, define um escopo para o gerenciamento de recursos e agrupa outros elementos que definem as atribuições específicas da camada de intermediação de serviços.

\begin{figure}
 \centering
 \includegraphics[width=0.8\textwidth]{./fig/manager}
 \caption{Principais elementos do metamodelo do intermediador de serviços.}
 \label{fig:metamodelo-principal}
\end{figure}

A figura~\ref{fig:metamodelo-principal} ilustra os principais elementos do metamodelo. Nesta figura é possível identificar a classe \textsf{Manager}, e os seguintes elementos que o compõem:

\begin{itemize}

\item \textsf{Interface}: define as operações disponibilizadas por um gerenciador e quais eventos podem ser gerados por este. 

\item \textsf{Action}/\textsf{Handler}:  definem como os sinais serão tratados pela camada.

\item \textsf{ResourceManager}: define os recursos que serão gerenciados por um determinado \textsf{Manager}, incluindo suas interfaces, e como são obtidos.

\item \textsf{StateManager}: define os tipos de dados que precisam ser mantidos pela camada para prover seus serviços.

\item \textsf{AutonomicManager}: define elementos associados ao auto gerenciamento da camada.

\item \textsf{PolicyManager}: define políticas para seleção de recursos e quando estas devem ser avaliadas

\end{itemize}

Uma vez construída uma instância da classe \textsf{Manager}, esta pode ser utilizada como um recurso para outra instância de \textsf{Manager}. Isto possibilita a construção de uma hierarquia de gerenciadores que podem ser empregados sucessivamente para prover serviços a partir de recursos e outros gerenciadores de intermediação. Além disso, essa característica permite a modularização da camada e a reutilização de gerenciadores de intermediação na construção de outros gerenciadores de mais alto nível.
% Ref: Design concepts & considerations: http://en.wikipedia.org/wiki/Software_design
A construção de uma camada de intermediação de serviços, se dá a partir da indicação de qual será o seu gerenciador principal, que por sua vez pode empregar outros gerenciadores como recursos subjacentes.

As seções seguintes descrevem em detalhes as (aspectos/assuntos/temas/áreas/partes) do metamodelo identificados acima. Como observado anteriormente, a abordagem proposta se baseia nas soluções empregadas no desenvolvimento da CVM. Portanto, as abstrações existentes no metamodelo também guardam semelhanças com as empregadas pela camada de intermediação de serviços da CVM \cite{ncb}.
% com as empregadas pela camada de intermediação de serviços da CVM = com o trabalho existente na NCB

%% Como resolver a sobrecarga de nomes? e.g. classe no metamodelo e classe da implementação do ambiente de execução?
\section{Interface}

No metamodelo proposto, a interface para utilização de um gerenciador é definida por meio de chamadas que podem ser realizadas, e eventos que podem ser sinalizados. Este tipo de interface segue a mesma abordagem empregada pela CVM para comunicação entre camadas \cite{cvm}. Dessa forma, a utilização de um gerenciador se dá através da realização de chamadas disponíveis e tratamento de eventos gerados.

A interface de uma camada de intermediação de serviços, por sua vez, é definida pela interface de seu gerenciador principal e, portanto, também interage com a camada superior da forma descrita acima. Além disso, as interfaces para utilização dos recursos gerenciados também é descrita da mesma forma, o que possibilita que um gerenciador seja tratado como um recurso.

A figura~\ref{fig:metamodelo-interface} ilustra as classes do metamodelo relacionadas à descrição de interfaces.
A classe \textsf{Interface} é utilizada para descrever a interface de um gerenciador ou recurso. Essa classe agrupa um conjunto de chamadas disponibilizadas e eventos que podem ser sinalizados. Chamadas e eventos, denominados sinais, são representados respectivamente através das classes \textsf{Call} e \textsf{Event} que apresentam como característica comum o fato de possuírem um nome e um conjunto de parâmetros, e por isso herdam estes atributos da classe \textsf{Signal}. Os parâmetros de um sinal, por sua vez, são identificados por um nome, e são definidos por meio da classe \textsf{Parameter}.

\begin{figure}
 \centering
 \includegraphics[width=0.5\textwidth]{./fig/interface}
 \caption{Elementos do metamodelo para descrição de interfaces.}
 \label{fig:metamodelo-interface}
\end{figure}


\section{Tratamento de sinais}
\label{sec:metamodelo-sinais}

Como mencionado, o comportamento de uma camada de intermediação de serviços é definido pela forma como esta reage às chamadas realizadas pela camada superior e aos eventos sinalizados pelos recursos. O metamodelo proposto disponibiliza construções que permitem definir uma ação a ser realizada como resposta à um determinado sinal.

O tratamento de sinais na camada de intermediação é definido por meio das classes \textsf{Signal}, \textsf{Handler} e \textsf{Action}. Enquanto os sinais a serem tratados por um gerenciador são descritos como parte da interface do gerenciador e dos recursos gerenciados, os demais elementos são diretamente agrupados no gerenciador. A figura~\ref{fig:metamodelo-sinais} ilustra como esses elementos estão organizados no metamodelo.

Uma ação representa uma operação que pode ser executada por um gerenciador, e é definida por meio da classe abstrata \textsf{Action}, que possui as seguintes subclasses:

\begin{itemize}

\item  \textsf{MacroAction}: permite ao usuário definir uma classe Java que implementa a ação desejada.

\item \textsf{CallAction}: define uma chamada a ser enfileirada ou executada nos recursos gerenciados ou no próprio gerenciador.

\item \textsf{EventAction}: define um evento a ser gerado para a camada superior.

\item \textsf{SequenceAction}: combina uma lista de ações a ser executada em sequência.

\end{itemize}

Uma ação também define um contexto necessário para a sua execução por meio de um conjunto de parâmetros. Os parâmetros de uma ação, descritos através da classe \textsf{ActionParameter}, representam o conjunto de dados necessários para a execução daquela ação.

Um tratador de sinais, representado pela classe \textsf{Handler}, é utilizado para indicar qual ação deve ser tomada quando um determinado sinal é identificado.
Uma instancia de \textsf{Handler} descreve o sinal a ser tratado, se este tratador está habilitado, e a ação a ser tomada.

Além disso, ao definir um tratador, é necessário descrever como serão atribuídos valores aos parâmetros exigidos por uma ação. Esta ligação entre o contexto no qual um sinal é identificado e o contexto exigido por uma ação é definido pela classe \textsf{ActionExecution}. A figura~\ref{fig:metamodelo-binding} ilustra as classes do metamodelo que estão relacionadas à ligação de contexto.

A classe \textsf{ActionExecution} intermedia a associação entre um tratador e uma ação, e define um conjunto de associações de parâmetros, descritas através classe \textsf{ParameterBinding}. Uma associação de parâmetro define como será atribuído um valor à um parâmetro de uma ação. Um parâmetro pode ser associado à diferentes fontes de valores, que são definidas por meio de subtipos do tipo \textsf{Value}. O metamodelo disponibiliza as seguintes classes para definição de uma fonte de valores:

\begin{itemize}

\item \textsf{FixedValue}: define uma fonte valor fixa, o que possibilita que um valor arbitrário seja passado como parâmetro para uma ação.

\item \textsf{ParameterValue}: define uma fonte valor que está associado à um parâmetro que faz parte do sinal tratado. Este tipo de fonte de valor permite que seja atribuído o valor passado como parâmetro para um sinal, à um parâmetro exigido pela ação que tratará este sinal.

\item \textsf{SignalSource}: o uso desta fonte de valor indica que o identificador da origem do sinal, ou seja, o recurso que gerou o sinal a ser tratado será atribuído à um atributo da ação que tratará este sinal. 

\item \textsf{ExpressionValue}: permite que o resultado da avaliação de uma expressão seja utilizado como fonte de valor. O contexto para avaliação da expressão inclui os parâmetros e a origem do sinal a ser tratado. O capítulo~\ref{cap:ambiente} descreve em mais detalhes o contexto de avaliação destas expressões.

\item \textsf{ActionExecution}: possibilita que o resultado da execução de uma ação seja atribuído à um parâmetro de uma outra ação. O uso desta fonte de valores permite a definição de tratadores complexos que utilizam uma combinação de ações para responder a um sinal.

\end{itemize}

A utilização dessas construções do metamodelo é melhor ilustrada no capítulo~\ref{cap:instancia}, onde elas são utilizadas para construir um modelo que representa a camada de intermediação de serviços presente na CVM.

\section{Recursos}
\label{sec:metamodelo-recursos}

No metamodelo proposto, os recursos a serem gerenciados por uma camada de intermediação de serviços são descritos por meio de um gerenciador de recursos, definido pelo tipo \textsf{ResourceManager}. Um gerenciador de recursos define as interfaces dos recursos gerenciados, e como estes podem ser obtidos. A figura~\ref{fig:metamodelo-recursos} ilustra as classes do metamodelo envolvidas na descrição de recursos.

As interfaces dos recursos são descritas através da classe mm \textsf{Interface}, da mesma forma que a interface de um gerenciador da camada.
A obtenção dos recursos por sua vez, é definida, de acordo com a sua natureza, por classes subtipos de \textsf{ResourceManager}. O metamodelo proposto conta com uma classe denominada \textsf{InstanceResourceManager} que permite a descrição de um conjunto fixo de recursos e suas características. Outras classes que implementam a interface \textsf{ResourceManager} poderiam, por sua vez, possibilitar a obtenção de recursos de formas mais elaboradas como, por exemplo, através de repositórios de objetos distribuídos.
% ??? Ponto de questionamento: que outras formas de se obter?

Uma instância da classe \textsf{InstanceResourceManager} agrupa um conjunto de objetos do tipo mm \textsf{Instance}. A classe \textsf{Instance}, por sua vez, representa um recurso que pode ser obtido diretamente a partir da instanciação de uma implementação do recurso.
A classe \textsf{Instance} define a classe que implementa o recurso, e  que será instanciada em tempo de execução.
Além disso, uma instância de \textsf{Instance} também define qual das interfaces descritas pelo \textsf{ResourceManager} correspondente é a interface do recurso. Por fim, a classe \textsf{Instance} implementa a interface \textsf{Annotable}, o que permite que metadados sejam associados aos recursos.

\begin{figure}
 \centering
 \includegraphics[width=0.5\textwidth]{./fig/resource}
 \caption{Elementos do metamodelo para descrição dos recursos gerenciados pela camada.}
 \label{fig:metamodelo-recursos}
\end{figure}


%Durante a execução da camada, um recurso descrito a partir da classe mm \textsf{Instance} tem sua implementação instanciada. Além disso, a interface associada à este objeto é utilizada para controlar a comunicação com essa implementação recém instanciada. 
%Para possibilitar a integração entre o ambiente de execução e a implementação do recurso, os métodos da classe rt de implementação que representam chamadas disponibilizadas pela interface associada devem incluir a anotação \textsf{@Call}, de forma a estabelecer o relacionamento entre interface e implementação. Além disso, essa mesma classe deve implementar a interface \textsf{Manageable} que possibilita que um recurso sinalize eventos à camada.
%% - Devemos: omitir os nomes Manageable e Call? ou explicar-los? ou mantê-los dessa forma?


\section{Manutenção de estado}

Muitas vezes, o processamento de um determinado sinal pela camada de intermediação de serviços pode depender de sinais que foram processados anteriormente. 
Um sinal pode ter seu processamento diferenciado devido à fatores que não estão diretamente ligados àquele sinal. 
A ocorrência de um evento, parâmetros advindos de uma chamada recebida anteriormente, resultados do processamento de outros sinais, entre outros, são informações que podem determinar como um dado sinal deve ser processado.

Para possibilitar essa variabilidade no processamento de sinais, é preciso que a camada de intermediação de serviços seja capaz de manter dados entre sucessivas ocorrências de sinais. As construções relacionadas a manutenção de estado, presentes no metamodelo proposto, têm como intuito possibilitar a definição dos dados devem ser mantidos pela camada.

A classe \textsf{StateManager} do metamodelo tem como função definir os tipos de dados que poderão ser mantidos durante a execução da camada. Os tipos de dados podem ser descritos através de uma estrutura simples baseada em atributos e subtipos. Assim como no modelo relacional de dados, a descrição de um tipo também exige a seleção de um atributo chave que identifique unicamente um registro de um tipo de dados. 

A figura~\ref{fig:metamodelo-estado} ilustra as classes envolvidas na definição dos tipos de dados a serem mantidos pela camada durante sua execução. A classe \textsf{State} é utilizada para definir um tipo de dados, que agrupa atributos e subtipos. Cada atributo, por sua vez, é definido por meio da classe \textsf{Property}. Os subtipos por sua vez são definidos a partir da mesma classe \textsf{State}, o que possibilita a definição de tipos de dados compostos.

\begin{figure}
 \centering
 \includegraphics[width=0.5\textwidth]{./fig/state}
 \caption{Elementos do metamodelo para descrição dos tipos de dados mantidos pela camada.}
 \label{fig:metamodelo-estado}
\end{figure}


\section{Gerenciamento Autônomo}

%- A camada de intermediação de serviços deve abstrair os detalhes da dinâmica envolvida no gerenciamento dos recursos da camada superior.

Além de abstrair as diferenças de capacidades entre os recursos existentes, a camada de intermediação de serviços também tem como responsabilidade ocultar da camada superior os detalhes relacionados à dinâmica de utilização dos recursos. Assim sendo, para a camada superior é indiferente o recurso que está sendo utilizado, como e quando foi selecionado e todos os detalhes envolvidos em sua preparação realizar as tarefas solicitadas.

%- Para isto deve ser capaz de se auto gerenciar (require self-healing behavior to adapt to changes in user needs, business goals, and environmental conditions such that self-healing decisions are made dynamically and adaptively according to the system context.)

Para atender à esta demanda, a camada de intermediação de serviços deve ser capaz de se auto gerenciar, adaptando-se automaticamente para realizar o serviço solicitado dentro das restrições impostas pelo seu ambiente operacional. O auto gerenciamento dessa camada envolve o constante monitoramento dos recursos e das solicitações dos usuários para identificar situações que exigem uma ação, e escolher a ação apropriada a ser tomada.


%- O auto gerenciamento envolve a capacidade de  selecionar, preparar, monitorar, desativar e reativar recursos com o objetivo de prover o serviço solicitado pelo usuário.

%- Através das construções de tratamento de eventos advindos dos recursos, e chamadas realizadas à camada unidos com a manutenção de estado, é possível monitorar os recursos e tomar ações de acordo com o estado destes.

Através das abstrações presentes no metamodelo é possível definir o tratamento de eventos gerados pelos recursos e chamadas realizadas através da interface da camada. Estes mecanismos, associados à manutenção de estado, possibilitam definir como os recursos e solicitações serão monitorados para identificar variados cenários que exigem a execução de uma ação.


%- Apesar de isso ser possível, estas abstrações não são apropriadas para este tipo de tarefa.


Apesar disso, essas abstrações não são apropriadas para a descrição de situações mais complexas, que podem envolver diversos recursos, o estado da camada, dados de chamadas realizadas, entre outros. 
%- O metamodelo dispõe de abstrações baseadas na arquitetura de computação autonômica da IBM para descrever o comportamento autonomo.
Com o intuito de facilitar a definição de como se dará o auto gerenciamento da camada, o metamodelo proposto incorpora um conjunto de abstrações baseadas na arquitetura de computação autônoma proposta pela IBM.

Revisão/descrição breve da arquitetura, do loop MAPE-K, sensores e atuadores.
%- Em tal arquitetura o gerenciamento se dá através de um control loop MAPE-K
% Explicar MAPE e Knowledge, que inclui os sintomas, change requests, change plans

%The Autonomic Computing Architectural Blueprint (see Resources for a link) describes an autonomic manager as: an implementation that automates some management function and externalizes this function according to the behavior defined by management interfaces. The autonomic manager is a component that implements the control loop ... For a system component to be self-managing, it must have an automated method to collect the details it needs from the system; to analyze those details to determine if something needs to change; to create a plan, or sequence of actions, that specifies the necessary changes; and to perform those actions. When these functions can be automated, an intelligent control loop is formed.


%- No meta-modelo proposto, as funções tem seu comportamento descrito a partir dos elementos que elas devem gerar.

As abstrações presentes no metamodelo proposto permitem descrever regras que determinam a geração e transmissão de conhecimento entre as funções MAPE. Desta forma, ao construir uma camada de intermediação de serviços, devem ser descritas regras para identificação de sintomas, solicitações de mudanças e planos de mudança. Em tempo de execução, o monitor utiliza essas regras para identificar a ocorrência de um sintoma. De forma semelhante o analisar e planejador se baseiam nos sintomas identificados e nas solicitações de mudança geradas para realizarem sua tarefa.
A figura~\ref{fig:metamodelo-autonomo} ilustra as construções associadas a definição do mecanismo autonômico em um intermediador de serviços.

% A classe AutonomicManager agrupa os elementos relacionados à gerenciamento autonomico.

A classe \textsf{AutonomicManager} agrupa os elementos relacionados ao gerenciamento autônomo de recursos. Essa classe agrupa elementos que descrevem as regras para geração de sintomas, solicitações de mudanças e planos de mudança. 
A classe \textsf{Symptom} descreve um sintoma a ser monitorado com o intuito de identificar mudanças no contexto da camada. Um sintoma define um conjunto de condições para que este seja identificado. Em tempo de execução, os recursos e o estado da camada são monitorados e as condições de um sintoma avaliadas. Se todas as condições definidas em um sintoma são atingidas uma ocorrência deste sintoma é gerada e passada ao analisador.

As condições agrupadas pela classe \textsf{Symptom} são descritas a partir de expressões. Além das condições, a classe \textsf{Symptom} também define o contexto em que estas expressões serão avaliadas através da classe \textsf{Binding} que associa um nome (a ser usado na expressão) à um elemento do tipo \textsf{Bindable}. A interface \textsf{Bindable}, por sua vez, é implementada pelas classes \textsf{Signal} e \textsf{State}. Essas abstrações permitem definir condições que envolvam além de dados de chamadas e eventos o estado mantido pela camada.

% TODO: separar symptons devem monitorar só os recursos e change request deve relacionar symptons com calls and state

A classe \textsf{ChangeRequest} define uma requisição de mudança que deve ser gerada quando um determinado sintoma é identificado. Associado à uma requisição de mudança podemos ter um plano de mudança definido por instâncias da classe \textsf{ChangePlan}. No metamodelo proposto, um plano de mudança define uma ação a ser executada. Uma ação por sua vez pode ser composta de outras ações, conforme visto na seção \ref{sec:signals}.
% Enquanto a função de planejamento pode empregar algoritmos complexos que geram dinâmicamente planos  de mudança que podem envolver um workflow completo de execução, no trabalho em questão optamos por uma abordagem simples, onde um plano é diretamente associado a uma solicitação de mudança

%Referencia: The plan function can take on many forms, ranging from a single command to a complex workflow. 

\section{Políticas para seleção de recursos}

No metamodelo em questão, políticas são empregadas com o intuito de direcionar a seleção de recursos. As abstrações contempladas pelo metamodelo compreendem além da descrição de políticas, a definição do momento onde estas devem ser avaliadas, e como os resultados dessa avaliação devem ser tratados.

A figura~\ref{fig:metamodelo-politicas} demonstra as abstrações relacionadas à utilização de políticas, que se estruturam em torno da classe \textsf{PolicyManager}.
Os principais elementos da definição de políticas são representados por meio das classes \textsf{Policy}, \textsf{PolicyEvaluationPoint}, e \textsf{PolicyEvaluationHandler}.

A classe \textsf{Policy} representa uma política, que é definida por meio de um nome e uma condição a ser avaliada sobre um recurso. Além disso, uma política define um valor de negócio associado ao cumprimento de sua condição pelo recurso. Durante a execução da camada a seleção de recursos se baseia no valor de negócio acumulado na avaliação das políticas.

Um ponto de avaliação de políticas, definido por meio da classe \textsf{PolicyEvaluationPoint}, especifica um sinal que desencadeia a avaliação de políticas. Por meio deste elemento é possível especificar o momento em que as políticas devem ser avaliadas ou reavaliadas em relação aos recursos.

Após a avaliação das políticas, uma ação pode ser necessária





In the proposed meta-model policies are employed to drive the selection of resources. The class \textsf{PolicyManager} groups abstractions related to the definition of policies and their evaluation. These comprises \textsf{Policy} that identifies a policy, \textsf{PolicyEvaluationPoint} that defines when policy evaluation should be triggered, and \textsf{PolicyEvaluationHandler} that defines how the policy evaluation result should be handled. Besides that, the meta-model also includes auxiliary constructs for establishing links between these main elements.

As mentioned earlier, resources may be annotated with its features and properties.
A policy specifies a condition over a feature that may be present in resources, and the business value that is associated to the reaching of this condition.
At runtime, the resource that achieves the highest accumulated business value is selected among the available resources.


An evaluation point on is defined by specifying a signal which triggers the evaluation of policies and a policy evaluation handler that will be executed after the evaluation to handle its result. A policy evaluation point is linked to its handler by an instance of \textsf{PolicyEvaluationRequest} that is responsible for defining the parameter mapping between the context of the signal that triggers the evaluation, and that required for the evaluation itself. Finally, a policy evaluation handler defines an implementation class (similar to the a macro action) that may be executed upon the results of the policy evaluation processes.
%The scope of the policies is implicitly the set of resources associated to the same manager.



