\chapter{Referencial teórico}
\label{cap:referencial}

Neste capítulo revemos os conceitos sobre os quais o presente trabalho foi desenvolvido. 
Na Seção~\ref{sec:mde} tratamos dos princípios de abordagens de engenharia de software dirigida por modelos e seus fundamentos associados. 
A Seção~\ref{sec:referencial-cvm} fornece uma visão geral da máquina virtual de comunicação (CVM), descrevendo seu comportamento e sua arquitetura. Por fim, a Seção~\ref{sec:referencial-selfman} descreve a arquitetura de computação autônoma e políticas, como tecnologias utilizadas para a construção de sistemas auto-gerenciáveis.

\section{Engenharia dirigida por Modelos}
\label{sec:mde}


O termo \emph{Model-Driven Engineering} (MDE) é geralmente empregado para identificar o conjunto de abordagens que promovem o uso de modelos como os principais artefatos no processo de engenharia de software \cite{mde, mddcs}.
Nessas abordagens o uso de modelos não se limita à documentação ou compreensão de um sistema de software, mas pode abranger todas as áreas da engenharia de software, incluindo desde o seu desenvolvimento, até sua operação e manutenção.

%O surgimento de abordagens dirigidas por modelos evoluiu da crescente complexidade 
%complexidade das aplicações
%enquanto isso as tecnologias existentes...

O emprego de abordagens dirigidas por modelo evoluiu a partir da necessidade de lidar com a crescente complexidade encontrada no desenvolvimento de sistemas de software.
O avanço nas tecnologias de rede e processamento observado nas últimas décadas possibilitou a construção de aplicações cada vez mais elaboradas,  que comumente envolvem elementos de computação distribuída em ambientes heterogêneos que estão em constante mudança. 
%Além disso, aplicações atuais apresentam cada vez mais requisitos de disponibilidade, segurança, adaptabilidade, entre outros capazes de aumentar significativamente a complexidade de um sistema baseado em software.


O desenvolvimento dessas aplicações utilizando abordagens tradicionais de desenvolvimento, baseadas na codificação em linguagens de programação, exige um grande esforço. 
Apesar da notável evolução nas linguagens de programação,  suas construções continuam sendo em grande parte baseadas nas capacidades fornecidas pelo ambiente computacional, e assim não guardam relação direta com o problema a ser resolvido. A distância semântica entre o problema a ser resolvido e a plataforma utilizada na sua implementação é considerada um dos principais fatores que dificultam o desenvolvimento das aplicações atuais \cite{mde, mddcs}. 

%\begin{comment}
%
%%MDE evoluiu da complexidade do software...
%%Abstrações não evoluíram (baseadas em computação)
%Versão alternativa, que descreve de uma forma menos relacionada ao uso de domínio específico. A idéia é mencionar que as linguagens de programação não oferecem construções capazes de ocultar a complexidade envolvida no desenvolvimento dessas aplicações, e que o uso de modelos surge como uma alternativa para abstrair essas complexidades, tornando mais fácil a compreensão e construção dessas.
%
%
%Apesar disso, as linguagens de programação não evoluíram com a mesma velocidade, e suas abstrações não se demonstraram capazes de ocultar as complexidades envolvidas no desenvolvimento de software atual.
%%Apesar da evolução nas linguagens de programação, suas construções continuam sendo baseadas nas capacidades fornecidas pelo ambiente computacional, e portanto não guardam relação com o problema a ser resolvido.
%%O desenvolvimento de software desse jeito (utilizando abstrações inapropriadas) exige bastante esforço pois é preciso expressar conceitos do problema complexo em construções muito simples, fornecidas pela linguagem, e próximas da implementação.
%Nesse contexto, o uso de modelos surge como um meio de representar de forma abstrata algum aspecto de um sistema, ocultando detalhes desnecessários para sua compreensão. 
%
%Por meio de linguagens de modelagem mais apropriadas para descrição dos aspectos que compõem um sistema e ferramentas capazes de processá-los, de forma automatizada, em construções da plataforma de implementação, abordagens de MDE buscam ocultar a complexidade envolvida no desenvolvimento de aplicações.
%
%
%\end{comment}

%In the past two decades alone, the information technology (IT) industry has
%been a driving force of progress. Through the use of distributed networks,
%Web-based services, handheld devices, and cellular phones, companies of
%all sizes and across all industries are delivering sophisticated services that
%fundamentally change the tenor of daily life, from how we shop to how we
%bank to how we communicate.


Abordagens de MDE visam reduzir essa distância promovendo o uso de abstrações mais próximas ao domínio do problema, que são sistematicamente transformadas em construções do ambiente computacional. Nessas abordagens, modelos são utilizados como um meio de descrever um sistema de software sob diferentes aspectos e níveis de abstração, sendo então processados de forma automatizada em elementos da plataforma de implementação.

%Além de abstratos, os modelos empregados em abordagens de MDE são formais, o que possibilita que sejam processados de forma automatizada. 

A abordagem de arquitetura dirigida por modelos (\emph{Model-Driven Architecture}, MDA) \cite{mda} surgiu com o objetivo de definir funcionalidades do sistema de forma independente da plataforma de implementação, buscando a interoperabilidade e portabilidade do sistema. A MDA pode ser considerada como a primeira iniciativa a propor um conjunto de princípios e padrões para o uso sistematizado de modelos. O termo \emph{Model-Driven Engineering}, usado mais recentemente, propõe o uso de modelos de forma mais abrangente, e engloba além de MDA outras iniciativas como \emph{Model-Driven Development} (MDD) \cite{pragMDE, mddesign}, e \emph{Model-Integrated Computing} (MIC) \cite{mic}, entre outras.
% \cite{scopeMDE}

A maior parte das abordagens de MDD propõe a construção de linguagens de modelagem e transformações capazes de transformar modelos descritos por meio dessas linguagens em artefatos da plataforma de implementação. A abordagem MIC pode ser considerada como uma aplicação de MDD, e propõe a construção de ambientes de desenvolvimento específicos de domínio que compreendem linguagens de modelagem específicas de domínio, transformadores e ferramentas que auxiliam na construção de aplicações naquele domínio. %Além disso, várias outras abordagens propõem o uso de modelos para definição de diferentes aspectos como (citar aspectos e citação).
% mencionar mrt

%The MDE approach has not a unique goal. Among the objectives pursued, one may list the separation from business-neutral descriptions and platform dependent imple-mentations, the identification, precise expression, separation and combination of specific aspects of a system under development with domain-specific languages, the establishment of precise relations between these different languages in a global framework and in particular the possibility to express operational transformations between them 

%More than five years after, the situation has much evolved. Separating platform dependent from platform independent aspects is no more seen as the unique goal. The major problem is now the separation and combination of concerns in the construction and maintenance of information systems. Among these concerns, platform dependent and independent aspects remains important in the agenda, but these are more and more considered as a special case of a general problem including for example separation of functional and non-functional requirements. MDA and DSL solutions are now more and more closely related. What MDA is bringing to DSLs is this idea of using a collection of metamodels to capture the various facets of a system under construction or under maintenance. What DSLs is bringing to MDA is that a unique general purpose language, even a very large one like UML 2.0, is not able and will never be able to capture all the needs of the designers, administrators, and users of a given system.

Apesar de empregarem modelos com diferentes objetivos, essas abordagens apresentam várias similaridades, sendo por vezes sobrepostas. 
A engenharia dirigida por modelos busca sistematizar o uso de modelos, de forma que possam ser empregados com diversos objetivos em todas as atividades da engenharia de software. 
Dessa forma, o princípio básico da engenharia dirigida por modelos propõe o uso de modelos como objetos de primeira classe, utilizados na construção de todos os artefatos de software \cite{searchPrinciple, Unifying}.

%Considering everything as a model in a software  development approach  has  many consequences that we are progressively discovering. This paper has probably shown  only some of them. Besides the advantages of conceptual simplicity, this also leads to clear architecture, efficient implementation, high scalability  and  good  flexibility

Apesar de ser considerada uma abordagem recente de engenharia de software, a engenharia dirigida por modelos se baseia em idéias de várias outras abordagens como linguagens específicas de domínio, programação orientada por linguagens, programação generativa e programação dirigida por domínio, entre outras \cite{Unifying}.
Nesse contexto, a engenharia dirigida por modelos surge como uma tentativa de sistematizar o uso de modelos, apoiando-se em técnicas e princípios já existentes.
% sistematizado de várias dessas abordagens, sendo consideradas compatíveis com o princípio \cite{ts,Towards a Basic Theory to Model Model Driven}.

%On the Applicability Scope of Model Driven Engineering


%The term Model-Driven Engineering is commonly used to describe a set of software engineering approaches that employ models as their primary artifacts. In these approaches, the use of models is not restricted to the documentation or design of software, but may extend throughout the software engineering process.
%
%Models are usually described in domain-specific modeling languages, and processed by automated tools into constructs of the implementation platform \cite{Schmidt}. The use of domain-specific models switches the focus of software engineering from implementation technologies to problem-level abstractions.
%Nonetheless, automation in the processing of high-level models into software implementation requires encoding substantial domain-specific knowledge into the language and processing tools
%
%A modeling language is described using a  metamodel, which is itself a model that defines the abstractions available in the domain and how they interrelate. Metamodeling techniques have been standardized by the OMG Meta-Object Facility \cite{mof241}, but there are several tools, such as the Eclipse Modeling Framework \cite{emf}, that provide metamodeling capabilities.
%
%Domain-specific models may be transformed into artifacts of the implementation platform or directly executed by a model interpreter. The use of model interpreters has the potential of facilitating the processing of models at runtime in order to adapt a running application. This usage of models has been proposed as an alternative to deal with the growing complexity of contemporary software \cite{FranceEtAl}.
%
%The use of models at runtime seeks to use better abstractions for manipulating and inspecting a running system. Models at runtime bear a certain resemblance with reflection in which both deal with self-representations of a system that are causally connected. However, models at runtime use representations that are closer to the problem domain, in contrast with reflection, whose representations tend to be based on the implementation platform \cite{Blair2009}.

\subsection{Modelos}
%\begin{comment}
%Talvez integrar essa subseção ao conteúdo anterior.
%\end{comment}

%Um modelo é geralmente como uma representação simplificada de algum aspecto de um sistema. Através de modelos que representam

%Em abordagens de MDE, um modelo é uma representação abstrata de algum aspecto de um sistema.


%"A model is a simplification of a system built with an intended goal in mind. The model should be able to answer questions in place of the actual system." [5].
%- abstract but formal, first class entities, visual or textual, abstract differente aspects (even runtime)
%- Considering models as first class entities and any software artifact as a model element is one of the basic principles of MDE.

Um modelo é geralmente utilizado como um meio de representar simplificadamente algum aspecto de um sistema.
%, facilitando a compreensão de sistemas mais complexos
%Em abordagens de MDE, um modelo é uma representação abstrata e formal de algum aspecto de um sistema.
Um modelo descreve um sistema de acordo com uma perspectiva, ocultando informações que não estão relacionadas à natureza dessa perspectiva. Modelos podem ser empregados para capturar informações sobre um sistema existente, ou para descrever um sistema a ser construído.
Um sistema complexo, por sua vez, é representado por meio de um conjunto de modelos, que capturam diferentes aspectos em diversos níveis de abstração. 

Em abordagens de MDE, um modelo não é apenas um diagrama ou uma outra representação visual, mas sim uma definição formal dos conceitos a serem representados \cite{WhatModelsMean}. Nessas abordagens, o uso de modelos vai além da análise e projeto de um sistema, podendo ser utilizado em todas as atividades relacionadas à engenharia de software. 
O emprego de modelos formalmente definidos possibilita que modelos representando visões abstratas de um sistema sejam processados de forma automatizada, resultando em artefatos de implementação.
%Nessas abordagens, modelos são representações formais e sem ambiguidades, passíveis de serem processadas de forma automatizada.

Modelos são formalizados por meio de linguagens de modelagem, cujas construções são definidas por um metamodelo. Um metamodelo, que também é um modelo, formaliza os conceitos fornecidos pela linguagem de modelagem, e define como estes estão relacionados.

%O emprego de abordagens dirigidas por modelos está geralmente associado ao denvolvimento de sistemas por meio de abstrações de nível mais elevado que o encontrado em linguagens de programação. Para isto, são construídos modelos que descrevem os requisitos, arquitetura,



%De acordo com o nível de abstração de um modelo, este pode ser construído por desenvolvedores de software, especialistas de domínio, ou até mesmo por usuários finais.

% a model of the system is not just a drawing in some design document anymore but a set of formal concepts and elements [39].
 
% In a MDE system, a model is a consistent and complete set of formal elements describing a system that is amenable to analysis 

%Model driven engineering offers the potential for automatic transformation of high-level, abstract application subject matter models into running systems. 

\subsection{Metamodelagem}
Conforme mencionado na seção anterior, modelos são construídos em conformidade com uma linguagem de modelagem. Assim como outras linguagens formais, uma linguagem de modelagem é definida por sua sintaxe e semântica. 
A sintaxe de uma linguagem de modelagem pode ainda ser divida em sintaxe concreta, que representa sua notação textual ou gráfica, e sintaxe abstrata que representa os conceitos disponíveis na linguagem e como eles se relacionam. A semântica, por sua vez, também é  tratada separadamente como semântica estática, que define critérios para que modelos sejam considerados válidos, e a semântica dinâmica que define o significado dos modelos ao serem executados.

%A sintaxe de uma linguagem é tradicionalmente definida por meio de gramáticas na forma Backus-Naur (BNF), que descrevem regras para derivação de sequências válidas. Apesar de possibilitarem a definição formal de  linguagens, o uso de gramáticas BNF se limita a descrição de linguagens textuais e 
A sintaxe abstrata e a semântica estática de uma linguagem de modelagem são comumente formalizadas por meio de um metamodelo.
Um metamodelo é um modelo que descreve um conjunto de abstrações e como estas se relacionam. 
As abstrações descritas por um metamodelo representam as construções que irão compor a linguagem por ele formalizada.
%Assim sendo, o metamodelo deve incluir elementos relacionados ao aspecto e nível de abstração da linguagem por ele descrito.
Assim sendo, os elementos do metamodelo devem estar relacionados ao nível de abstração da linguagem por ele descrita e também ao aspecto do sistema a ser descrito por meio dessa linguagem.


Por se tratar de um modelo, um metamodelo também é construído por meio de uma linguagem de modelagem. Esta meta-linguagem, por sua vez, também é definida através de um metamodelo, que neste caso é chamado de meta-metamodelo. 

A construção de modelos e metamodelos foi padronizada pelo OMG (\emph{Object Management Group}) por meio de uma arquitetura de metamodelagem denominada \emph{Meta-Object Facility} (MOF) \cite{mof241}. A especificação da MOF descreve uma arquitetura de quatro camadas, ilustrada na Figura~\ref{fig:referencial-mof}, onde os elementos em uma determinada camada são definidos como instâncias de elementos da camada imediatamente superior. 
A camada mais superior, denominada M3, também integra a especificação da MOF, e representa o meta-metamodelo, que pode ser utilizado para a construção de metamodelos.
O modelo da camada M3, também denominado de modelo MOF, é formalizado por meio de suas próprias abstrações, o que elimina a necessidade de um outro nível de metamodelagem.

\begin{figure}
 \centering
 \includegraphics[width=0.75\textwidth]{./fig/mof}
 \caption{Arquitetura de metamodelagem da MOF.}
 \label{fig:referencial-mof}
\end{figure}


A partir do modelo da camada M3, é possível construir metamodelos que descrevem a sintaxe abstrata e semântica estática de linguagens de modelagem para diversos fins. 
Exemplos de linguagens de modelagem definidas a partir do modelo MOF incluem a \emph{Unified Modeling Language} (UML) e \emph{Common Warehouse Metamodel} (CWM), também padronizadas pelo OMG.
Essas linguagens integram a camada M2 da arquitetura da MOF, e são utilizadas para construir os modelos que integram o nível M1.
Os modelos da camada M1, por sua vez, são representações de objetos existentes no nível M0, que podem ser considerados como objetos do mundo real. 
Além disso, a especificação da MOF ainda define um padrão para representação de modelos no formato XMI (\emph{XML Metadata Interchange}).

O \emph{Eclipse Modeling Framework} (EMF) \cite{emf} é um \emph{framework} de modelagem que fornece um conjunto de ferramentas para construção e processamento de modelos. O EMF inclui um metamodelo denominado Ecore, que representa um subconjunto do modelo MOF correspondente às abstrações existentes em linguagens de programação orientadas a objetos.
O Ecore pode ser utilizado para construir modelos que representam o metamodelo de uma linguagem. Utilizado dessa forma, o Ecore assume a mesma função do nível M3 da arquitetura da MOF. O desenvolvimento do EMF e do Ecore influenciou a padronização da MOF 2.0, que passou a contar com um metamodelo equivalente ao Ecore, denominado \emph{Essential MOF} (EMOF) \cite{mof241}.

%EMF Relation to OMG MOF

%For those of you that are familiar with OMG (Object Management Group) MOF (Meta Object Facility), you may be wondering how EMF relates to it. Actually, EMF started out as an implementation of the MOF specification but evolved from there based on the experience we gained from implementing a large set of tools using it. EMF can be thought of as a highly efficient Java implementation of a core subset of the MOF API. However, to avoid any confusion, the MOF-like core meta model in EMF is called Ecore.

%In the current proposal for MOF 2.0, a similar subset of the MOF model, which it calls EMOF (Essential MOF), is separated out. There are small, mostly naming differences between Ecore and EMOF; however, EMF can transparently read and write serializations of EMOF.


%\begin{comment}
%É necessário mencionar outras interpretações do metamodelo, como de uma ontologia do domínio?
%\end{comment}


%Model Driven Development: Code Generation or Model Interpretation?
%http://www.theenterprisearchitect.eu/archive/2010/06/28/model-drivendevelopment-code-generation-or-model-interpretation
%Domain-specific languages in practice: A user study on the success factors.
\subsection{Linguagens específicas de domínio}

Uma linguagem específica de domínio (\emph{Domain-Specific Language}, DSL) é uma linguagem de programação ou especificação, projetada com o objetivo de prover abstrações para a resolução de problemas em um determinado domínio.

Diferente de linguagens de propósito geral, que podem ser empregadas para um grande conjunto de tarefas em variados domínios, linguagens específicas de domínio normalmente estão restritas a um conjunto limitado de tarefas em um determinado domínio. Não obstante, DSLs apresentam um maior poder de expressividade na solução de problemas no seu domínio específico \cite{Mernik:2005:DDL:1118890.1118892, vanDeursen:2000:DLA:352029.352035}.

Os ganhos em expressividade tem como principal benefício o aumento da produtividade na construção de soluções. Além disso, o uso de conceitos e notações apropriadas próximas ao domínio pode permitir que especialistas de domínio, ou até mesmo usuários finais sejam capazes de construir aplicações \cite{endUser}.

Um domínio pode ser considerado como uma área de interesse delimitada. Podemos categorizar domínios como técnicos e de negócio \cite{mdsd, DSM}. Domínios técnicos estão diretamente relacionados aos aspectos tecnológicos de um software, como persistência, interfaces gráficas, bancos de dados etc. Domínios de negócio, por sua vez, estão relacionados com atividades econômicas ou profissionais, como telecomunicações, sistema bancário, seguros, vendas, entre outros. Apesar disso, essa separação é nebulosa, sendo que a delimitação de um domínio deve ser definida de acordo com o problema a ser resolvido.

A abordagem de engenharia dirigida por modelos fornece um conjunto de princípios e ferramentas para construção de linguagens de modelagem, que se adequam perfeitamente à construção de DSLs \cite{Kurtev:2006:MDF:1176617.1176632, mdetechnical}.
Através do uso de técnicas de metamodelagem  é possível especificar as construções dessas linguagens, que nesse caso são geralmente denominadas linguagens de modelagem específicas de domínio (\emph{Domain-Specific Modeling Languages}, DSMLs).

Ao mesmo tempo, grande parte do sucesso no emprego de abordagens dirigidas por modelos está associada ao emprego de DSMLs, sendo consideradas tecnologias que apresentam grande sinergia \cite{ChallengesSemantics, DSM, Kurtev:2006:MDF:1176617.1176632}. O uso de abordagens dirigidas por modelos em um domínio específico permite atingir um alto grau de automatização no processamento de modelos.
%Ao focar em um determinado domínio, é possível construir mecanismos para o processamento de modelos capazes de atingir um alto grau de automatização.

% something that is difficult - if not impossible - to achieve with general purpose languages. For isntance, UML was developed to be able to model all kinds of application domains, but it has not proven to be successfull in truly model-driven development \cite{DSM}

Apesar de metamodelos poderem ser empregados na descrição de DSMLs, sua capacidade limita-se à descrição da sintaxe abstrata e da semântica estática. A definição da sintaxe concreta é simples, e existem várias ferramentas que permitem descrever sua notação, seja ela textual ou gráfica, e o seu mapeamento para a sintaxe abstrata. 
A formalização da semântica dinâmica de uma DSML, no entanto, é bem mais complexa, e atualmente não há um método estabelecido como padrão \cite{Kurtev:2006:MDF:1176617.1176632}.

A semântica dinâmica de uma DSML é, na maior parte das situações, descrita informalmente, por meio de linguagem natural, e codificada na implementação do mecanismo responsável pelo processamento da DSML. A formalização da semântica dinâmica de linguagens de modelagem tem sido objeto de estudos, e tem o potencial de trazer vários benefícios, principalmente associados à geração automática de ferramentas \cite{ChallengesSemantics}.

Existem várias	 abordagens para descrição da semântica dinâmica de linguagens de modelagem as quais podem ser agrupadas nas seguintes categorias \cite{Clark}:

\begin{itemize}

\item Por tradução, onde a semântica da linguagem é definida por meio da tradução de seus conceitos em conceitos de uma outra linguagem cuja semântica já é estabelecida. %A semântica por tradução é formalizada por meio de um mapeamento entre as construções das linguagens.

\item Operacional, que descreve como os modelos descritos por meio da linguagem são processados. A semântica operacional é incorporada ao interpretador ou mecanismo responsável pelo processamento e execução dos modelos.

\item Por extensão, que possibilita a descrição da semântica como uma extensão de uma outra linguagem.

\item Denotacional, que é definida por meio de um mapeamento entre as construções da linguagem e um domínio semântico que engloba elementos matemáticos representando elementos primitivos de semântica.

\end{itemize}

Uma das abordagens proeminentes para definição de semântica de DSMLs por meio de tradução é denominada ancoragem semântica \cite{Chen:2005:TSA:1086228.1086236}. Nessa abordagem, a definição da semântica e se dá pelo mapeamento dos elementos da DSML em modelos computacionais, cuja semântica é bem definida, como máquinas de estado abstratas, sistemas de eventos discretos, autômatos etc. Outra abordagem baseada em tradução emprega regras de reescrita \cite{1240339}, que descrevem como os elementos de um modelo podem ser sucessivamente reescritos, até que representem elementos da linguagem alvo.

Outra técnica também empregada na formalização da semântica dinâmica de DSMLs consiste em incorporar comportamento ao metamodelo (\emph{behavior weaving}) \cite{weave}. Esta abordagem propõe uma forma de estender a linguagem de meta-metamodelagem para possibilitar a construção de metamodelos que incorporem a semântica operacional.

% Both approaches can be implemented by code in general-purpose languages
%There are standardized languages for defining both transformations and operational semantics, but they tend to be generic in a way that sometimes they do not provide greater advantage than the use of a general-purpose language.


\subsection{Modelos em tempo de execução}


Modelos também têm sido empregados com sucesso como um meio para lidar com a complexidade envolvida no gerenciamento de sistemas em tempo de execução.
O gerenciamento de sistemas que precisam ser monitorados, adaptados e evoluídos durante sua execução é realizado por meio da inspeção e manipulação de estruturas que representam o sistema em tempo de execução.
%No entanto, a representação de um sistema em execução se baseia nas construções da sua plataforma de execução, e não guarda qualquer ligação com as questões que são relevantes ao sistema em execução.

Nesse cenário, o uso de modelos em tempo de execução tem como intuito prover representações mais apropriadas dos elementos de um sistema em execução, ocultando a complexidade de sua plataforma de execução. Assim, os modelos representam interfaces que podem ser utilizadas por agentes para monitorar e manipular sistemas em execução.
De acordo com essa visão, os modelos são o meio pelo qual desenvolvedores ou outros agentes podem compreender, configurar e modificar o comportamento e estrutura de um sistema em execução  \cite{mddcs}.


Modelos de tempo de execução estão diretamente relacionados à reflexão computacional, visto que ambos buscam definir representações que refletem um sistema em execução e que possuem uma relação de causalidade com o mesmo.
No entanto, diferente da reflexão cujas representações estão associadas à plataforma de execução do sistema, modelos em tempo de execução empregam representações mais próximas ao domínio do problema \cite{mrt}. 
Assim como na reflexão computacional, modelos em tempo de execução podem ser empregados para capturar a estrutura ou comportamento de um sistema em execução, ou ainda, podem capturar outras facetas do sistema relacionadas ao domínio do problema.


\section{Máquina Virtual de Comunicação}
\label{sec:referencial-cvm}

A Máquina Virtual de Comunicação (\emph{Communication Virtual Machine}, CVM) é uma plataforma para especificação e realização de serviços de comunicação \cite{cvm}. Sendo uma plataforma dirigida por modelos, a CVM funciona por meio do processamento de modelos descritos em uma linguagem de modelagem específica de domínio, denominada Linguagem de Modelagem de Comunicação (\emph{Communication Modeling Language}, CML) \cite{cml}. Diferente de muitas abordagens dirigidas por modelo que se apoiam na geração de código, os modelos CML são diretamente interpretados pela CVM.

A CVM é considerada uma plataforma centrada no usuário devido ao alto nível dos modelos descritos por meio da CML, que podem ser facilmente construídos por usuários especialistas de domínio, ou até mesmo por usuários finais. A CML é uma linguagem declarativa, por meio da qual são descritos os participantes, dados, e tipos de mídia envolvidos em uma comunicação a ser realizada. Informações associadas às tecnologias e dispositivos efetivamente utilizados na realização da comunicação, não são descritos em um modelo CML. A Figura~\ref{fig:referencial-cml} apresenta um exemplo de modelo descrito utilizando a representação gráfica da CML. O modelo em questão define uma sessão de comunicação entre dois participantes por meio de áudio em tempo real.

\begin{figure}
 \centering
 \includegraphics[width=1\textwidth]{./fig/cml}
 \caption{Exemplo de modelo CML \cite{cvm}.}
 \label{fig:referencial-cml}
\end{figure}

A partir de um modelo CML, a CVM é capaz de realizar o serviço de comunicação descrito de forma automática, sem a necessidade de intervenção do usuário. Um modelo CML também pode ser modificado ao longo do curso de uma comunicação, sendo a CVM capaz de identificar essas mudanças e adaptar a comunicação em andamento para atender aos novos requisitos definidos. Devido a esta natureza, os modelos em CML podem ser considerados como modelos de desenvolvimento e de tempo de execução \cite{Wang}.

Para tornar isso possível, a CML e a CVM incorporam conhecimento relacionado à realização de serviços de comunicação, permitindo que modelos CML se limitem a descrever os aspectos específicos do serviço a ser realizado.
A CVM se baseia em uma arquitetura de camadas que encapsulam as tarefas necessárias à realização de um serviço de comunicação. Um modelo CML fornecido pelo usuário (ou aplicação) é sucessivamente processado e transformado pelas camadas da CVM, até que sejam geradas chamadas aos componentes que efetivamente realizam os serviços solicitados. A Figura~\ref{fig:referencial-cvm} ilustra as camadas que integram a CVM, descritas logo adiante.

\begin{figure}
 \centering
 \includegraphics[width=0.75\textwidth]{./fig/cvm}
 \caption{Arquitetura em camadas da CVM \cite{cvm}.}
 \label{fig:referencial-cvm}
\end{figure}


\begin{itemize}

\item Interface de Comunicação com o Usuário (\emph{User Communication Interface}, UCI). A UCI representa a interface para interação com a CVM, provendo meios para a definição e gerenciamento de modelos em CML. É por meio dessa interface que usuários ou aplicações podem solicitar a realização de uma sessão de comunicação descrita por um modelo, podendo também ser notificados sobre eventos ocorridos durante o seu andamento. Além disso, a UCI também conta com um ambiente de modelagem que permite que usuários construam modelos CML por meio de manipulação direta da representação gráfica. 

\item Mecanismo de Síntese (\emph{Synthesis Engine}, SE). O mecanismo de síntese é responsável por duas principais tarefas: a negociação de um modelo em CML recebido da UCI com os demais participantes de uma comunicação; e a transformação desse modelo em um \emph{script} de controle da comunicação, o qual contém a lógica para o estabelecimento da comunicação. O mecanismo de síntese implementa a semântica operacional da CML \cite{OperSemantic}, sendo o responsável por transformar os modelos declarativos descritos através da CML em \emph{scripts} executáveis pela camada seguinte.

\item \emph{Middleware} de Comunicação Centrado no Usuário (\emph{User-centric Communication Middleware}, UCM). A camada de \emph{middleware} da CVM, tem como função executar o \emph{script} de comunicação recebido do mecanismo de síntese e coordenar as sessões de comunicação. Além disso, cabe a esta camada garantir que sejam aplicadas as políticas de segurança, qualidade de serviço, entre outras relativas à comunicação.

\item Intermediador de Comunicação em Rede (\emph{Network Communication Broker}, NCB). A camada NCB provê uma interface de comunicação independente de tecnologia para ser utilizada pela camada de \emph{middleware}. O intermediador tem como função blindar a camada superior da heterogeneidade e complexidade envolvidas na interação com os componentes que efetivamente realizam a comunicação. Assim, a NCB recebe requisições da camada UCM e intermedia o acesso aos \emph{frameworks} de comunicação para que realizem a solicitação recebida.

\end{itemize}

A Máquina Virtual de Redes Elétricas Locais (\emph{Microgrid Virtual Machine}, MGridVM) \cite{microgrid} também utiliza essa arquitetura para a execução de modelos construídos por usuários para descrever requisitos para a utilização de energia elétrica em um ambiente local. 
A partir desses modelos a MGridVM gerencia a utilização de fontes de energia, cargas e baterias.

\subsection{Intermediador de Comunicação em Rede}

Como introduzido no Capítulo~\ref{cap:intro}, neste trabalho nos concentramos na camada de intermediação de serviços da arquitetura de máquinas de execução de modelos. 
Para melhor compreender a função da camada de intermediação de serviços, nesta seção descrevemos em mais detalhes o Intermediador de Comunicação em Rede (NCB) que integra a CVM.

A camada NCB foi projetada com o intuito de fornecer uma interface de serviços de comunicação independente da tecnologia de comunicação empregada, capaz de abstrair para a camada superior a heterogeneidade e dinâmica envolvidas na utilização de diversos provedores alternativos de comunicação \cite{cvm}.  Para isso, o intermediador de comunicação deve ser capaz de se auto-gerenciar, adaptando-se a mudanças no ambiente de rede, nos provedores de comunicação, ou nas solicitações recebidas da camada de \emph{middleware}.

Apesar de prever o uso de diversos provedores de comunicação, a versão inicialmente desenvolvida da NCB comportava apenas um provedor diretamente incorporado à sua implementação, limitando a qualidade e tipos de serviços de comunicação disponíveis. Em trabalhos seguintes \cite{SelfConfig}, a NCB foi ampliada para possibilitar a integração, e auto-configuração de vários \emph{frameworks} provedores de comunicação como Skype, Smack, Asterisk etc. Para o auto-gerenciamento da camada foi adotada a arquitetura de computação autônoma, e proposto o uso de políticas como meio de guiar decisões sobre a seleção de \emph{frameworks} de comunicação \cite{UCCAF} .

%\section{Reflexão computacional}

\section{Sistemas auto-gerenciáveis}
\label{sec:referencial-selfman}

Um sistema auto-gerenciável é aquele capaz de se adaptar de forma automática às mudanças nos seus requisitos e ambiente operacional.
O objetivo do auto-gerenciamento é reduzir a necessidade do uso de controles manuais para manter um sistema de acordo com os seus objetivos quando da ocorrência de mudanças em seu ambiente operacional ou requisitos \cite{selfManSystems}.

A construção de sistemas auto-gerenciáveis apresenta vários desafios cujas soluções envolvem diversas áreas de pesquisa, incluindo computação sensível ao contexto, inteligência artificial, adaptação dinâmica, entre outras.
Nesse contexto, arquiteturas de auto-gerenciamento surgem como uma abordagem para integração de soluções para os desafios envolvidos na realização da visão de sistemas auto-gerenciáveis \cite{archSelfMan, selfManSystems}.

Esta seção apresenta um resumo da arquitetura de computação autônoma proposta pela IBM para construção de sistemas auto-gerenciáveis e do uso de políticas para guiar o gerenciamento de sistemas. Ambos conceitos são empregados pela CVM e neste trabalho para prover capacidades de auto-gerenciamento.

\subsection{Computação autônoma}
\label{sec:referencial-autonomic}

A crescente complexidade dos sistemas baseados em software modernos tem dificultado não só a sua construção de aplicações, mas também a sua implantação, configuração e operação. A provisão de serviços que atendam às demandas atuais dos usuários muitas vezes exige a construção de aplicações capazes de  integrar vários vários recursos. 

Esses recursos, geralmente heterogêneos, podem incluir, além de componentes de software, bancos de dados, servidores de aplicações, aplicações legadas e,  até mesmo, subsistemas completos. Além disso, com a expansão das tecnologias de rede e Internet, esses recursos podem estar distribuídos em inúmeros dispositivos.
Nessa situação, até mesmo a implantação e gerenciamento de aplicações pode tornar-se uma atividade intratável, mesmo para especialistas em tecnologia da informação.

As dificuldades relacionadas à integração e gerenciamento desses sistemas complexos levaram ao surgimento de iniciativas \cite{visionAC, HPAdaptiveEnterprise, MicrosoftDynamicSystems} que propõem uma abordagem sistematizada para a construção de sistemas capazes de se auto-gerenciar. O emprego de mecanismos de computação autônoma, proposto pela IBM \cite{visionAC}, visa dotar os sistemas de software de capacidades similares àquelas presentes no sistema nervoso autônomo humano, que controla as funções vitais do organismo de forma inconsciente ao ser humano. De forma análoga, um sistema de computação autônoma é capaz de ajustar sua operação de acordo com mudanças no seu ambiente e nas demandas de usuários.

Conforme essa visão, um sistema autônomo deve possuir as seguintes capacidades de auto-gerenciamento:

\begin{itemize}

\item Auto-configuração: Capacidade de um sistema de automaticamente adaptar para atender mudanças em seu ambiente.

\item Auto-otimização: Capacidade de monitorar os recursos e realizar ajustes para aumentar a sua eficiência.

\item Auto-proteção: Capacidade de identificar e antecipar ataques, tomando as ações necessárias para se proteger.

\item Auto-recuperação: Capacidade de identificar problemas como falhas ou mal-funcionamento em recursos e tomar as ações necessárias para garantir a manutenção dos serviços fornecidos.

\end{itemize}

Para realizar essa visão, foi proposta uma arquitetura baseada em camadas para a construção de sistemas autônomos  \cite{ibmac} . A Figura~\ref{fig:referencial-ac} ilustra essa arquitetura, cujo elemento principal é o gerenciador autônomo. A camada mais inferior contém os recursos a serem gerenciados, que podem ser componentes de hardware ou software, e podem incorporar capacidades de auto-gerenciamento. A camada imediatamente acima representa os componentes de acesso aos recursos, denominados \emph{touchpoints}. Um \emph{touchpoint} representa uma interface padrão para interação com os recursos apresentando o comportamento de sensor e atuador para um ou mais recursos. Enquanto sensores tem como função observar o estado dos recursos gerenciados, atuadores são utilizados para efetuar mudanças nos mesmos.


%\begin{figure}
% \centering
% \includegraphics[width=1\textwidth]{./fig/aclayers}
% \caption{Arquitetura de computação autônoma.}
% \label{fig:referencial-ac}
%\end{figure}

O gerenciamento dos recursos é realizado por meio de gerenciadores autônomos e manuais. Gerenciadores autônomos de \emph{touchpoint} atuam diretamente sobre os recursos, interagindo com eles por meio de seus \emph{touchpoints}. Gerenciadores autônomos de orquestração gerenciam outros gerenciadores autônomos, coordenando diferentes grupos de recursos ou diferentes tarefas de gerenciamento. Por fim, um gerenciador manual fornece uma interface para que um profissional de tecnologia da informação possa intervir manualmente na gerência dos recursos.
Ao realizarem sua função, os gerenciadores autônomos e manuais podem obter e compartilhar informações, que neste caso são chamadas de conhecimento e mantidas em fontes de conhecimento. Em um sistema autônomo são considerados como conhecimento tipos de dados particulares como sintomas, políticas, solicitações e planos de mudança.

O elemento principal da arquitetura de computação autônoma é o gerenciador autônomo, que implementa um ciclo de controle que realiza as funções de monitoramento, análise, planejamento e execução (MAPE). Essas funções, conjuntamente, são responsáveis por monitorar os recursos e eventualmente tomar a ação apropriada em resposta a alguma mudança. Durante a sua execução essas funções são influenciadas pelos dados mantidos em uma fonte de conhecimento e interagem por meio da troca de dados como sintomas, solicitações de mudança e planos de mudanças, também tratados como conhecimento.

A Figura~\ref{fig:referencial-ac-am} mostra uma visão conceitual do gerenciador autônomo, onde podem ser identificados os elementos que implementam as funções do ciclo de controle:

%\begin{figure}
% \centering
% \includegraphics[width=0.7\textwidth]{./fig/am}
% \caption{Gerenciador autônomo.}
% \label{fig:referencial-ac-am}
%\end{figure}

\begin{figure}
\centering
\subfigure[] {
	\includegraphics[width=0.35\textwidth]{./fig/arch-autonomic}
	\label{fig:referencial-ac} } \qquad
\subfigure[] {
\includegraphics[width=0.5\textwidth]{./fig/am}
\label{fig:referencial-ac-am} }
\caption{{\subref{fig:referencial-ac}} Arquitetura de computação autônoma \\ {\subref{fig:referencial-ac-am}} Gerenciador autônomo \cite{ibmac}.}
\label{fig:subfiguras} \end{figure}


\begin{itemize}

\item Monitor, que é responsável por coletar, agregar e filtrar informações coletadas de recursos gerenciados por meio de sensores, identificando sintomas relevantes para a análise do estado do recurso.

\item Analisador, que analisa os sintomas gerados pelo monitor e determina se alguma mudança é necessária, gerando uma solicitação de mudança.

\item Planejador, que fornece meios para construção de planos de mudança que determinam quais ações devem ser tomadas em resposta a uma solicitação de mudança recebida.

\item Executor, que coloca um plano de mudança em prática, interagindo com os atuadores para executar as ações definidas pelo plano.

\end{itemize}

Como ilustrado na parte superior da Figura~\ref{fig:referencial-ac-am}, o gerenciador autônomo também expõe as mesmas interfaces de sensores e atuadores, permitindo que um gerenciador autônomo seja utilizado por um gerenciador autônomo orquestrador. Além disso, políticas podem ser utilizadas para direcionar o comportamento de um gerenciador autônomo, as quais também são consideradas como conhecimento.


A aplicação de abordagens dirigidas por modelos em conjunto com essa arquitetura de computação autônoma pode ser muito benéfica.
O uso de técnicas de metamodelagem possibilita a formalização da estrutura do conhecimento utilizado para direcionar o comportamento autônomo.
Modelos podem ser empregados na representação de políticas, sintomas, solicitações e planos de mudança, além de outros conhecimentos relacionados aos recursos gerenciados. 
%Modelos em tempo de execução também podem ser utilizados como um meio de interagir com a interface de gerenciador manual.
%O uso de modelos em tempo de execução permite que agentes manuais ou automáticos sejam utilizados para dirigir o gerenciamento dos sistem \cite{mrt}.


\subsection{Políticas de gerenciamento}

O uso de políticas no gerenciamento de sistemas tem como intuito isolar as regras que controlam o gerenciamento de um sistema de sua funcionalidade \cite{pbm}. Essa separação visa reduzir o esforço exigido na manutenção de sistemas e aumentar a sua flexibilidade e adaptabilidade.
Nesse contexto, políticas são utilizadas como um meio de definir objetivos de alto nível, que direcionam o comportamento do sistema. 
Devido a isto, o uso de políticas está incorporado a várias arquiteturas e abordagens de auto-gerenciamento de sistemas, incluindo a de computação autônoma.

Políticas podem ser utilizadas para definir regras para se atingir diversos objetivos de gerenciamento, como escalabilidade, desempenho, otimização do uso de recursos, flexibilidade etc. Políticas são definidas por linguagens de definição de políticas, que oferecem meios para especificar regras que podem ser mapeadas para ações de gerenciamento de um sistema.
O uso de políticas para auto-gerenciamento de sistemas guarda semelhanças com técnicas de MDE, pois se baseia na construção de representações formais de políticas por meio de linguagens, e na sua aplicação de forma automatizada.

Há uma grande diversidade entre as linguagens para definição de políticas, que variam de acordo com os aspectos a serem gerenciados ou o domínio aplicado. Apesar disso, algumas linguagens de políticas buscam oferecer construções mais genéricas que podem ser utilizadas para uma gama maior de sistemas. 

A PDL (\emph{Policy Definition Language})  \cite{pdl} considera uma política como um conjunto de regras que determinam o comportamento esperado de um sistema e propõe a definição de políticas por meio de regras do tipo Evento-Condição-Ação (ECA). Ponder \cite{ponder} é uma linguagem orientada a objetos declarativa para especificação de políticas de segurança baseada em papéis e políticas de gerenciamento de propósito geral. A linguagem Ponder estende a abordagem baseada em regras do tipo ECA, que passam a ser utilizadas na composição de outros tipos mais elaborados de políticas, que incluem obrigações, restrições, delegações, papeis, relacionamentos etc. \emph{Policy Management for Autonomic Computing} (PMAC) \cite{pmac} é uma plataforma de políticas para o gerenciamento de vários aspectos de sistemas distribuídos de larga escala. Na PMAC, uma política é uma regra que contempla condições, ações, prioridade e papel. A plataforma proposta pela PMAC se integra com a arquitetura de computação autônoma proposta pela IBM, sendo o gerenciador autônomo considerado um gerenciador baseado em políticas e, assim, suas funções MAPE operam de acordo com um conjunto de políticas.

O uso de linguagens de políticas mais específicas ou genéricas é uma questão sujeita a debates, assim como na área de linguagens de programação. Entretanto, sob uma ótica mais abrangente de abordagens de MDE, linguagens de política são necessariamente de propósito específico e podem ser consideradas como uma linguagem específica de domínio.
Na implementação da camada NCB da CVM, políticas são utilizadas para direcionar a seleção de \emph{frameworks} de comunicação \cite{foda, UCCAF}.

%The approach to policies in this dissertation is in the vein of domain specific specialization, focused more on providing a semantic rich language for specifying domain specific policies. The systematic approach to understand and define policies detailed later in this dissertation can be applied to other domains of interest. The author notes that while an explicit policy specification is described in this dissertation, other policy languages could be used to specify the artifacts of systematic domain analysis.
%
%
% Policy Management for Autonomic Computing (PMAC) [1], is another policy language for the management of aspects (quality of service (QoS), configuration) of large-scale distributed system. PMAC additionally includes integratable software
%
% direcionar o gerenciamento de sistemas por meio da definição objetivos de alto nível, que podem 
%
%Policy-Based Management (PBM) is a management paradigm that separates the rules governing the behavior of
%a system from its functionality. 
%It promises to reduce maintenance costs of information and communication systems while improving ?exibility and runtime adaptability. 
%
%It is today present at the heart of a multitude of management
%architectures and paradigms including SLA-driven, Business-driven, autonomous, adaptive, and self-* management
%-----
%Many different techniques can be used to implement self management. 
%After detailed investigation, policy based computing has been selected as the core self-management technology.
%extensivamente aplicada para o auto-gerenciamento
%
%D.C. Robinson and M. Sloman [25] view Management policy to be the sets of rules 
%for achieving the scalable management of a distributed computing system,
% as well as achieving the sub-objectives of optimizing resource
%usage, cost, revenue, and performance. 
%The requirements of scalability, ?exibility, uniformity, and veri?ability are
%believed to be achievable through policies and management domains
%25: Domains: a new approach to distributed system management
%---
%PDL [56] is a declarative policy de?nition language for information systems management developed by Bell
%Labs. It de?nes a policy as a collection of general principles specifying the desired behavior of a system. Policies11
%are formulated using the Event-Condition-Action (ECA) rule paradigm of active databases and are supported by a
%rich event sub-language for un-interpreted concurrent actions.
%
%Policies... policy types
%The Policy Description Language (PDL) [4] is an 
%example of the use of statically configured policies. 
%PDL is used to specify policy agents, which perform 
%distributed network management tasks [5]. 
%The Policy Management for Autonomic Computing 
%(PMAC), [6] from IBM, is an example of a policy 
%technology that supports open-loop adaptation. An 
%automated policy management and deployment 
%application is provided to assist manual policy updates. 
%A further tool, the Policy Schedule Advisor assists in 
%refining a policy schedule to ensure efficient execution 
%on the PMAC middleware [7]. Policyscape [8] also 
%supports automated policy creation. It provides a set of 
%building blocks from which more-complex policies can 
%be created.
%
%policies are employed in NCB for... \cite{ncbPolicies}
%
%We base our work in the NCB 

\subsection{Considerações finais}

Neste capítulo descrevemos a Máquina Virtual de Comunicação (CVM), destacando sua arquitetura e o funcionamento de sua camada de intermediação de serviços. Para isso, revemos os fundamentos de abordagens de engenharia de software dirigida por modelos, que são utilizados na CVM para possibilitar a construção de serviços de comunicação por meio de modelos de alto nível.
Além disso, também tratamos dos princípios relacionados à construção de sistemas auto-gerenciáveis, que são empregados na camada de intermediação de serviços da arquitetura da CVM.
Os conceitos discutidos nesse capítulo tem como intuito fornecer um referencial para a compreensão do presente trabalho.
%, que propõe uma abordagem dirigida por modelos para construção máquinas de execução de modelos, se concentrando na camada de intermediação de serviços.

