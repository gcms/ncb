\chapter{Referencial teórico}
\label{cap:referencial}


\section{Engenharia dirigida por Modelos}
\label{sec:mde}

Não esquecer:::
More than five years after, the situation has much evolved. Separating platform dependent from platform independent aspects is no more seen as the unique goal. The major problem is now the separation and combination of concerns in the construction and maintenance of information systems. Among these concerns, platform dependent and independent aspects remains important in the agenda, but these are more and more considered as a special case of a general problem including for example separation of functional and non-functional requirements. MDA and DSL solutions are now more and more closely related. What MDA is bringing to DSLs is this idea of using a collection of metamodels to capture the various facets of a system under construction or under maintenance. What DSLs is bringing to MDA is that a unique general purpose language, even a very large one like UML 2.0, is not able and will never be able to capture all the needs of the designers, administrators, and users of a given system.


The term Model-Driven Engineering is commonly used to describe a set of software engineering approaches that employ models as their primary artifacts. In these approaches, the use of models is not restricted to the documentation or design of software, but may extend throughout the software engineering process.
%By employing models based on abstractions closer to the problem to be solved, model-driven approaches seek to abstract technical details of the underlying platform, therefore simplifying the engineering of software. To make it feasible, these approaches rely on automated tools for the processing of models into constructs of the implementation platform.

Models are usually described in domain-specific modeling languages, and processed by automated tools into constructs of the implementation platform \cite{Schmidt}. The use of domain-specific models switches the focus of software engineering from implementation technologies to problem-level abstractions.
Nonetheless, automation in the processing of high-level models into software implementation requires encoding substantial domain-specific knowledge into the language and processing tools

A modeling language is described using a  metamodel, which is itself a model that defines the abstractions available in the domain and how they interrelate. Metamodeling techniques have been standardized by the OMG Meta-Object Facility \cite{Omg_2006}, but there are several tools, such as the Eclipse Modeling Framework \cite{emf}, that provide metamodeling capabilities.

Domain-specific models may be transformed into artifacts of the implementation platform or directly executed by a model interpreter. The use of model interpreters has the potential of facilitating the processing of models at runtime in order to adapt a running application. This usage of models has been proposed as an alternative to deal with the growing complexity of contemporary software \cite{FranceEtAl}.

The use of models at runtime seeks to use better abstractions for manipulating and inspecting a running system. Models at runtime bear a certain resemblance with reflection in which both deal with self-representations of a system that are causally connected. However, models at runtime use representations that are closer to the problem domain, in contrast with reflection, whose representations tend to be based on the implementation platform \cite{Blair2009}.

\subsection{Modelos}

Em abordagens de MDE, um modelo é uma representação abstrata e formal de algum aspecto de um sistema.
Um modelo descreve um sistema de acordo com uma perspectiva, ignorando informações que não estão relacionadas à sua natureza.
Um sistema complexo, por sua vez, pode ser descrito por diversos modelos que capturam diferentes aspectos sob variados níveis de abstração. 
De acordo com o nível de abstração de um modelo, este pode ser construído por desenvolvedores de software, especialistas de domínio, ou até mesmo por usuários finais.
O uso de modelos formalmente definidos, em acordo com uma linguagem de modelagem, possibilita que os modelos que descrevem um sistema sejam processados automaticamente em elementos associados à implementação do sistema.

modelos podem apresentar representações gráficas ou textuais


%De acordo com o nível de abstração de um modelo, este pode ser construído por desenvolvedores de software, especialistas de domínio, ou até mesmo por usuários finais.

% a model of the system is not just a drawing in some design document anymore but a set of formal concepts and elements [39].
 
% In a MDE system, a model is a consistent and complete set of formal elements describing a system that is amenable to analysis 

%Model driven engineering offers the potential for automatic transformation of high-level, abstract application subject matter models into running systems. 

\subsection{Metamodelagem}
Conforme mencionado na seção anterior, modelos são construídos em conformidade com uma linguagem de modelagem. Assim como outras linguagens formais, uma linguagem de modelagem é definida por sua sintaxe e semântica. 
A sintaxe de uma linguagem de modelagem pode ainda ser divida em sintaxe concreta, que representa sua notação textual ou gráfica, e sintaxe abstrata que representa os conceitos disponíveis na linguagem e como estes se relacionam. A semântica, por sua vez, também é comumente tratada separadamente como semântica estática, que define critérios para que modelos sejam considerados válidos, e a semântica dinâmica que dá significado aos modelos.

%A sintaxe de uma linguagem é tradicionalmente definida por meio de gramáticas na forma Backus-Naur (BNF), que descrevem regras para derivação de sequências válidas. Apesar de possibilitarem a definição formal de  linguagens, o uso de gramáticas BNF se limita a descrição de linguagens textuais e 
A sintaxe abstrata e semântica estática de uma linguagem de modelagem são comumente formalizadas por meio de um metamodelo. Um metamodelo é um modelo que descreve um conjunto de abstrações e como estas estão relacionadas. As abstrações descritas por um meta-modelo representam as construções que irão compor a linguagem por ele formalizada. Assim sendo, o meta-modelo deve incluir elementos relacionados ao aspecto e nível de abstração da linguagem por ele descrito.

Por também se tratar de um modelo, um meta-modelo também é construído por meio de uma linguagem de modelagem. Esta meta-linguagem, por sua vez, também é definida através de um metamodelo, que neste caso é chamado de meta-metamodelo. 

A construção de modelos e meta-modelos foi padronizada pela OMG por meio de uma arquitetura de metamodelagem denominada \emph{Meta-Object Facility} (MOF) \cite{Omg_2006}. A especificação da MOF descreve uma arquitetura de quatro camadas, ilustrada na figura~\ref{fig:referencial-mof}, onde os elementos em uma determinada camada são definidos como instâncias de elementos da camada imediatamente superior. A camada mais superior, denominada M3, também integra a especificação da MOF, e representa o meta-metamodelo, que pode ser utilizado para a construção de metamodelos. O modelo da camada M3, também denominado de modelo MOF, é formalizada por meio de suas próprias abstrações, tornando desnecessária a existência de um outro nível de metamodelagem.

\begin{figure}
 \centering
 \includegraphics[width=1\textwidth]{./fig/mof}
 \caption{Arquitetura de metamodelagem da MOF.}
 \label{fig:referencial-mof}
\end{figure}


A partir do modelo da camada M3, é possível construir metamodelos que descrevem a sintaxe abstrata e semântica estática de linguagens de modelagem para diversos fins. Exemplos de linguagens de modelagem definidas a partir do modelo MOF incluem a .... Essas linguagens integram a camada M2 da arquitetura da MOF, e são utilizadas para construir os modelos que integram o nível M1. Os modelos da camada M1, por sua vez, são representações de objetos existentes no nível M0. O significado da camada M0 é controverso, e pode ser considerado como um objeto do mundo real, ou um fenômeno da execução de software, de acordo com a natureza do modelo na camada M1. Além disso, a especificação da MOF ainda define um padrão para representação de modelos no formato XMI (\emph{XML Metadata Interchange}).

O \emph{Eclipse Modeling Framework} (EMF) é um \emph{framework} de modelagem que fornece um conjunto de ferramentas para construção e processamento de modelos. O EMF inclui um metamodelo denominado Ecore, que representa um subconjunto do modelo MOF que correspondente às abstrações existentes em linguagens de programação orientadas a objetos. O Ecore pode ser utilizado para construir modelos que representam um meta-modelo de uma linguagem. Utilizado dessa forma, o Ecore assume a mesma função do nível M3 da arquitetura da MOF. O desenvolvimento do EMF e Ecore influenciaram a padronização da MOF 2.0, que passou a contar com um metamodelo equivalente ao Ecore, denominado \emph{Essential MOF} (EMOF).

%EMF Relation to OMG MOF

%For those of you that are familiar with OMG (Object Management Group) MOF (Meta Object Facility), you may be wondering how EMF relates to it. Actually, EMF started out as an implementation of the MOF specification but evolved from there based on the experience we gained from implementing a large set of tools using it. EMF can be thought of as a highly efficient Java implementation of a core subset of the MOF API. However, to avoid any confusion, the MOF-like core meta model in EMF is called Ecore.

%In the current proposal for MOF 2.0, a similar subset of the MOF model, which it calls EMOF (Essential MOF), is separated out. There are small, mostly naming differences between Ecore and EMOF; however, EMF can transparently read and write serializations of EMOF.


\begin{comment}
É necessário mencionar outras interpretações do metamodelo, como de uma ontologia do domínio?
\end{comment}


%Model Driven Development: Code Generation or Model Interpretation?
%http://www.theenterprisearchitect.eu/archive/2010/06/28/model-drivendevelopment-code-generation-or-model-interpretation
%Domain-specific languages in practice: A user study on the success factors.
\subsection{Linguagens específicas de domínio}

Uma linguagem específica de domínio (\emph{Domain-Specific Language}, DSL) é uma linguagem de programação ou especificação, projetada com o objetivo de prover abstrações voltadas para a resolução de problemas um determinado domínio.

Diferente de linguagens de propósito geral, que podem ser empregadas para um grande conjunto de tarefas em variados domínios, linguagens específicas de domínio normalmente estão restritas a um conjunto limitado de tarefas em um determinado domínio. Não obstante, DSLs apresentam um maior poder de expressividade na solução de problemas no seu domínio específico \cite{Mernik:2005:DDL:1118890.1118892, vanDeursen:2000:DLA:352029.352035}.

Os ganhos em expressividade tem como principal benefício o aumento da produtividade na construção de soluções. Além disso, o uso de conceitos e notações apropriadas próximas ao domínio pode permitir que especialistas de domínio, ou até mesmo usuários finais sejam capazes de construir aplicações \cite{endUser}.

Um domínio pode ser considerado como uma área de interesse bem delimitada. Podemos categorizar domínios como técnicos e de negócio \cite{mdsd, DSM}. Domínios técnicos estão diretamente relacionados aos aspectos tecnológicos de um software como persistência, interfaces gráficas, bancos de dados, etc. Domínios de negócio, por sua vez, estão relacionados à atividades econômicas ou profissionais como telecomunicações, sistema bancário, seguros, vendas, entre outros. Apesar disso, essa separação é nebulosa, sendo que a delimitação de um domínio deve ser definida de acordo com o problema a ser resolvido.

A abordagem de engenharia dirigida por modelos fornece um conjunto de princípios e ferramentas para construção de linguagens de modelagem, que se adequam perfeitamente à construção de DSLs \cite{Kurtev:2006:MDF:1176617.1176632}.
Através do uso de técnicas de metamodelagem  é possível especificar as construções dessas linguagens, que nesse caso são geralmente denominadas linguagens de modelagem específicas de domínio (\emph{Domain-Specific Modeling Languages}, DSMLs).

Ao mesmo tempo, grande parte do sucesso no emprego de abordagens dirigidas por modelos está associada ao emprego de DSMLs, sendo consideradas tecnologias que apresentam grande sinergia \cite{ChallengesSemantics, DSM, Kurtev:2006:MDF:1176617.1176632}. O emprego de abordagens dirigidas por modelos em um domínio específico permite atingir um alto grau de automatização no processamento de modelos.
%Ao focar em um determinado domínio, é possível construir mecanismos para o processamento de modelos capazes de atingir um alto grau de automatização.

% something that is difficult - if not impossible - to achieve with general purpose languages. For isntance, UML was developed to be able to model all kinds of application domains, but it has not proven to be successfull in truly model-driven development \cite{DSM}

Apesar de metamodelos poderem ser empregados na descrição de DSMLs, sua capacidade limita-se a descrição da sintaxe abstrata e semântica estática. Todavia, a definição da sintaxe concreta é simples, e existem várias ferramentas que permitem descrever sua notação, seja ela textual ou gráfica, e o seu mapeamento para a sintaxe abstrata. 
A formalização da semântica dinâmica de uma DSML, no entanto, é bem mais complexa, e atualmente não há um método estabelecido como padrão \cite{Kurtev:2006:MDF:1176617.1176632}.

A semântica dinâmica de uma DSML é na maior parte das situações descrita informalmente, por meio de linguagem natural, e codificada na implementação do mecanismo responsável pelo processamento da DSML. A formalização da semântica dinâmica de linguagens de modelagem tem sido objeto de estudos, e tem o potencial de trazer vários benefícios, principalmente associados à geração automática de ferramentas.

There are four main approaches to describing the semantics of languages: translational ? translating from one language to another language with precise semantics; operational ? modeling the operational behavior of language concepts; extensional ? extending the semantics of existing language concepts; and denotational ? modeling the mapping to semantic domain concepts. There are advantages and disadvantages of each approach (Clark et al., 2008). 

Uma das abordagens proeminentes para definição de semântica de DSMLs por meio de tradução é denominada ancoragem semântica \cite{Chen:2005:TSA:1086228.1086236}. Nessa abordagem, a definição da semântica e se dá pelo mapeamento dos elementos da DSML em modelos computacionais, cuja semântica é bem definida, como máquinas de estado abstratas, sistemas de eventos discretos, autômatos, etc. Outra abordagem baseada em tradução emprega regras de reescrita \cite{1240339} que descrevem como os elementos de um modelo podem ser sucessivamente reescritos, até que representem elementos da linguagem alvo.

Outra técnica também empregada na formalização da semântica dinâmica de DSMLs consiste em incorporar comportamento ao metamodelo (\emph{behavior weaving}) \cite{weave}. Estas abordagens propõem uma forma de estender a linguagem de meta-metamodelagem para possibilitar a construção de metamodelos que incorporem a semântica operacional.

% Both approaches can be implemented by code in general-purpose languages
%There are standardized languages for defining both transformations and operational semantics, but they tend to be generic in a way that sometimes they do not provide greater advantage than the use of a general-purpose language.


\subsection{Modelos em tempo de execução}




O termo \emph{Model-Driven Engineering} (MDE) é geralmente empregado para identificar um conjunto de abordagens que promovem o uso de modelos como os principais artefatos no processo de engenharia de software \cite{}.


%O surgimento de abordagens dirigidas por modelos evoluiu da crescente complexidade 
%complexidade das aplicações
%enquanto isso as tecnologias existentes...

O surgimento de abordagens dirigidas por modelo evoluiu a partir da necessidade de lidar com a crescente complexidade encontrada no desenvolvimento de sistemas de software. O avanço nas tecnologias de rede e processamento observado nas últimas décadas possibilitou a construção de aplicações cada vez mais complexas. Apesar disso, as linguagens de programação de terceira geração não evoluíram com a mesma velocidade, sendo que suas  abstrações não se demonstram capazes de ocultar as complexidades envolvidas no desenvolvimento de software atual.
Abordagens dirigidas por modelos buscam reduzir a lacuna existente entre as tecnologias/plataforma de implementação e a 

%O avanço nas tecnologias de rede e processamento observado nas últimas décadas possibilitou a construção de aplicações cada vez mais complexas, que comumente envolvem elementos de computação distribuída em ambientes heterogêneos que estão em constante mudança. 
%Além disso, aplicações atuais apresentam cada vez mais requisitos de disponibilidade, segurança, adaptabilidade, entre outros capazes de aumentar significativamente a complexidade de um sistema baseado em software.
%As abstrações fornecidas por linguagens de programação orientadas a objetos não são capazes de ocultar as complexidades envolvidas no desenvolvimento das aplicações atuais.

Nesse contexto, o uso de modelos surge como um meio de representar de forma abstrata algum aspecto de um sistema, ocultando detalhes desnecessários para sua compreensão. 
Em abordagens dirigidas por modelos, o uso de modelos não se restringe a representação e compreensão de um sistema, mas também se aplica à sua descrição e construção.

Além de abstratos, os modelos empregados em abordagens de MDE são formais, o que possibilita que sejam processados de forma automatizada. Por meio de linguagens de modelagem mais apropriadas para descrição dos aspectos que compõem um sistema e ferramentas capazes de processá-los, de forma automatizada, em construções da plataforma de implementação, abordagens de MDE buscam ocultar a complexidade envolvida no desenvolvimento de aplicações.


%MDE evoluiu da complexidade do software...
%Abstrações não evoluíram (baseadas em computação)

In a traditional software engineering process, mapping between design and implementation is done by exploiting the expert knowledge of a programmer. In model driven engineering this expert knowledge is not lost in millions of lines of code but instead it is explicitly visible in trans- formation functions.




multiple goals

Descrição geral de MDE:
  - uso de modelos como principais artefatos para construção de software
  - modelos não só como documentação ou projeto, mas como elementos de primeira classe
  - processamento automatizado de modelos em elementos da plataforma de implementação
  
  transformação ou interpretação
  
  models@run.time
  
  DSL
  - encoding substantial domain-specific knowledge into the language and its processing tools
  
  

The term Model-Driven Engineering is commonly used to describe a set of software engineering approaches that employ models as their primary artifacts. In these approaches, the use of models is not restricted to the documentation or design of software, but may extend throughout the software engineering process.
%By employing models based on abstractions closer to the problem to be solved, model-driven approaches seek to abstract technical details of the underlying platform, therefore simplifying the engineering of software. To make it feasible, these approaches rely on automated tools for the processing of models into constructs of the implementation platform.

Models are usually described in domain-specific modeling languages, and processed by automated tools into constructs of the implementation platform \cite{Schmidt}. The use of domain-specific models switches the focus of software engineering from implementation technologies to problem-level abstractions.
Nonetheless, automation in the processing of high-level models into software implementation requires encoding substantial domain-specific knowledge into the language and processing tools

A modeling language is described using a  metamodel, which is itself a model that defines the abstractions available in the domain and how they interrelate. Metamodeling techniques have been standardized by the OMG Meta-Object Facility \cite{Omg_2006}, but there are several tools, such as the Eclipse Modeling Framework \cite{emf}, that provide metamodeling capabilities.

Domain-specific models may be transformed into artifacts of the implementation platform or directly executed by a model interpreter. The use of model interpreters has the potential of facilitating the processing of models at runtime in order to adapt a running application. This usage of models has been proposed as an alternative to deal with the growing complexity of contemporary software \cite{FranceEtAl}.

The use of models at runtime seeks to use better abstractions for manipulating and inspecting a running system. Models at runtime bear a certain resemblance with reflection in which both deal with self-representations of a system that are causally connected. However, models at runtime use representations that are closer to the problem domain, in contrast with reflection, whose representations tend to be based on the implementation platform \cite{Blair2009}.


Title: In Search of a Basic Principle for Model Driven Engineering

"One of the possible evolutionary paths is
called model engineering. This consists in giving ?rst-class
status to models and model elements, similarly to the ?rst class
status that was given to objects and classes in the 80s, at the
beginning of the object technology era. The essential change is
that models are no longer used only as mere documentation for
programmers, but can now be directly used to drive software
production tools."


The answer was to provide one language for
de?ning meta-models, i.e. a meta-meta-model (level M3
in
Figure 1). Each meta-model de?nes itself a language for
describing a speci?c domain of interest (level M2
 in Figure 1).
For example UML describes the artifacts of an object-oriented
software system. Some other meta-models may address
domains like legacy systems, data warehouses, software process, organization, tests, quality of service, party management,
etc. Each is important and their numbers keep growing. They
are de?ned as separate components and many relationships
exist between them.


Until now
object analysis and design models have mainly been used to
document software systems. Analysts and designers built models that were provided to programmers only as inspiration
material to facilitate the production of concrete software. The
move from this ‘contemplative’ period to a new situation where
production tools will be model driven has been facilitated by
the introduction of standards like the XMI (XML Metadata
Interchange) recommendation [7].


A basic principle in object technology (“Everything is an
object” [P1]) was most helpful in driving the technology in the
80s, in the direction of simplicity, generality and power of integration. Similarly in model engineering, the basic principle
“Everything is a model” [P2] has many interesting properties,
among them the capacity to generate a realistic research agenda. We suggest that this may be most useful in understanding
many questions about model engineering in general and the
MDA™ approach in particular.

A model represents this system at level M1
. This
model conforms to its meta-model de?ned at level M2
and the
meta-model itself  conforms to the meta-meta-model at level
M3
. The meta-meta-model conforms to itself. This is very
similar to the organization of programming languages, as
already suggested in the right-hand column of Figure 1. A selfrepresentation of the EBNF (Extended Backus-Naur Form)
notations takes some lines. This notation allows de?ning in?nity of well-formed grammars. A given grammar, for example
the grammar of the Pascal language, allows de?ning the in?nity
of syntactically correct Pascal programs. One Pascal program
is a symbolic representation of the in?nity of its possible executions. The Pascal program, the Pascal grammar, the EBNF
self-described notation are all examples of symbolic models.
The execution of the program, on the contrary, is a real phenomenon involving changes of values in electronic memories
and much more: it is part of the real world.




We suggest that the current software development paradigm, based on object orientation, may have reached
the point of exhaustion, and we propose a model for its successor


Title: On the Unification Power of Models

The software industry remains reliant on the craftsmanship of skilled individuals engaged in labor intensive manual tasks.
We suggest that the current software development para-digm, based on object orientation, may have reached the point of exhaustion, and we propose a model for its successor.

At the beginning of object technology, what was important was that an object could be an instance of a class and a class could inherit from another class. This may be seen as a minimal definition in support of principle [P1]. We call the two basic relations instanceOf and inheritsFrom. Very differently, what seem to be important now is that a particular view (or aspect) of a system can be captured by a model and that each model is written in the language of its metamodel. This may be seen as a minimal definition in support of principle [P2].

The danger would be to use the old [P1] relations within the new context of MDE, for example by stating that a model in an instanceOf a metamodel2. This point of view often leads to many confusion and does not help in clarifying a complex evolution.
More generally, there is an over-usage of this instanceOf relation in MDE. Used in different contexts, with different meanings, this may cause additional confusion. Careful distinction between at least three different usages of this relation is suggested in [3] and [8].
[3] Some Initial Considerations on the Layered Organization of Metamodels
[8] Ontology-based Layered Semantics for Precise OA\&D

The MDE approach has not a unique goal. Among the objectives pursued, one may list the separation from business-neutral descriptions and platform dependent imple-mentations, the identification, precise expression, separation and combination of specific aspects of a system under development with domain-specific languages, the establishment of precise relations between these different languages in a global framework and in particular the possibility to express operational transformations between them 

3 MDE: concepts and goals
As the notion of object was central to the software development practices of the 80's, the notion of model seems today to focus much attention. The question of defining what a model is, on a practical basis, will probably take as much time and energy to settle as the definition of the notion of an object. We propose in this paper to start from the two basic relations associated to principle [P2].





\section{Máquina Virtual de Comunicação}
\label{sec:referencial-cvm}

A Máquina Virtual de Comunicação (\emph{Communication Virtual Machine}, CVM) é uma plataforma voltada para a especificação e realização de serviços de comunicação \cite{cvm}. Sendo uma plataforma dirigida por modelos, a CVM funciona por meio do processamento de modelos descritos em uma linguagem de modelagem específica de domínio, denominada Linguagem de Modelagem de Comunicação (\emph{Communication Modeling Language}, CML) \cite{cml}. Diferente de muitas abordagens dirigidas por modelo que se apoiam na geração de código, os modelos CML são diretamente interpretados pela CVM.

A CVM é considerada uma plataforma centrada no usuário devido ao alto-nível dos modelos descritos por meio da CML, que podem ser facilmente construídos por usuários especialistas de domínio, ou até mesmo usuários finais. A CML é uma linguagem declarativa, por meio da qual são descritos os participantes, dados, e tipos de mídia envolvidos em uma comunicação a ser realizada. Informações associadas às tecnologias e dispositivos efetivamente utilizados na realização da comunicação, não são descritos em um modelo CML. A figura~\ref{fig:referencial-cml} ilustra um exemplo de modelo descrito por meio da representação gráfica da CML. O modelo em questão define uma comunicação entre dois participantes por meio de audio em tempo real.

\begin{figure}
 \centering
 \includegraphics[width=1\textwidth]{./fig/cml}
 \caption{Exemplo de modelo CML.}
 \label{fig:referencial-cml}
\end{figure}

A partir de um modelo CML, a CVM é capaz de realizar o serviço de comunicação descrito de forma automática, sem a necessidade de intervenção do usuário. Um modelo CML também pode ser modificado ao longo do curso de uma comunicação, sendo a CVM capaz de identificar essas mudanças e adaptar a comunicação em andamento para atender aos novos requisitos definidos. Devido à esta natureza, os modelos em CML podem ser considerados como modelos de desenvolvimento e de tempo de execução \cite{Wang}.

Para tornar isso possível, a CML e a CVM incorporam conhecimento relacionado à realização de serviços de comunicação, permitindo que modelos CML se limitem a descrever os aspectos específicos do serviço a ser realizado.
A CVM se baseia em uma arquitetura de camadas que encapsulam as tarefas necessárias à realização de um serviço de comunicação. Um modelo CML fornecido pelo usuário (ou aplicação) é sucessivamente processado e transformado pelas camadas da CVM, até que sejam geradas chamadas aos componentes que efetivamente realizam os serviços solicitados. A figura~\ref{fig:referencial-cvm} ilustra as camadas que integram a CVM, descritas logo adiante.

\begin{figure}
 \centering
 \includegraphics[width=0.75\textwidth]{./fig/cvm}
 \caption{Arquitetura em camadas da CVM.}
 \label{fig:referencial-cvm}
\end{figure}


\begin{itemize}

\item Interface de Comunicação com o Usuário (\emph{User Communication Interface}, UCI). A UCI representa uma interface para interação com a CVM, provendo meios para a definição e gerenciamento de modelos em CML. É por meio dessa interface que usuários ou aplicações podem solicitar a realização de uma comunicação descrita por um modelo, e serem notificados de eventos ocorridos durante o seu andamenteo. Além disso, a UCI também conta com um ambiente de modelagem que permite que usuários construam modelos CML por meio de manipulação direta da representação gráfica. 

\item Mecanismo de Síntese (\emph{Synthesis Engine}, SE). O mecanismo de síntese é responsável por duas principais tarefas: a negociação de um modelo em CML recebido da UCI com os demais participantes de uma comunicação; e a transformação deste modelo em um \emph{script} de controle da comunicação executável que contém a lógica para o estabelecimento da comunicação. O mecanismo de síntese implementa a semântica operacional da CML \cite{OperSemantic}, sendo o responsável por transformar os modelos declarativos descritos através da CML em \emph{scripts} executáveis pela camada seguinte.

\item \emph{Middleware} de Comunicação Centrado no Usuário (\emph{User-centric Communication Middleware}, UCM). A camada de \emph{middleware} da CVM, tem como função executar o \emph{script} de comunicação recebido do mecanismo de síntese e coordenar as sessões de comunicação. Além disso, cabe à esta camada garantir que sejam aplicadas as políticas de segurança, qualidade de serviço, entre outras relativas à comunicação.

\item Intermediador de Comunicação em Rede (\emph{Network Communication Broker}, NCB). A camada NCB provê uma interface de comunicação, independente de tecnologia, para uso da camada de \emph{middleware}. O intermediador tem como função blindar a camada superior da heterogeneidade e complexidade envolvidas na interação com os componentes que efetivamente realizam a comunicação. Assim, a NCB recebe requisições da camada UCM e intermedia o acesso aos \emph{frameworks} de comunicação para que realizem a solicitação recebida.

\end{itemize}

\subsection{Intermediador de Comunicação em Rede}

A camada NCB, que integra a CVM, foi projetada com o intuito de fornecer uma interface de serviços de comunicação independente da tecnologia de comunicação empregada, capaz de abstrair da camada superior a heterogeneidade e dinâmica envolvida na utilização de provedores de comunicação \cite{cvm}.  Para isso, o intermediador de comunicação deve ser capaz de se auto-gerenciar, adaptando-se para se adequar à mudanças no ambiente de rede, nos provedores de comunicação, ou nas solicitações advindas da camada de \emph{middleware}.

Apesar de prever o uso de diversos provedores de comunicação, a versão inicialmente desenvolvida da NCB comportava apenas um provedor diretamente incorporado à sua implementação, limitando a qualidade e tipos de serviços de comunicação disponíveis. Em trabalhos seguintes \cite{SelfConfig}, a NCB foi ampliada para possibilitar a integração, e auto-configuração de vários \emph{frameworks} provedores de comunicação como Skype, Smack, Asterisk, etc. Para o auto-gerenciamento da camada foi adotada a arquitetura de computação autônoma proposta pela IBM \cite{ibmac}.
A NCB também foi posteriormente \cite{UCCAF} estendida para contemplar o uso de políticas como meio de guiar decisões da seleção de \emph{frameworks} de comunicação.


\section{Reflexão computacional}

\section{Computação autônoma}

\section{Políticas}
