
\chapter{Ambiente de execução para o Intermediador de Serviços}
\label{cap:ambiente}


% Describe the execution engine based on EMF. This section corresponds to the implementation section that goes in most papers. Make it clear in the text that it is the implementation.

%% Describe why the execution environment is needed
%- The  metamodel allows for us to define a Broker layer...
%- but in order to execute it so that it is capable of handling requests from the middleware layer ...
%- we developed an execution engine (that therefore provides dynamic semantics to the  metamodel)

%Though the  metamodel provides abstractions that enable the description of a broker layer, it is not enough to have an executable layer, capable of handling requests at runtime. In order to fill in this gap, we developed an execution environment that loads a broker layer model and behaves accordingly, therefore providing operational semantics for the proposed  metamodel.

Apesar do metamodelo prover abstrações que possibilitam descrever um intermediador de serviços, isto não é suficiente para se obter uma camada executável, capaz de tratar as solicitações recebidas em tempo de execução. Com o intuito de preencher essa lacuna, desenvolvemos um ambiente de execução capaz de carregar um modelo que representa uma camada de intermediação e proceder de acordo com o descrito nesse modelo. Assim, o ambiente de execução desenvolvido implementa a semântica operacional do metamodelo proposto.


%% MAKE IT CLEAR that the execution engine loads the XMI models defined by using EMF
%- The execution environment loads a Broker layer model defined as an EMF XMI file.
%- Based on this model, the execution environment initializes a Broker layer for a DSML execution engine.
%- It uses the classes generated by EMF from the  metamodel to process the model.

%The provided execution environment was developed in the Java platform and comprises components for executing a broker layer model and a library for interfacing with the resources to be managed by the layer. It loads a model described in EMF XMI 2.0 and initializes a broker layer for a DSML execution engine.

O ambiente de execução, desenvolvido na plataforma Java, compreende componentes para a execução de modelos que representam intermediadores de serviços, e uma biblioteca de classes para integração da camada com os recursos a serem gerenciados. Através desses componentes é possível carregar um modelo representado no formato EMF XMI 2.0 e inicializar uma camada de intermediação de serviços de uma máquina virtual.

% Introduction to understand the following paragraphs
%in this section we deal with the actual implementation that actually process the requests driven by a given Broker model
%- The name of the classes are overloaded (always refer to the implementation exception when mentioned)
%- The architecture resembles the  metamodel

%In this section, we describe the implementation of this execution environment, including its main components and how they interact in order to provide the behavior described by the model loaded in it. Though the names employed for describing these components may be the same used for elements of the  metamodel they are not the same. The components described here are part of the actual Java implementation but are related to their homonymous in the  metamodel.

Neste capítulo descrevemos a implementação do ambiente de execução fornecido, incluindo seus principais componentes, e como estes interagem para prover o comportamento descrito pelo modelo carregado. Na primeira seção descrevemos uma visão geral do ambiente de execução, incluindo o fluxo geral de processamento de sinais e os componentes envolvidos. As seções seguintes descrevem em detalhes a implementação de componentes específicos do ambiente.

\section{Visão geral do ambiente de execução}


Antes de iniciar a execução de uma camada de intermediação de serviços, as estruturas responsáveis pela realização da camada em tempo de execução precisam ser inicializadas. A inicialização da camada é realizada a partir do processamento do modelo, descrito no formato EMF XMI. O ambiente de execução contém um conjunto de fábricas de objetos capazes de, a partir do modelo carregado, instanciar os objetos que compõem o ambiente de execução.

% Describe the overall flow of the execution environment
%Under the implemented execution environment, a broker layer constantly waits for calls from the upper layer or events from resources, that once arrived are enqueued for later processing. In order to process a signal, the appropriate handler is found and executed. In accordance with the model, the handler executes the associated action that may interact with resources and manipulate the state maintained by the layer. Specialized handlers are also set up for handling signals that may activate self-management functions.


No ambiente de execução em questão, um intermediador de serviços está constantemente à espera de chamadas oriundas da camada superior ou eventos gerados pelos recursos. Uma vez identificados, esses sinais são enfileirados, para em seguida serem processados. Para processar um sinal, o intermediador procura por um tratador de sinal apropriado, e encaminha o sinal à este tratador. De acordo com o definido no modelo em execução, o tratador executa a ação associada ao sinal, que pode interagir com os recursos disponíveis ou manipular o estado mantido pela camada.

A figura~\ref{fig:ambiente-fluxo} ilustra os principais componentes que integram uma camada intermediação de serviços em tempo de execução. Apesar de serem empregados para esses componentes os mesmos nomes presentes no metamodelo, eles não representam os mesmo elementos. Os elementos discutidos neste capítulo são parte da implementação responsável por realizar um modelo que descreve um intermediador de serviços.

Conforme ilustrado, um modelo de alto nível, descrito em uma DSML é processado pelas camadas superiores da máquina virtual, sendo sucessivamente transformado até chegar à camada de intermediação. Na camada de intermediação, o modelo é recebido como uma sequência de chamadas. Para simplificar a utilização do intermediador de serviços pela camada superior, o ambiente de execução provê uma fachada \cite{designpattern} que permite que a camada superior execute chamadas, e receba notificações de eventos.

O \emph{gerenciador de intermediação} é o principal elemento do ambiente, sendo o responsável por controlar o fluxo de execução. O \emph{gerenciador de intermediação} é o componente responsável por realizar, em tempo de execução, o elemento descrito no metamodelo por meio da classe \textsf{Manager}. Portanto, em tempo de execução o contexto de gerenciamento de recursos é definido por um \emph{gerenciador de intermediação}, que pode empregar outros \emph{gerenciadores de intermediação} como recursos.

\begin{figure*}
 \centering
 \includegraphics[width=0.95\textwidth]{./fig/environment}
 \caption{Ambiente de execução para realização de um intermediador de serviços.}
 \label{fig:ambiente-fluxo}
\end{figure*}

Um \emph{gerenciador de intermediação} serializa o tratamento dos sinais recebidos, que são enfileirados e em seguida processados um a um.  O processamento dos sinais é conduzido pelo \emph{gerenciador de tratadores de sinais} que identifica e executa o \emph{tratador de sinal} apropriado.
O \emph{gerenciador de tratadores de sinais} mantém um registro de \emph{tratadores de sinais} e procura pelo primeiro que é capaz de tratar o sinal em processamento. 
Os \emph{tratadores de sinais} registrados são inicializados de acordo com as definições de tratadores e ações definidos no modelo em execução.

Uma vez identificado o \emph{tratador de sinal} apropriado, a \emph{ação} correspondente é executada. Como ilustrado na figura~\ref{fig:ambiente-fluxo}, uma \emph{ação} pode interagir com os recursos por meio do \emph{gerenciador de recursos}, manipular o estado da camada por meio do \emph{gerenciador de estado}, ou gerar eventos para camada superior por meio do \emph{gerenciador de intermediação}.

Além desses, outros tratadores especializados também são registrados com objetivo identificar sinais que podem ser de interesse para as funções de auto gerenciamento da camada. Esses tratadores interceptam os sinais recebidos e os direcionam para o \emph{gerenciador autônomo} e o \emph{gerenciador de avaliação de políticas}, respectivamente.

O \emph{gerenciador de recursos} mantém referências para os recursos disponíveis para uso da camada, e disponibiliza uma interface para obtenção desses recursos. Além disso, esse gerenciador notifica o \emph{gerenciador de intermediação} sobre eventos gerados pelos recursos.
O \emph{gerenciador de estado} disponibiliza uma interface para manipulação de dados, e notifica o \emph{gerenciador autônomo} sobre alterações, que podem disparar o mecanismo de auto gerenciamento da camada.

O \emph{gerenciador autônomo} encapsula as funções MAPE do ciclo de gerenciamento autônomo, que são ativadas pelo \emph{tratador de sinal} correspondente, ou pelo \emph{gerenciador de estado}. A análise dos sinais identificados ou de mudanças no estado da camada pode levar o \emph{gerenciador autônomo} a executar uma \emph{ação}.

De forma similar, o \emph{gerenciador de avaliação de políticas} é ativado pelo \emph{tratador de sinais de políticas}, e inicia a reavaliação das políticas em relação aos recursos disponíveis. Após a avaliação dos recursos em relação às políticas, uma ação é executada para efetuar chamadas aos recursos ou mudanças nos dados mantidos pelo intermediador.

\section{Tratamento de sinais}

Em uma camada de intermediação de serviços, sinais podem representar chamadas recebidas por meio da interface com a camada superior, ou eventos gerados pelos recursos. Os sinais recebidos por um gerenciador da camada de intermediação são tratados por um gerenciador de tratadores de sinais. Este elemento mantém um registro de tratadores de sinais, e é responsável por identificar qual tratador responderá à um sinal recebido. Um tratador de sinais, por sua vez, é o responsável por realizar a ação esperada da camada quando da recepção de um sinal.

%\subsection{Tratadores de sinais}

O gerenciador de tratadores de sinais é implementado pela classe \textsf{SignalHandlerManager}, que mantém um registro de tratadores de sinais, que são implementações da interface \textsf{SignalHandler}. 
Cada sinal recebido pelo gerenciador, é repassado sequencialmente a cada tratador, até que um desses trate apropriadamente o sinal, e indique que este não deve continuar a ser repassado aos tratadores seguintes.
Isso permite que mais de um tratador receba um sinal, mas que uma vez tratado, sua propagação seja interrompida. A ordem de avaliação dos tratadores é estabelecida de acordo com a sua prioridade, definida no momento em que um tratador é registrado junto ao gerenciador de tratadores de sinais.

A figura~\ref{fig:ambiente-signal} ilustra a interface \textsf{SignalHandler} e os tipos associados. Ao processar um sinal, representado em tempo de execução pela classe \textsf{SignalInstance}, um tratador de sinais tem acesso ao contexto de gerenciamento, representado pelo tipo \textsf{ManagerContext}. Através dessa interface, tratadores podem ter acesso aos gerenciadores de intermediação, recursos, e estado.
O resultado do tratamento de um sinal é representado por meio de um objeto do tipo \textsf{HandlingResult}, que indica se o tratador foi capaz de tratar o sinal em questão, e eventualmente, o resultado desse tratamento.

A classe \textsf{ActionSignalHandler} é utilizada para definir um tratador de sinais que executa uma ação quando um sinal é identificado. Instâncias dessa classe são registradas durante a inicialização da camada a partir das definições de tratadores existentes no modelo da camada, conforme descrito na seção~\ref{sec:metamodelo-sinais}. Ao receber um sinal em tempo de execução, um tratador verifica se o sinal é do mesmo tipo do encontrado em sua definição, e executa a ação correspondente.

%\subsection{Acionamento de ações}

Associado à um \textsf{ActionSignalHandler}, temos um acionador de ação, implementado pela classe \textsf{ActionCaller}. O acionador é inicializado junto ao tratador, e tem como objetivo realizar o mapeamento do contexto do sinal recebido para o contexto da ação a ser executada. Uma ação, por sua vez é representada em tempo de execução por um objeto do tipo \textsf{ActionInstance}. A figura\~ref{fig:ambiente-action} mostra as classes e interfaces que estão relacionadas ao tratamento de sinais por meio da execução de uma ação. 

Como já observado, uma ação executa uma determinada operação na camada, que pode envolver a utilização de recursos ou manipulação do estado da camada.  Além disso, execução de uma ação exige um contexto, definido por um conjunto de parâmetros. Essas características podem ser notadas na interface do tipo \textsf{ActionInstance}, cujo método \texsf{execute} exige um contexto de gerenciamento, e um conjunto de parâmetros. Através do contexto de gerenciamento a ação pode ter acesso aos gerenciadores de intermediação, recursos e estado. Os parâmetros de uma ação são passados em tempo de execução como um dicionário de nomes e valores.

O acionador de ação, por sua vez, recebe um provedor de contexto, e o utiliza para obter os valores que serão passados como argumentos para uma ação. Um provedor de contexto é um objeto que provê um conjunto de variáveis que podem ser obtidas a partir de seu nome, como pode ser notado na interface \textsf{ContextProvider}.  A partir das ligações de parâmetros definidas no modelo em execução, o acionador de ação é capaz de mapear o contexto provido para os parâmetros esperados pela ação.

%\subsection{Associação de contexto}

Quando uma ação é utilizada para tratar um sinal, o contexto utilizado para a execução da ação é provido pelo próprio sinal. Um sinal é representado em tempo de execução por meio da classe \textsf{SignalInstance}, que implementa a interface \textsf{ContextProvider}. Um sinal provê como variáveis, além dos parâmetros passados junto ao sinal, o objeto que o gerou esse sinal, através da variável de nome \textsf{source}.

O mapeamento do contexto provido por um sinal para os parâmetros da ação depende do tipo de fonte de valor empregado, conforme descrito na seção~\ref{sec:metamodelo-sinais}. Uma fonte de valor define como um valor será obtido do contexto, para em seguida ser atribuído à um parâmetro da ação que será executada. 

%\subsection{Fontes de valores}


Uma fonte de valor fixo, definida em um modelo por meio do tipo \textsf{FixedValue}, retorna o valor fixo definido no modelo em execução, e portanto independe do sinal recebido. Uma fonte de valor de parâmetro (\textsf{ParameterValue}), por sua vez, obtém o seu valor através do contexto provido pelo sinal. Em tempo de execução, uma consulta é feita ao contexto do sinal, por uma variável que represente o parâmetro indicado no modelo.
De forma similar uma fonte de valor de origem do sinal (\textsf{SignalSource}) retorna o valor da variável \textsf{source} disponível no contexto de um sinal.

Enquanto os tipos de fontes de valores citados acima tem o seu comportamento implementado de forma relativamente simples e direta, a implementação de fontes de valor baseadas em expressões, e em chamadas à outras ações, é um pouco mais complexa.
Enquanto os tipos de fontes de valores discutidos logo acima envolvem no máximo uma variável do contexto provido, o uso de expressões permite que várias variáveis sejam empregadas para se obter um valor único, que será então passado como um argumento à uma ação.

Na implementação existente, as expressões podem ser descritas na linguagem Groovy \cite{groovyExpr}. Groovy é uma linguagem dinâmica para a plataforma Java que apresenta várias construções que facilitam seu emprego para a descrição de expressões. A linguagem permite o emprego de uma sintaxe simplificada para o acesso à propriedades, utilização de estruturas de dados, e definição de expressões \emph{lambda} \cite{proglang}. Além disso, essa linguagem pode ser considerada um superconjunto da linguagem Java, pois as construções Java também são construções válidas em Groovy.

Ao definir uma expressão, o construtor do modelo pode empregar todas as variáveis providas pelo contexto provido. Como observado anteriormente, quando um sinal é tratado o contexto consiste dos parâmetros do sinal e a origem do sinal, acessível por meio da variável \textsf{source}. Além do contexto provido, uma expressão também pode ter acesso ao estado da camada por meio de variáveis com o nome do tipo de dados. Estas variáveis implementam a interface de um dicionário, e permitem a obtenção de um registro de dados pelo seu identificador. O uso da linguagem Groovy também possibilita que consultas mais complexas sejam realizadas para obtenção de registros. O uso dessas expressões é ilustrado no capítulo~\ref{cap:instancia}, onde expressões são utilizadas na construção de um modelo de um intermediador de serviços.

O uso de uma fonte de valor baseada na execução de uma ação, tem como objetivo atribuir à um parâmetro de uma ação, o resultado da execução de outra ação. Essa definição é descrita no modelo por meio do tipo \textsf{ActionExecution}, que define além da ação a ser executada o mapeamento de contexto. 
No ambiente de execução implementado todas as fontes de valores são avaliadas antes da execução de uma ação e, assim sendo, as fontes do tipo \textsf{ActionExecution} são previamente processadas, e só então os valores, obtidos com execução das ações, são passados como argumentos para ação que trata o sinal em avaliação. 
% eager evaluation
A avaliação de uma fonte de valor desse tipo se dá da mesma forma que as demais ações, por meio de um acionador de ação.

%\subsection{Ações}



%Além disso, as classes {AutonomicManagerSignalHandler} e \textsf{PolicyManagerSignalHandler} também implementam a interface \textsf{SignalHandler}. Esses tipos especializados de tratadores direcionam os sinais recebidos, respectivamente, para um gerenciador autônomo e um gerenciador de políticas. Uma instância de cada um desses tratadores é registrada durante a inicialização da camada. Esses tratadores são registrados com prioridade máxima, e interceptam os sinais com o intuito de identificar se esses podem influenciar o auto gerenciamento da camada. Não obstante, esses tratadores não interrompem o processamento de um sinal, permitindo que esse ainda seja repassado a outros tratadores, até que um desses o trate apropriadamente.


\section{Recursos}

Os recursos utilizados por uma camada de intermediação de serviço são mantidos pelo gerenciador de recursos. O gerenciador de recursos mantém um registro dos recursos disponíveis, a partir do qual podem ser obtidos. 
Além disso, em tempo de execução, a utilização dos recursos é mediada por componentes capazes de interagir com os recursos, traduzindo suas construções naquelas utilizadas pela camada.

A classe \textsf{ResourceManager} representa o ponto inicial de acesso aos recursos gerenciados por uma camada de intermediação de serviços. Essa classe mantém um registro de recursos, criados a partir das definições presentes no modelo da camada. A partir dessa classe, é possível obter os recursos registrados, que são representados em tempo de execução pelo tipo \textsf{Resource}. 

A interface \textsf{Resource} possui duas implementações concretas: \textsf{ManagedResource} que media o acesso a recurso ordinário, e \textsf{BrokerManager} que representa um outro intermediador de serviços utilizado como um recurso. A figura~\ref{fig:ambiente-recursos-classes} ilustra um diagrama das principais classes relacionadas ao gerenciamento de recursos em tempo de execução.

A interface \textsf{Resource} é uma extensão das interfaces \textsf{Touchpoint} e \textsf{Executable}. Um \emph{touchpoint} representa uma interface de gerenciamento que disponibiliza uma forma padronizada para sua utilização, independente do tipo de recurso gerenciado \cite{KeepInTouchWithTouchPoints}. Nesta implementação, \textsf{Touchpoint} é herdeira das interfaces \textsf{Effector} e \textsf{Sensor}, e portanto um \emph{touchpoint} provê uma interface padrão para realizar chamadas e detectar eventos em um recurso. Além disso, um recurso também é executável, pois também implementa a interface \textsf{Executable}. Ser executável indica que um recurso, em tempo de execução, possui um fluxo próprio de controle, que nesse caso, é utilizado para serializar a interação entre a camada e o recurso. 

Não obstante, um recurso possui meios para comunicação de sinais prioritários.


%- inicializa os recursos; e mantém referências para ele em tempo de execução; e disponibiliza uma interface para obtenção dos recursos gerenciados.
%- como o resourcemanager pode ser utilizado
%- acesso aos recursos é serializado; segue a interação baseada em touchpoints


\subsection{Integração com os recursos}

Um conjunto de classes e interfaces é fornecido para a integração dos recursos com o ambiente de execução. Essa biblioteca tem como função viabilizar a interação entre o ambiente de execução e os recursos a serem gerenciados.
Além disso, essas classes e interfaces, que integram o pacote \textsf{mdvm.sb.adapters}, permitem associar a interface dos recursos, descrita no metamodelo, às suas implementações. A figura~\ref{fig:ambiente-integracao-diagrama} mostra um diagrama de classes do pacote mencionado.

A integração em questão se aplica aos recursos baseados na instanciação de uma implementação, representados no metamodelo pela classe \textsf{Instance}, descrita na seção~\ref{sec:metamodelo-recursos}. Por ser implementado na plataforma Java, o ambiente de execução exige que o recurso também seja implementado nesta plataforma. Apesar disso, é possível utilizar uma implementação que atue apenas como um \emph{wrapper} para a real implementação do recurso, em outra plataforma.

Para que um recurso seja integrado ao ambiente de execução é preciso que um protocolo seja seguido.
Antes de tudo, o recurso a ser integrado deve implementar a interface \textsf{Manageable}, que identifica que este recurso pode ser gerenciado por uma camada de intermediação de serviços.
Por meio desta interface,  o recurso tem acesso à um notificador de eventos, representado pelo tipo \textsf{EventNotifier}, que deve ser utilizado para sinalizar eventos ao intermediador de serviços. 

Os eventos a serem sinalizados são representados por meio da classe \textsf{Event}, também disponível no pacote citado. Além dessa classe, a classe \textsf{EventException} pode ser usada para sinalizar a ocorrência de uma exceção no recurso. Ao sinalizar um evento ou exceção, um recurso deve indicar o nome do evento e valores para os seus parâmetros.
% Descrever no fluxo como exceções são tratadas

Ainda, os métodos que implementam as chamadas providas pelo recurso, precisam ser marcadas com a anotação \textsf{@Call}. Esta anotação tem como função associar uma chamada provida, descrita no metamodelo, ao método que a implementa. Para isso, a anotação indica o nome da chamada provida associada ao método anotado e a ordem como os parâmetros desta chamada devem ser passados à este método. O código ~\ref{cod:ambiente-integracao-impl} demonstra trecho da implementação de um recurso a ser integrado ao ambiente de execução.

Uma vez seguido o protocolo descrito, um intermediador de serviços é capaz de interagir apropriadamente com o recurso, identificando corretamente os eventos gerados, e realizando chamadas aos métodos corretos. Esta interação possibilita que o recurso seja gerenciado por uma camada de intermediação de serviços descrita por meio do metamodelo proposto.


\section{Manutenção de estado}

A manutenção do estado da camada, em tempo de execução, é realizada por meio do gerenciador de estado. O gerenciador de estado mantém informações sobre os tipos de dados descritos no modelo e os registros de dados associados à esses tipos. A partir desse gerenciador, é possível pesquisar, criar, modificar e destruir registros de dados. Além disso, o gerenciador de estado monitora alterações efetuadas nesses registros e, se necessário, notifica o gerenciador autônomo.

O gerenciador de estado é implementado por um conjunto de classes que compõem o pacote \textsf{mdvm.sb.state}. A figura...

A principal classe desse pacote, denominada \textsf{StateManager}, mantém um conjunto de gerenciadores específicos para cada tipo de dados. Um gerenciador de tipo de dados é implementado pela classe \textsf{StateTypeManager}, e mantém os registros de dados associadas àquele tipo de dados. Por meio do gerenciador de tipo de dados é possível obter um registro de dados pelo seu identificador, ou realizar uma consulta baseada nos demais atributos. Além disso, o gerenciador de tipo de dados também pode ser usado para criar e destruir registros de dados. 

Os registros de dados são representados em tempo de execução por instâncias da classe \textsf{StateHolder}. Um \textsf{StateHolder} mantém os dados de um registro, e fornece métodos para acesso e manipulação de seus atributos. 
%Para facilitar a manipulação dos atributos, a interface do StateHolder permite/possibilita que os atributos possam ser tratados como um objeto ou uma coleção de objetos. 
Esta classe também é a responsável por interceptar a manipulação de um registro com o intuito de identificar mudanças e notificá-las aos componentes interessados.

O uso é ilustrado no capítulo~\ref{cap:instancia}.

\section{Gerenciamento autônomo}

A implementação do auto gerenciamento da camada se baseia na arquitetura de computação autonômica proposta pela IBM. O ambiente de execução inclui um conjunto de classes que implementam as funções de monitoramento, análise, planejamento e execução, que fazem parte dessa arquitetura. Além dessas funções, um outro conjunto de classes é utilizado para representar o conhecimento trocado entre essas funções em tempo de execução, incluindo ocorrências de sintomas, requisições de mudança, e planos de mudança. A figura~\ref{fig:ambiente-autonomo} ilustra as classes que compõem a implementação do mecanismo autônomo.




\section{Políticas}

