
\chapter{Ambiente de execução para o Intermediador de Serviços}
\label{cap:ambiente}


% Describe the execution engine based on EMF. This section corresponds to the implementation section that goes in most papers. Make it clear in the text that it is the implementation.

%% Describe why the execution environment is needed
%- The  metamodel allows for us to define a Broker layer...
%- but in order to execute it so that it is capable of handling requests from the middleware layer ...
%- we developed an execution engine (that therefore provides dynamic semantics to the  metamodel)

%Though the  metamodel provides abstractions that enable the description of a broker layer, it is not enough to have an executable layer, capable of handling requests at runtime. In order to fill in this gap, we developed an execution environment that loads a broker layer model and behaves accordingly, therefore providing operational semantics for the proposed  metamodel.

Apesar do metamodelo prover abstrações que possibilitam descrever um intermediador de serviços, isto não é suficiente para se obter uma camada executável, capaz de tratar as solicitações recebidas em tempo de execução. Com o intuito de preencher essa lacuna, desenvolvemos um ambiente de execução capaz de carregar um modelo que representa uma camada de intermediação e proceder de acordo com o descrito nesse modelo. Assim, o ambiente de execução desenvolvido implementa a semântica operacional do metamodelo proposto.


%% MAKE IT CLEAR that the execution engine loads the XMI models defined by using EMF
%- The execution environment loads a Broker layer model defined as an EMF XMI file.
%- Based on this model, the execution environment initializes a Broker layer for a DSML execution engine.
%- It uses the classes generated by EMF from the  metamodel to process the model.

%The provided execution environment was developed in the Java platform and comprises components for executing a broker layer model and a library for interfacing with the resources to be managed by the layer. It loads a model described in EMF XMI 2.0 and initializes a broker layer for a DSML execution engine.

O ambiente de execução, desenvolvido na plataforma Java, inclui componentes para a execução de modelos que representam intermediadores de serviços, e uma biblioteca de classes para integração da camada com os recursos a serem gerenciados. Através desses componentes é possível carregar um modelo representado no formato EMF XMI 2.0 e inicializar uma camada de intermediação de serviços de uma máquina virtual.

% Introduction to understand the following paragraphs
%in this section we deal with the actual implementation that actually process the requests driven by a given Broker model
%- The name of the classes are overloaded (always refer to the implementation exception when mentioned)
%- The architecture resembles the  metamodel

%In this section, we describe the implementation of this execution environment, including its main components and how they interact in order to provide the behavior described by the model loaded in it. Though the names employed for describing these components may be the same used for elements of the  metamodel they are not the same. The components described here are part of the actual Java implementation but are related to their homonymous in the  metamodel.

Neste capítulo descrevemos a implementação do ambiente de execução fornecido, incluindo seus principais componentes, e como estes interagem para prover o comportamento descrito pelo modelo carregado. Na primeira seção descrevemos uma visão geral do ambiente de execução, incluindo o fluxo geral de processamento de sinais e os componentes envolvidos. As seções seguintes descrevem em detalhes a implementação de componentes específicos do ambiente.

\section{Visão geral}


Antes de iniciar a execução de uma camada de intermediação de serviços, as estruturas responsáveis pela realização da camada em tempo de execução precisam ser inicializadas. A inicialização da camada é realizada a partir do processamento do modelo, descrito no formato EMF XMI. O ambiente de execução contém um conjunto de fábricas de objetos capazes de instanciar, a partir do modelo carregado, os objetos que compõem o ambiente de execução.

% Describe the overall flow of the execution environment
%Under the implemented execution environment, a broker layer constantly waits for calls from the upper layer or events from resources, that once arrived are enqueued for later processing. In order to process a signal, the appropriate handler is found and executed. In accordance with the model, the handler executes the associated action that may interact with resources and manipulate the state maintained by the layer. Specialized handlers are also set up for handling signals that may activate self-management functions.


No ambiente de execução desenvolvido, um intermediador de serviços está constantemente à espera de chamadas oriundas da camada superior ou eventos gerados pelos recursos. 
Uma vez identificados, esses sinais são enfileirados, para em seguida serem processados. Para processar um sinal, o intermediador procura por um tratador de sinais apropriado, e encaminha o sinal à este tratador. De acordo com o definido no modelo em execução, o tratador executa a ação associada ao sinal, que pode interagir com os recursos disponíveis ou manipular o estado mantido pela camada.

A figura~\ref{fig:ambiente-fluxo} ilustra os principais componentes que integram uma camada intermediação de serviços em tempo de execução.
%Apesar de apresentarem os mesmos nomes presentes no metamodelo, esses componentes não representam os mesmos elementos.
Os elementos discutidos neste capítulo são parte da implementação responsável por realizar um modelo que descreve um intermediador de serviços.
Conforme ilustrado, um modelo de alto nível, descrito em uma DSML é processado pelas camadas superiores da máquina virtual, sendo sucessivamente transformado até chegar à camada de intermediação. Na camada de intermediação, o modelo é recebido como uma sequência de chamadas. Para simplificar a utilização do intermediador de serviços pela camada superior, o ambiente de execução provê uma fachada que permite que a camada superior execute chamadas, e receba notificações de eventos.
% fachada \cite{designpattern} 

O \emph{gerenciador de intermediação} é o principal elemento do ambiente, sendo o responsável por controlar o fluxo de execução. O \emph{gerenciador de intermediação} é o componente responsável por realizar, em tempo de execução, o elemento descrito no metamodelo por meio da classe \textsf{Manager}. Portanto, em tempo de execução o contexto de gerenciamento de recursos é definido por um \emph{gerenciador de intermediação}, que pode empregar outros \emph{gerenciadores de intermediação} como recursos.

\begin{figure}
 \centering
 \includegraphics[width=1\textwidth]{./fig/environment}
 \caption{Ambiente de execução para realização de um intermediador de serviços.}
 \label{fig:ambiente-fluxo}
\end{figure}

Um \emph{gerenciador de intermediação} serializa o tratamento dos sinais recebidos, que são enfileirados e em seguida processados um a um.  O processamento dos sinais é conduzido pelo \emph{gerenciador de tratadores de sinais} que identifica e executa o \emph{tratador de sinais} apropriado.
O \emph{gerenciador de tratadores de sinais} mantém um registro de \emph{tratadores de sinais} e procura pelo primeiro que é capaz de tratar o sinal em processamento. 
Os \emph{tratadores de sinais} registrados são inicializados de acordo com as definições de tratadores e ações definidos no modelo em execução.

Uma vez identificado o \emph{tratador de sinais} apropriado, a \emph{ação} correspondente é executada. Como ilustrado na figura~\ref{fig:ambiente-fluxo}, uma \emph{ação} pode interagir com os recursos por meio do \emph{gerenciador de recursos}, manipular o estado da camada por meio do \emph{gerenciador de estado}, ou gerar eventos para camada superior por meio do \emph{gerenciador de intermediação}.

Além desses, outros tratadores especializados também são registrados com o objetivo identificar sinais que podem ser de interesse para as funções de auto gerenciamento da camada. Esses tratadores interceptam os sinais recebidos e os direcionam para o \emph{gerenciador autônomo} e o \emph{gerenciador de avaliação de políticas}, respectivamente.

O \emph{gerenciador de recursos} mantém referências para os recursos disponíveis para uso da camada, e disponibiliza uma interface para obtenção desses recursos. Além disso, esse gerenciador notifica o \emph{gerenciador de intermediação} sobre eventos gerados pelos recursos.
O \emph{gerenciador de estado} disponibiliza uma interface para manipulação de dados, e notifica o \emph{gerenciador autônomo} sobre alterações, que podem disparar o mecanismo de auto gerenciamento da camada.

O \emph{gerenciador autônomo} encapsula as funções MAPE do ciclo de gerenciamento autônomo, que são ativadas pelo \emph{tratador de sinais} correspondente, ou pelo \emph{gerenciador de estado}. A análise dos sinais identificados ou de mudanças no estado da camada pode levar o \emph{gerenciador autônomo} a executar uma \emph{ação}.

De forma similar, o \emph{gerenciador de avaliação de políticas} é ativado pelo \emph{tratador de sinais de políticas}, e inicia a reavaliação das políticas em relação aos recursos disponíveis. Após a avaliação dos recursos em relação às políticas, uma ação é executada para efetuar chamadas aos recursos ou mudanças nos dados mantidos pelo intermediador.

\section{Tratamento de sinais}
\label{sec:ambiente-sinais}

Em uma camada de intermediação de serviços, sinais podem representar chamadas recebidas por meio da interface com a camada superior, ou eventos gerados pelos recursos. Os sinais recebidos por um gerenciador da camada de intermediação são tratados por um gerenciador de tratadores de sinais. Este elemento mantém um registro de tratadores de sinais, e é responsável por identificar qual tratador responderá à um sinal recebido. Um tratador de sinais, por sua vez, é o responsável por realizar a ação esperada da camada quando da recepção de um sinal.

%\subsection{Tratadores de sinais}

O gerenciador de tratadores de sinais é implementado pela classe \textsf{SignalHandlerManager}, que mantém um registro de tratadores de sinais. Um tratador de sinais é representado em tempo de execução pelo tipo \textsf{SignalHandler}.
A figura~\ref{fig:ambiente-sinal} ilustra os tipos associados ao tratamento de sinais. 

\begin{figure}
 \centering
% \includegraphics[width=0.8\textwidth]{./fig/policy}
 \includegraphics[width=0.65\textwidth]{./fig/ambiente-sinais}
 \caption{Elementos associados ao tratamento de sinais em tempo de execução.}
 \label{fig:ambiente-sinal}
\end{figure}



Cada sinal recebido pelo gerenciador de tratadores, é repassado sequencialmente a cada tratador registrado, até que um desses o trate apropriadamente, indicando que o sinal não deve continuar a ser repassado aos tratadores seguintes.
Isso permite que mais de um tratador receba um sinal, mas que uma vez tratado, sua propagação seja interrompida. A ordem de avaliação dos tratadores é estabelecida de acordo com a sua prioridade, definida no momento em que um tratador é registrado junto ao gerenciador de tratadores de sinais.

Ao processar um sinal, representado em tempo de execução pela classe \textsf{SignalInstance}, um tratador de sinais tem acesso ao contexto de gerenciamento, representado pelo tipo \textsf{ManagerContext}. Através dessa interface, tratadores podem ter acesso aos gerenciadores de intermediação, recursos, e estado.
O resultado do tratamento de um sinal é representado por meio de um objeto do tipo \textsf{HandlingResult}, que indica se o tratador foi capaz de tratar o sinal em questão e, em caso afirmativo, o resultado desse tratamento.

Como ilustra a figura~\ref{fig:ambiente-acao}, a classe \textsf{ActionSignalHandler} é uma implementação da interface \textsf{SignalHandler}, utilizada para definir um tratador de sinais que executa uma ação quando um sinal é identificado.
Instâncias dessa classe são registradas durante a inicialização da camada, a partir das definições de tratadores existentes no modelo da camada, conforme descrito na seção~\ref{sec:metamodelo-sinais}. Ao receber um sinal em tempo de execução, um tratador desse tipo, verifica se o sinal é do mesmo tipo do encontrado em sua definição, e executa a ação correspondente.

\begin{figure}
 \centering
% \includegraphics[width=0.8\textwidth]{./fig/policy}
 \includegraphics[width=0.95\textwidth]{./fig/ambiente-acoes}
 \caption{Elementos associados à execução de ações em tempo de execução.}
 \label{fig:ambiente-acao}
\end{figure}


%\subsection{Acionamento de ações}

Associado à um \textsf{ActionSignalHandler}, temos um acionador de ação, implementado pela classe \textsf{ActionCaller}. O acionador é inicializado junto ao tratador, e tem como objetivo realizar o mapeamento do contexto do sinal recebido para o contexto da ação a ser executada. Uma ação, por sua vez, é representada em tempo de execução por um objeto do tipo \textsf{ActionInstance}. A figura~\ref{fig:ambiente-acao} também mostra as classes e interfaces que estão relacionadas ao tratamento de sinais por meio da execução de uma ação. 

Como já observado, uma ação executa uma determinada operação na camada, que pode envolver a utilização de recursos ou manipulação do estado da camada.  Além disso, a execução de uma ação exige um contexto, definido por um conjunto de parâmetros. 
Essas características podem ser notadas na interface \textsf{ActionInstance}, cujo método \textsf{execute} exige um contexto de gerenciamento, e um conjunto de parâmetros. Através do contexto de gerenciamento a ação pode ter acesso aos gerenciadores de intermediação, recursos e estado. Os parâmetros de uma ação são representados em tempo de execução como um dicionário de nomes e valores.

O acionador de ação, por sua vez, recebe um provedor de contexto, e o utiliza para obter os valores que serão passados como argumentos para uma ação. Um provedor de contexto é um objeto que provê um conjunto de variáveis que podem ser obtidas a partir de seu nome, como pode ser notado na interface \textsf{ContextProvider}.  A partir das ligações de parâmetros definidas no modelo da camada, o acionador de ação é capaz de mapear o contexto provido para os parâmetros esperados pela ação.

%\subsection{Associação de contexto}

Quando uma ação é utilizada para tratar um sinal, o contexto utilizado para a execução da ação é provido pelo próprio sinal. Um sinal é representado em tempo de execução por meio da classe \textsf{SignalInstance}, que implementa a interface \textsf{ContextProvider}. Um sinal provê como variáveis, além dos parâmetros passados junto ao sinal, o objeto que o gerou esse sinal, através da variável de nome \textsf{source}.

O mapeamento do contexto provido por um sinal para os parâmetros da ação depende do tipo de fonte de valor empregado, conforme descrito na seção~\ref{sec:metamodelo-sinais}. Uma fonte de valor define como um valor será obtido do contexto, para em seguida ser atribuído à um parâmetro da ação que será executada. 

%\subsection{Fontes de valores}


Uma fonte de valor fixo, definida em um modelo por meio do tipo \textsf{FixedValue}, retorna o valor fixo definido no modelo em execução, e portanto independe do sinal recebido. Uma fonte de valor de parâmetro (\textsf{ParameterValue}), por sua vez, obtém o seu valor através do contexto provido pelo sinal. Em tempo de execução, uma consulta é feita ao contexto do sinal, por uma variável que represente o parâmetro indicado no modelo.
De forma similar uma fonte de valor de origem do sinal (\textsf{SignalSource}) retorna o valor da variável \textsf{source} disponível no contexto de um sinal.

Enquanto os tipos de fontes de valores citados acima tem o seu comportamento implementado de forma relativamente simples e direta, a implementação de fontes de valor baseadas em expressões, e em chamadas à outras ações, é um pouco mais complexa.
Os tipos de fontes de valores discutidos logo acima envolvem no máximo uma variável do contexto provido, enquanto o uso de expressões permite que várias variáveis do contexto provido sejam empregadas para se obter um valor único, que será então passado como um argumento à uma ação.

Na implementação existente, as expressões podem ser descritas na linguagem Groovy \cite{groovyExpr}. Groovy é uma linguagem dinâmica para a plataforma Java que apresenta várias construções que facilitam seu emprego para a descrição de expressões. A linguagem permite o emprego de uma sintaxe simplificada para o acesso à propriedades, utilização de estruturas de dados, e definição de expressões \emph{lambda}. Além disso, essa linguagem pode ser considerada um superconjunto da linguagem Java, pois as construções Java também são construções válidas em Groovy.
%  lambda \cite{proglang}

Ao definir uma expressão, o construtor do modelo pode empregar todas as variáveis providas pelo contexto provido. Como já observado, quando um sinal é tratado, o contexto consiste dos parâmetros do sinal e a origem do sinal.
Além do contexto provido, uma expressão também pode ter acesso ao estado da camada por meio de variáveis com o nome do tipo de dados. Estas variáveis dão acesso à objetos que implementam a interface de um dicionário, e permitem a obtenção de um registro de dados de um determinado tipo a partir de seu identificador único. O uso da linguagem Groovy também possibilita que consultas mais complexas sejam realizadas para obtenção de registros. 
O uso dessas expressões é ilustrado no capítulo~\ref{cap:instancia}, onde são utilizadas na construção de um modelo de um intermediador de serviços.

O uso de uma fonte de valor baseada na execução de uma ação, tem como objetivo atribuir à um parâmetro de uma ação, o resultado da execução de outra ação. Isso é descrito no modelo por meio do tipo \textsf{ActionExecution}, que define além da ação a ser executada o mapeamento de contexto.
No ambiente de execução implementado todas as fontes de valores são avaliadas antes da execução de uma ação e, assim sendo, as fontes do tipo \textsf{ActionExecution} são previamente processadas, e só então os valores, obtidos com execução das ações, são passados como argumentos para ação principal que tratará o sinal em avaliação. 
% eager evaluation
A avaliação de uma fonte de valor desse tipo é realizada da mesma forma que a execução de uma ação, por meio de um acionador de ação.

%\subsection{Ações}

Em tempo de execução, uma ação é representada por um objeto do tipo \textsf{ActionInstance}, uma interface que possui como implementações as classes \textsf{CallActionInstance}, \textsf{EventActionInstance}, e \textsf{SequenceActionInstance}. Além disso, uma subinterface, chamada \textsf{MacroActionInstance} representa uma ação implementada por uma macro. A figura~\ref{fig:ambiente-acao} mostra a hierarquia do tipo \textsf{ActionInstance}.

Esses são os objetos que efetivamente são executados pelo acionador de ação após o mapeamento de parâmetros. A lógica implementada pela classe \textsf{CallActionInstance} é direta, e consiste em enviar uma chamada à um recurso ou ao gerenciador de intermediação, conforme definido no modelo. A classe \textsf{EventActionInstance} atua de forma similar, e tem como intuito permitir que a camada gere um evento para camadas superiores. Em ambos os casos, os parâmetros recebidos pela ação são diretamente utilizados como parâmetros para a chamada ou evento.

A classe \textsf{SequenceActionInstance}, por sua vez, encapsula uma série de acionadores de chamadas, que são utilizados para executar, em ordem, cada uma das ações que o compõem, conforme definido no modelo. Ao fim da execução, o resultado da última ação executada é utilizado como resultado da ação como um todo.

De forma geral, um tratador de sinais baseado em uma ação (\textsf{ActionSignalHandler}) recebe um sinal, e verifica se é capaz de tratá-lo. Caso afirmativo, o tratador utiliza um acionador de ação (\textsf{ActionCaller}) associado para mapear o contexto do sinal identificado para o da ação (\textsf{ActionInstance}), e em seguida executá-la.


%Além disso, as classes {AutonomicManagerSignalHandler} e \textsf{PolicyManagerSignalHandler} também implementam a interface \textsf{SignalHandler}. Esses tipos especializados de tratadores direcionam os sinais recebidos, respectivamente, para um gerenciador autônomo e um gerenciador de políticas. Uma instância de cada um desses tratadores é registrada durante a inicialização da camada. Esses tratadores são registrados com prioridade máxima, e interceptam os sinais com o intuito de identificar se esses podem influenciar o auto gerenciamento da camada. Não obstante, esses tratadores não interrompem o processamento de um sinal, permitindo que esse ainda seja repassado a outros tratadores, até que um desses o trate apropriadamente.


\section{Recursos}

Os recursos disponíveis para o uso de uma camada de intermediação de serviço são mantidos em tempo de execução pelo gerenciador de recursos. O gerenciador de recursos mantém um registro dos recursos disponíveis, e provê meios para sua obtenção e manipulação.
Além disso, a utilização de recursos em tempo de execução, é mediada por componentes capazes de interagir com os recursos, traduzindo suas construções naquelas utilizadas pela camada.

A classe \textsf{ResourceManager} representa o ponto inicial de acesso aos recursos gerenciados por uma camada de intermediação de serviços. Essa classe mantém um registro de recursos, criados a partir das definições presentes no modelo da camada. A partir dessa classe, é possível obter os recursos registrados, que são representados em tempo de execução pelo tipo \textsf{Resource}. 

A interface \textsf{Resource} possui duas implementações concretas: \textsf{ManagedResource}, que media o acesso a um recurso ordinário; e \textsf{BrokerManager}, que representa um outro intermediador de serviços sendo utilizado como um recurso. A figura~\ref{fig:ambiente-recursos-classes} ilustra um diagrama das principais classes relacionadas ao gerenciamento de recursos em tempo de execução.

\begin{figure}
 \centering
 \includegraphics[width=0.95\textwidth]{./fig/ambiente-recursos}
 \caption{Elementos associados ao gerenciamento de recursos em tempo de execução.}
 \label{fig:ambiente-recursos-classes}
\end{figure}


A interface \textsf{Resource} é uma extensão das interfaces \textsf{Touchpoint} e \textsf{Executable}. Um \emph{touchpoint} representa uma interface de gerenciamento que disponibiliza uma forma padronizada para sua utilização, independente do tipo de recurso gerenciado. Nesta implementação, \textsf{Touchpoint} é herdeira das interfaces \textsf{Effector} e \textsf{Sensor}, e portanto um \emph{touchpoint} provê uma interface padrão para realizar chamadas e detectar eventos em um recurso. Além disso, um recurso também é executável, pois também implementa a interface \textsf{Executable}. Ser executável indica que um recurso, em tempo de execução, possui um fluxo próprio de controle, que nesse caso, é utilizado para serializar a interação entre a camada e o recurso. 
%  ... do tipo de recurso gerenciado \cite{KeepInTouchWithTouchPoints}

%Não obstante, um recurso possui meios para comunicação de sinais prioritários.


%- inicializa os recursos; e mantém referências para ele em tempo de execução; e disponibiliza uma interface para obtenção dos recursos gerenciados.
%- como o resourcemanager pode ser utilizado
%- acesso aos recursos é serializado; segue a interação baseada em touchpoints


\subsection{Integração com os recursos}
\label{sec:ambiente-integracaorecursos}

Um conjunto de classes e interfaces é fornecido para a integração dos recursos com o ambiente de execução. Essa biblioteca tem como função viabilizar a interação entre o ambiente de execução e os recursos a serem gerenciados.
Esses elementos, que integram o pacote \textsf{mdvm.sb.adapters}, permitem associar a interface dos recursos, descrita no metamodelo, às suas implementações. A figura~\ref{fig:ambiente-integracao-diagrama} mostra um diagrama de classes do pacote mencionado.

\begin{figure}
 \centering
 \includegraphics[width=0.7\textwidth]{./fig/ambiente-adapters}
 \caption{Elementos para integração de recursos ao intermediador de serviços.}
 \label{fig:ambiente-integracao-diagrama}
\end{figure}


A integração em questão se aplica aos recursos baseados na instanciação de uma implementação, representados no metamodelo pela classe \textsf{Instance}, descrita na seção~\ref{sec:metamodelo-recursos}. Por ser implementado na plataforma Java, o ambiente de execução exige que o recurso também seja implementado nesta plataforma. Apesar disso, é possível utilizar uma implementação que atue apenas como um \emph{wrapper} para a real implementação do recurso, em outra plataforma.

Para que um recurso seja integrado ao ambiente de execução é preciso que um protocolo seja seguido.
Antes de tudo, o recurso a ser integrado deve implementar a interface \textsf{Manageable}, que identifica que este recurso pode ser gerenciado por uma camada de intermediação de serviços.
Por meio desta interface,  o recurso tem acesso à um notificador de eventos, representado pelo tipo \textsf{EventNotifier}, que deve ser utilizado para sinalizar eventos ao intermediador de serviços. 

Os eventos a serem sinalizados são representados por meio da classe \textsf{Event}, também disponível no pacote citado. Além dessa classe, a classe \textsf{EventException} pode ser usada para sinalizar a ocorrência de uma exceção no recurso. Ao sinalizar um evento ou exceção, um recurso deve indicar o nome do evento e valores para os seus parâmetros.
% Descrever no fluxo como exceções são tratadas

Ainda, os métodos que implementam as chamadas providas pelo recurso, precisam ser marcadas com a anotação \textsf{@Call}. Esta anotação tem como função associar uma chamada provida, descrita no metamodelo, ao método que a implementa. Para isso, a anotação indica o nome da chamada provida associada ao método anotado e a ordem como os parâmetros desta chamada devem ser passados à este método. O código ~\ref{cod:ambiente-integracao-impl} demonstra trecho da implementação de um recurso a ser integrado ao ambiente de execução.

\begin{center}
 \begin{minipage}{1\textwidth}
  \begin{codigo}[H]
   \small
   \VerbatimInput[xleftmargin=5mm,numbers=left,obeytabs=true]{./prog/SmackAdapter.java}
   \caption{\texttt{mdvm.sb.adapters.impl.SmackAdapter} }
   \label{cod:ambiente-integracao-impl}
  \end{codigo}
 \end{minipage}
\end{center}


Uma vez seguido o protocolo descrito, um intermediador de serviços é capaz de interagir apropriadamente com o recurso, identificando corretamente os eventos gerados, e realizando chamadas aos métodos corretos. Esta interação possibilita que o recurso seja gerenciado por uma camada de intermediação de serviços descrita por meio do metamodelo proposto.


\section{Manutenção de estado}

A manutenção do estado da camada, em tempo de execução, é realizada por meio do gerenciador de estado. O gerenciador de estado mantém informações sobre os tipos de dados descritos no modelo e os registros de dados associados à esses tipos. A partir desse gerenciador, é possível pesquisar, criar, modificar e destruir registros de dados. Além disso, o gerenciador de estado monitora alterações efetuadas nesses registros e, se necessário, notifica o gerenciador autônomo. As classes que integram o gerenciamento de estado em tempo de execução são ilustradas na figura~\ref{fig:ambiente-estado}.

\begin{figure}
 \centering
 \includegraphics[width=0.6\textwidth]{./fig/ambiente-estado}
 \caption{Classes que implementam o gerenciamento de recursos.}
 \label{fig:ambiente-estado}
\end{figure}

A principal classe desse pacote, denominada \textsf{StateManager}, mantém um conjunto de gerenciadores específicos para cada tipo de dados descrito no modelo em execução. Um gerenciador de tipo de dados é implementado pela classe \textsf{StateTypeManager}, e mantém os registros de dados de um determinado tipo de dados. Por meio do gerenciador de tipo de dados é possível obter um registro de dados pelo seu identificador, ou realizar uma consulta baseada nos seus demais atributos. Além disso, o gerenciador de tipo de dados também pode ser usado para criar e destruir registros de dados. 

Os registros de dados são representados em tempo de execução por instâncias da classe \textsf{StateHolder}. Um \textsf{StateHolder} mantém os dados de um registro, e fornece métodos para acesso e manipulação de seus atributos. 
%Para facilitar a manipulação dos atributos, a interface do StateHolder permite/possibilita que os atributos possam ser tratados como um objeto ou uma coleção de objetos. 
Esta classe também é a responsável por interceptar a manipulação de um registro com o intuito de identificar mudanças e notificá-las aos componentes interessados.

\section{Gerenciamento autônomo}

A implementação do auto gerenciamento da camada se baseia na arquitetura de computação autonôma proposta pela IBM \cite{ibmac}. O ambiente de execução inclui um conjunto de classes que implementam as funções de monitoramento, análise, planejamento e execução, que fazem parte dessa arquitetura. Além dessas funções, um outro conjunto de classes é utilizado para representar o conhecimento trocado entre essas funções em tempo de execução, incluindo ocorrências de sintomas, requisições de mudança, e planos de mudança. A figura~\ref{fig:ambiente-autonomo} ilustra as classes que compõem a implementação do mecanismo autônomo.

\begin{figure}
 \centering
 \includegraphics[width=1\textwidth]{./fig/ambiente-autonomo}
 \caption{Classes que implementam o mecanismo autônomo da camada.}
 \label{fig:ambiente-autonomo}
\end{figure}

Em tempo de execução, o mecanismo autônomo é ativado pelo gerenciador autônomo, implementado pela classe \textsf{AutonomicManager}. O gerenciador autônomo, implementa a interface \textsf{SignalHandler} de forma a interceptar os sinais recebidos pela camada. Apesar disso, o gerenciador autônomo não impede que o sinal continue sendo tratado pelos demais tratadores regularmente. Um sinal intereceptado pelo gerenciador autônomo é encaminhado ao seu monitor, que avalia se algum sintoma pode ser identificado, e encaminha uma ocorrência para o analisador. O analisador por sua vez, identifica qual a mudança a associada ao sintoma e envia uma solicitação de mudança para o planejador. Ao receber uma solicitação de mudança, o planejador determina qual o plano para efetuar a mudança solicitada, e o encaminha ao executor. Este último, por fim, executa a ação definida pelo plano e a executa.


\subsection{Monitor}

Ao receber um sinal, o monitor verifica se algum sintoma, definido no modelo do intermediador, depende deste evento, e reavalia as condições desse sintoma. Caso as condições que determinam o sintoma sejam verdadeiras, uma ocorrência de sintoma, representada pela classe \textsf{SymptomOcurrence}, é encaminhada para o analisador. Uma ocorrência de sintoma carrega consigo informações sobre os sinais e registros de dados que culminaram na detecção do sintoma.

As condições de um sintoma são definidas por meio de expressões. Assim como nas fontes de valor, as expressões para a definição de uma condição também são descritas em Groovy. A linguagem Groovy possui uma semântica bem definida para coerção de objetos em um tipo booleano, que é empregada na avaliação de uma condição.

O contexto para avaliação das condições é definido no modelo por meio da construção \textsf{Binding}, e pode envolver sinais e tipos de dados, conforme descrito na seção~\ref{sec:metamodelo-autonomo}. O nome empregado na definição de um elemento do contexto de um sintoma, representa uma variável que pode ser utilizada em uma expressão para representar o objeto correspondente em tempo de execução.

Quando uma variável é associada à um sinal, essa variável dá acesso à um objeto que apresenta como propriedades os parâmetros do sinal detectado, e a origem desse sinal. De forma similar, uma variável associada à um tipo de dados permite obter atributos de um registro de dados desse tipo.

Durante a execução da camada, vários sinais de um mesmo tipo podem ser gerados por diferentes recursos. Além disso, diversos registros de dados de um mesmo tipo podem existir em tempo de execução. Portanto, um mesmo sintoma pode ser detectado em diferentes contextos, gerando várias ocorrências do mesmo sintoma. Ao avaliar os sintomas, o monitor identifica quais combinações de ocorrências de um sinal e registros de dados tornam as expressões de condição verdadeiras, e gera uma ocorrência de sintoma para cada uma.

Apesar das condições de um sintoma poderem envolver diversos sinais, esses geralmente não ocorrem em um mesmo instante. O monitor implementado, assume que um sinal indica uma mudança de estado, e mantém um registro com a última ocorrência de cada tipo de sinal gerado por cada recurso.
Esse registro, implementado pela classe \textsf{SignalRegistry}, permite que sintomas que dependem de diversos sinais possam ser identificados. 


\subsection{Analisador}

Após a detecção de um sintoma pelo monitor, uma ocorrência de sintoma é repassada ao analisador. O analisador identifica a mudança necessária, de acordo com o definido no modelo e cria uma requisição de mudança. A requisição de mudança é representada em tempo de execução pela classe \textsf{ChangeRequestInstance} que carrega consigo além de informações sobre a mudança requisitada a ocorrência de sintoma que gerou a requisição. A implementação do analisador, por meio da classe \textsf{Analyzer}, é bastante simples pois a associação entre sintoma e requisição de mudança é estabelecida de forma direta no modelo.

\subsection{Planejador}

O planejador é implementado pela classe \textsf{Planner}, e possui uma implementação bem similar ao analisador. O planejador recebe uma requisição de mudança e identifica o plano de mudança apropriado. Após identificado o plano, a classe \textsf{ChangePlanInstance} é instanciada com informações do tipo de plano e da requisição de mudança recebida.

\subsection{Executor}

O executor é a última função do ciclo autônomo, e tem como função executar a ação definida no plano de mudança recebido. Ao receber um plano de mudança, o executor obtém a ação definida no plano e cria um acionador para esta ação. O plano de mudança recebido é utilizado como provedor de contexto para a execução da ação. Esse por sua vez engloba o contexto da solicitação de mudança e dos sintomas que geraram a mudança. Isso permite que a ação tenha seus argumentos associados ao contexto que desencadeou na sua execução.

\section{Políticas}

A avaliação de políticas em tempo de execução é conduzida pelo gerenciador de avaliação de políticas, implementado pela classe \textsf{PolicyEvaluationManager}. O gerenciador de avaliação implementa a interface \textsf{SignalHandler} e intercepta os sinais definidos como pontos de avaliação de políticas no modelo em execução. A figura~\ref{fig:ambiente-politicas} ilustra as classes envolvidas na implementação da avaliação de políticas.

\begin{figure}
 \centering
 \includegraphics[width=0.95\textwidth]{./fig/ambiente-policy}
 \caption{Classes que implementam a avaliação de políticas na camada.}
 \label{fig:ambiente-politicas}
\end{figure}

Ao identificar um sinal que define um ponto de avaliação de políticas, o gerenciador de avaliação gera uma requisição de avaliação de políticas, representada pela classe \textsf{PolicyEvaluationRequest}. Uma requisição de avaliação de políticas inclui as políticas que deverão ser avaliadas, e o contexto necessário para avaliação dessas políticas. O mapeamento entre o contexto do sinal que disparou a avaliação de políticas e a requisição de avaliação, é realizada de acordo com o definido no metamodelo, seguindo as regras de mapeamento de parâmetros descritas na seção~\ref{sec:ambiente-sinais}.

Uma requisição é encaminhada ao avaliador de políticas, implementado pela classe \textsf{PolicyEvaluator}. O avaliador de políticas avalia as condições de cada política em relação à cada recurso, e identifica o valor total de negócio associado à cada recurso, de acordo com o resultado da avaliação. Os resultados da avaliação são representados por meio da classe \textsf{PolicyEvaluationResult} que registra os valores de negócio associados à cada recurso. Além disso, o resultado da avaliação de políticas ainda engloba o contexto da requisição de avaliação que gerou estes resultados.

Após a avaliação de políticas, o gerenciador de avaliação identifica os tratadores de avaliação de políticas, associados ao grupo de políticas avaliadas. Conforme demonstrado na seção~\ref{sec:metamodelo-politicas}, um tratador de avaliação define uma ação a ser executada após a avaliação de políticas. Ao executar essa ação, gerenciador de avaliação de políticas utiliza o resultado da avaliação de políticas como provedor de contexto.





