{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf360
{\fonttbl\f0\froman\fcharset0 TimesNewRomanPSMT;\f1\fnil\fcharset0 LucidaGrande;}
{\colortbl;\red255\green255\blue255;}
\paperw11905\paperh16837\margl1134\margr1134\margb1134\margt1134\vieww20140\viewh12820\viewkind0
\deftab709
\pard\pardeftab709\ql\qnatural

\f0\fs24 \cf0 Como j\'e1 mencionado, modelos podem ser utilizados \
Uma das formas de se utilizar  se mostrado muito promissor est\'e1 associado ao uso modelos para\
\
ncreasingly, software should dynamically adapt its behavior\
at run-time in response to changing conditions in the supporting computing and communication infrastructure, and\
in the surrounding physical environment. In order for an\
adaptive program to be trusted, it is important to have\
mechanisms to ensure that the program functions correctly\
during and after adaptations. Adaptive programs are generally more di
\f1 \uc0\u64259 
\f0 cult to specify, verify, and validate due to\
their high complexity\
\
\
Modelos tem sido empregados com sucesso como um meio para lidar com a complexidade envolvida no gerenciamento de sistemas em tempo de execu\'e7\'e3o.\
O gerenciamento de sistemas que precisam ser monitorados, adaptados e evolu\'eddos durante sua execu\'e7\'e3o \'e9 realizado por meio da inspe\'e7\'e3o e manipula\'e7\'e3o de estruturas que representam o sistema em tempo de execu\'e7\'e3o.\
No entanto, a representa\'e7\'e3o de um sistema em execu\'e7\'e3o se baseia nas constru\'e7\'f5es da sua plataforma de execu\'e7\'e3o, e n\'e3o guarda qualquer liga\'e7\'e3o com as quest\'f5es que s\'e3o relevantes ao sistema em execu\'e7\'e3o.\
\
Nesse cen\'e1rio, o uso de modelos em tempo de execu\'e7\'e3o tem como intuito prover representa\'e7\'f5es mais apropriadas para os aspectos de um sistema em execu\'e7\'e3o, ocultando a complexidade de sua plataforma de execu\'e7\'e3o. Assim, os modelos atuam como interfaces que podem ser utilizadas por agentes para monitorar e manipular sistemas em execu\'e7\'e3o. Modelos de tempo de execu\'e7\'e3o est\'e3o diretamente relacionados \'e0 reflex\'e3o computacional, visto que ambos buscam definir representa\'e7\'f5es de um sistema que possuem uma rela\'e7\'e3o de causalidade com o sistema em execu\'e7\'e3o. No entanto, diferente da reflex\'e3o cujas representa\'e7\'f5es est\'e3o associadas \'e0 plataforma de execu\'e7\'e3o do sistema, modelos em tempo de execu\'e7\'e3o empregam representa\'e7\'f5es mais pr\'f3ximas ao problema em quest\'e3o.\
\
Assim, o uso de modelos em tempo de execu\'e7\'e3o pode ser considerado como a aplica\'e7\'e3o da abordagem de MDE \'e0 reflex\'e3o computacional \\cite\{mrt\}.\
\
pave the way for the development of environments in which\
change agents (e.g., software maintainers, software-based\
agents) use runtime models to modify executing software\
in a controlled manner.\
\
\
. In the case of MDE research on runtime models, the\
goal is to produce technologies that hide the complexities of\
runtime phenomena from agents responsible for managing\
the runtime environment, and for adapting and evolving the\
software during runtime.\
\
\
Attempts at building complex software systems that dynamically adapt to changes in their operating environments\
has led some researchers to consider the use of models during runtime to monitor and manage the executing software.\
\
Early work in this emerging MDE area was presented at a\
MODELS 2006 Workshop on runtime models [8].\
We envisage that MDE \
\
research on runtime models will\
pave the way for the development of environments in which\
change agents (e.g., software maintainers, software-based\
agents) use runtime models to modify executing software\
in a controlled manner.\
\
 The models act as interfaces that\
change agents can use to adapt, repair, extend, or retro\uc0\u64257 t\
software during its execution.\
\
 In our broad vision of MDE,\
models are not only the primary artifacts of development,\
they are also the primary means by which developers and\
other systems understand, interact with, con\uc0\u64257 gure and modify the runtime behavior of software.\
\
\
A major goal of MDE research is to produce technologies that shield software developers from the complexities\
of the underlying implementation platform. \
\
An implementation platform may consist of networks of computers, middleware, and libraries of utility functions (e.g., libraries of\
persistence, graphical user interface, and mathematical routines)\
\
. In the case of MDE research on runtime models, the\
goal is to produce technologies that hide the complexities of\
runtime phenomena from agents responsible for managing\
the runtime environment, and for adapting and evolving the\
software during runtime.\
\
\
\'95 Runtime models: These models present views of some\
aspect of an executing system and are thus abstractions\
of runtime phenomena. A growing number of MDEresearchers have started to explore how models can be\
used to support dynamic adaptation of software-based\
systems.\
\
\
\'95 System users can use runtime models to observe the\
runtime behavior when trying to understand a behavioral phenomenon (e.g., understanding the conditions\
under which transaction bottlenecks occur in a system), and to monitor speci\uc0\u64257 c aspects of the runtime\
environment (e.g., monitoring patterns of access to\
highly-sensitive information).\
\
\'95 Adaptation agents can use runtime models to detect the\
need for adaptation and to effect the adaptations. Effecting an adaption involves making changes to models\
of the parts to be adapted and submitting the changes\
to an adaptation mechanism that can interpret and perform the needed adaptations. Here it is assumed that\
the adaptations to be performed are pre-determined.\
\
. Consequently, these systems are \
required, when feasible, to adapt their behavior at runtime \
with little or no human intervention. \
\
------\
\
. A promising \
approach to managing complexity in runtime environments is to develop adaptation mechanisms that \
leverage software models, referred to as models@run.\
time. \
\
Models@run.time therefore builds on reflection but \
seeks to draw the work from the solution space up to\
the problem space, mirroring the similar influence that \
MDE seeks more generally on software engineering \
methodologies.\
2\
This leads to the following definition: a model@run.\
time is a causally connected self-representation of the associated system that emphasizes the structure, behavior, \
or goals of the system from a problem space perspective.\
\
A model can be any useful representation of the system, \
and it should be no surprise that a variety of techniques \
have been investigated for models@run.time. Some of the \
key dimensions include the following:\
\'95 Structure versus behavior. As in the reflection community, models tend to focus on either the structure of the \
underlying system or the associated, more dynamic, \
behavioral aspects. Structural models tend to emphasize how the software is currently constructed\'97for \
example, in terms of objects, inheritance relationships \
and invocation pathways; components and their connections; or aspects and their patterns of weaving. \
In contrast, behavioral models emphasize how the \
system executes in terms of flows of events or traces \
through the system, or the arrival of events and their \
pathway to execution\'97arriving, enqueuing, selection, \
dispatching, and so on.\
\'95	 Procedural versus declarative. Another key choice is \
whether the model is procedural, reflecting the actual \
structures or behaviors in the system (the nuts and \
bolts), or more declarative\'97for example, in terms of \
system goals. There is a clear pressure arising from \
the need for mirroring the problem space for more \
declarative models.\
\'95	 Functional versus nonfunctional. Most models that \
have been considered are based on the underlying \
system\'92s functionality, but there is an equal need for \
models that capture and represent nonfunctional \
characteristics. As an example of the latter, in the \
software performance field, researchers have looked \
at how performance models can be used at runtime \
to optimize system execution. Equally, there is a need \
for models that capture aspects such as the system\'92s \
security.\
\'95 Formal versus informal. Several models are inspired \
by the mathematics of computation whereas others \
are derived from consideration of programming \
models or domain abstractions. This special issue \
presents examples of both. The advantage of formal \
models is that they may support automated reasoning about the system\'92s state but equally may not \
adequately capture or express the required domain \
concepts so elegantly.\
}