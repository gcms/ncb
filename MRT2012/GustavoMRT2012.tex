\documentclass{sig-alternate}

\usepackage{graphicx}

\begin{document}

\conferenceinfo{Models@Run.Time}{'12 Innsbruck, Austria}

\title{Model-Driven Development of DSML Execution Engines\titlenote{This work was partly supported by the Capes Foundation, Brazil, Proc. 0759-11-2}}

\numberofauthors{3}

\author{
\alignauthor Gustavo C. M. Sousa \\ F{\'a}bio M. Costa\\
       \affaddr{Instituto de Inform{\'a}tica}\\
       \affaddr{Universidade Federal de Goi{\'a}s}\\
       \affaddr{Goi{\^a}nia-GO, Brazil}\\
       \email{\{gustavo|fmc\}@inf.ufg.br}
%\alignauthor F{\'a}bio M. Costa\\
%       \affaddr{Instituto de Inform{\'a}tica}\\
%       \affaddr{Universidade Federal de Goi{\'a}s}\\
%       \affaddr{Goi{\^a}nia-GO, Brazil}\\
%       \email{fmc@inf.ufg.br}
\alignauthor Peter J. Clarke\\
       \affaddr{School of Computing and\\ Information Sciences}\\
       \affaddr{Florida International University}\\
       \affaddr{Miami-FL, USA}\\
       \email{clarkep@cis.fiu.edu}
\alignauthor Andrew A. Allen\\
       \affaddr{Computer Sciences Department}\\
       \affaddr{Georgia Southern University}\\
       \affaddr{Statesboro-GA, USA}\\
%       \email{andrewallen@georgiasouthern.edu}
}

\date{July 2012}

\maketitle

\begin{abstract}
The combination of domain-specific modeling languages and model-driven engineering techniques hold the promise of a breakthrough in the way applications are developed. 
By raising the level of abstraction and specializing in building blocks that are familiar in a particular domain, it has the potential to turn domain experts into application developers. 
Applications are developed as models, which in turn are interpreted at runtime by a specialized execution engine in order to produce the intended behavior. 
% are interpreted or may be interpreted?
This approach has been successfully applied in different domains, such as communication and smart grid management. 
However, each time the approach has to be realized in a different domain, substantial re-implementation has to take place in order to put together an execution engine for the respective DSML. 
In this paper, we present our work towards a generalization of the approach in the form of a  metamodel and its respective execution environment, which capture the domain-independent aspects of runtime model interpretation and allow the definition of domain-specific execution engines as instances of the  metamodel. 
We present an initial validation of the approach in the context of the Communication Virtual Machine project, by realizing part of the execution engine architecture in the form of an instance of the proposed  metamodel. 
\end{abstract}

%To cope with the ever-present problem of growing soft- ware complexity MDE researchers need to develop tech- nologies that developers can use to generate domain- specific software development environments. These envi- ronments should consist of languages and tools that are tai- lored to the target classes of applications. Developing such technologies requires codifying knowledge that reflects a deep understanding of the common and variable aspects of the gap bridging process. Such an understanding can be gained only through costly experimentation and systematic accumulation and examination of experience. Developing such technologies is thus a wicked problem.
%\cite{FranceEtAl}

\category{D.2.11} {Software Engineering}{Software Architectures}[domain-specific architectures, languages]

\keywords{Models at Runtime, Model-Driven Engineering, Domain-Specific Modeling Languages, Metamodeling, Middleware}

%Research in model-driven software development (MDD)and domain-specific modeling languages (DSMLs) focuses on how models that provide good abstractions of complex software behaviors can be used to significantly improve software productivity and quality.

\section{Introduction}
%% Tell the whole story: problem, proposed approach to solution, results. 

%%TODO: FOR THE WHOLE SECTION... TRY TO FOCUS MORE ON THE MODELS@RUNTIME. I MEAN, I NEED TO MAKE MORE EXPLICIT THE RELATIONSHIP BETWEEN THE WORK AND MODELS@RUNTIME
%Model driven engineering is being proposed as an approach to deal with the growing complexity involved in the development of modern applications.
%These applications commonly operate in a distributed and heterogeneous environment and must behave in a dependable manner. 
%These applications also often need to adapt at runtime to comply with changing requirements and environment.
%In order to achieve these goals the developers need to employ a variety of strategies to 

Model-driven engineering (MDE) proposes the use of models as a way to deal with the increasing complexity of contemporary software applications \cite{FranceEtAl}. These applications usually operate in a distributed and heterogeneous environment and must be able to dynamically adapt in order to meet changes in the requirements and operational environment. Their development and maintenance using traditional approaches often require a huge effort due to the limitation of abstractions based on the implementation platform. % to deal with the large number of details
% traditional: (computer/technological centric) 
% limitations: (too generic/distant from the problem)

%MDE proposes to simplify the development of applications.
%By employing models built upon abstractions of the problem domain.
%MDE looks forward reducing the complexity due to the the technical details in the translation from domain concepts to platform concepts.

%% OBS: First we introduce the MDE approach of using DSMLs and automated processing
%In order to reduce this complexity, MDE relies on DSMLs and automated processing of models.
%Models can be either transformed or interpreted.
By employing models built upon abstractions that are closer to the problem at hand, model-driven approaches seek to abstract details of the implementation platform, thus simplifying the development and maintenance of these applications. Models are usually described in a domain-specific modeling language (DSML) and are automatically processed by tools that either translate the models into artifacts of the target implementation platform or directly interpret them.

% Maybe move these phrases into the preceding paragraph?
The use of high-level graphical DSMLs may enable domain experts, or even end users to create applications right from their requirements. 
Moreover, models may be used during development to construct new applications or at runtime to dynamically change an executing system. The use of execution engines that directly process models eases the usage of models that may be created and changed at runtime.
%%By employing this approach models can be as high-level as to be created by domain experts or even end users

%% OBS: Then we discuss about the DSML
%The use of high level (and maybe graphical) DSMLs?
%Making it possible for domain experts, or even end users to create applications from their requirements.

% OBS: And next we discuss about the automated processing as an interpreter (exeution engine)

%%Besides allowing the development of applications, these software also enables the users to adapt applications during their runtime by manipulating models. These virtual machines are execution engines for DSMLs named CML and MGridML respectively.
The Communication Virtual Machine (CVM) \cite{Deng20081640} and the MicroGrid Virtual Machine (MGridVM) \cite{DBLP:conf/seke/AllisonAYC11} are examples of software that employ MDE techniques to allow users to create complex applications using high-level graphical DSMLs. 
% They provide a high level service upon a heterogenous set of resources
%These virtual machines are execution engines for DSMLs named CML and MGridML respectively.
Their execution engines are capable of processing models described in their respective DSML and realize the services described by them. Such models can also be changed at runtime, triggering adaptations to achieve the newly described requirements. 

%%Don't forget to mention that its not only applications, but complex applications
% TODO: make the concept of execution engine clearer
% TODO: MAKE IT CLEAR THAT THE MODELS PROCESSED BY THESE ARE MODELS@RUNTIME

% QUESTION: maybe change the order of ideas introducing the need to embody knowledge into the DSML and execution engine before the CVM and MGridVM
% QUESTION: maybe introduce it not in terms of CVM/MGridVM
% QUESTION: While mentioning CVM should we mention here that it works by analyzing changes in the model and synthesizing scripts? Or should we delay it to the Background?
%ALTERNATIVE: State that the use of an interpreter (herein called execution engine) enables the use of models to also change the runtime behavior using constructs closer to the problem domain


%to allow the above (user built applications)?
%DSMLs, along with the mechanisms for their processing embed concepts and semantics of the domain.
%Once we have a DSML and the mechanism for processing it, users can directly develop applications in that DSML.

To enable users to directly create and execute applications in a DSML, much of the knowledge of the application domain must be embedded into the DSML and the execution engine. While this approach simplifies the development of applications in these domains, the same is often not true regarding the execution engines that interpret these DSMLs. These engines are commonly developed in general purpose languages and are usually built from scratch for an specific DSML.


%While the development of applications in these domains employing their respective DSMLs is quite simple, the same is not true when talking about the execution engine that interprets their languages. These mechanisms are commonly developed in general purpose language and are subject to all the technical complexities involved in the traditional software development.

%Despite that, these execution engines share a lot of commonalities.
%Their applications basically provide a high-level service upon a set of heterogeneous resources.
%In order to do that, the runtime engine may need to execute many operations related to the processing of models, negotiation of configurations, synthesis of commands, evaluation of policies, runtime adaptation, and etc.

Despite being tailored for different DSMLs, execution engines of CVM and MGridVM share a lot of commonalities as both of them are focused on providing high-level services on the top of a heterogeneous set of resources. Both of these engines need to deal with operations related to the processing of models, negotiation of configurations, synthesis of commands, evaluation of policies, runtime adaptation, etc. Both CVM and MGridVM were built upon a layered architecture, in which each layer has a set of well-defined responsibilities.

%TODO: Give a better look at how the chapter about the CVM mentions these features and the similarity between these VMs
%%Both CVM and MGridVM are built upon a layered architecture, in which each layer has well defined responsibilities.
%Although the communication domain is the focus of this chapter, we are currently applying the approach to other domains, such as the microgrid energy management applications (Allison, Allen, Yang, & Clarke, 2011). That is, we are in the process of developing the Microgrid Modeling Language (MGridML) and the Microgrid Virtual Machine (MGridVM) using the approach describe here. By applying our approach to multiple domains, we hope to eventually show how the approach can be generalized as a new way for defining semantics for i-DSMLs that can be directly executed by a virtual machine.

In this work, we envision an approach to generalize the construction of this category of execution engines, that are aimed at the processing of DSMLs related to the provision of services upon a set of resources and capable of transparently executing models created or changed at runtime.

Taking that into account, we propose a model-driven approach to the construction of these execution engines that stems from the solutions employed in the development of CVM and MGridVM. By doing so, we expect to assist the construction of these DSML execution engines. Our approach relies on a generic layered architecture and the use of modeling as a way to specialize these architectures into an execution engine for a given DSML.

%Taking that into consideration, we propose a model-driven approach to the construction of execution engines for the provision of high-level services described by DSMLs upon a set of resources. Doing so, we look forward a way to assist the construction of DSML execution engines. 
%%Generalization of approach. The long-term goal of this research project is to generalize the approach on developing i-DSMLs. We expect to create an infrastructure that can be used to assist with developing the i-DSML (see Figure 1), capturing the domain-specific behavior (maybe using LTSs e.g., Tables 4 and 5), and generating the domain specific VM (transformation shown in Figure 4).
%Such an infrastructure would require: (1) defining a set of domain characteristics that are well suited for these i-DSMLs, (2) a meta-metamodel that can be used to define both the i-DSML and its interpreter, (3) a method for capturing the domain-specific behavior and integrating it into the interpreter.

We illustrate our approach by presenting a  metamodel designed for the construction of one of the layers of the proposed architecture. Next, we demonstrate how this  metamodel can be used to create a model that describes the same behavior of the equivalent layer in CVM.

%Our approach relies on the experience acquired in the development of CVM and MGridVM to propose a generic architecture and the use of modeling as a way to specialize it.
%We illustrate this approach by presenting a  metamodel designed to describe one of the layers of the proposed architecture.
%Next, we create an instance of this  metamodel that describes the same behavior expected from the correspondent layer in the CVM.

In Section ~\ref{sec:background} we review the concepts involved in this work. Section ~\ref{sec:approach} describes our proposed approach. Section ~\ref{sec: metamodel} describes the  metamodel of part of the architecture and section ~\ref{sec:runtime} explains the runtime environment needed to process the models descbribed using the proposed  metamodel. Section ~\ref{sec:instance} shows an instance of the  metamodel that describes a layer of CVM.


\section{Background}
\label{sec:background}
% MDE, DSMLs and models at runtime; analogy with the distinction between structural reflection (modeling of the language) and behavioral reflection (modeling of the execution engine);

%In this section, we review the principles of model-driven engineering and domain-specific modeling languages. We also introduce the Communication Virtual Machine.

\subsection{Model-Driven Engineering}

The term Model-Driven Engineering is commonly used to describe of a set of software engineering approaches that employ models as their primary artifacts. In these approaches, the use of models is not restricted to the documentation or design of software, but may extend through all the software engineering process.
%By employing models based on abstractions closer to the problem to be solved, model-driven approaches seek to abstract technical details of the underlying platform, therefore simplifying the engineering of software. To make it feasible, these approaches rely on automated tools for the processing of models into constructs of the implementation platform.

Models are usually described in domain-specific modeling languages, and processed by automated tools into constructs of the implementation platform \cite{Schmidt}. The use of domain-specific models switches the focus of software engineering from implementation technologies to problem-level abstractions.
Nonetheless, automation in the processing of high-level models into software implementation requires encoding substantial domain-specific knowledge into the language and the processing tools

A modeling language is described using a  metamodel, which is itself a model that defines the abstractions available in the domain and how they interrelate. Metamodeling is standardized by the OMG Meta-Object Facility \cite{Omg_2006}, but there are several tools such as the Eclipse Modeling Framework \cite{emf}, that provide metamodeling capabilities.

Domain-specific models may be transformed into artifacts of the implementation platform or directly executed by a model interpreter. The use of model interpreters has the potential of facilitating the processing of models at runtime in order to adapt a running application. This usage of models has been proposed as an alternative to deal with the growing complexity of contemporary software \cite{FranceEtAl}.

The use of models at runtime seeks to use better abstractions for manipulating and inspecting a running system. Models at runtime bear a certain resemblance with reflection in which both deal with self-representations of a system that are causally connected. However, models at runtime look for representations that are closer to the problem domain, in contrast with reflection whose representations tend to be based on the implementation platform \cite{Blair2009}.

\subsection{Domain-Specific Modeling Languages} 

Domain-specific languages (DSLs) provide constructs that are directly related to the concepts of a given problem domain. Through the use of appropriate concepts and notations, DSLs may enable domain experts or even end users to create applications.
Unlike general-purpose languages, that may be employed for large set of tasks over multiple domains, domain-specific languages are usually restricted to a delimited set of tasks in a particular domain. Nevertheless, DSLs offer a greater expressive power on their focused domain \cite{vanDeursen:2000:DLA:352029.352035}.


A domain can be viewed as a delimited area of interest. We can categorize domains as a technical domain, such as persistency, graphical user interface, databases, or as a business domain, such as insurance, telecommunication, banking. Still, this separation is sometimes blurry and the proper delimitation of a domain should be defined according to the problem at hand.

Model-driven engineering provides conceptual and tool support for language engineering, and is therefore suitable for the construction of domain-specific languages \cite{Kurtev:2006:MDF:1176617.1176632}. MDE employs metamodeling to describe the constructs in these languages, henceforth called domain-specific modeling languages.

As other languages, a DSML may be defined in terms of its syntax and semantics. The syntax of a DSML may be further divided in concrete syntax, which represents the textual or graphical notations of the language, and abstract syntax, which represents the concepts available in the language and how they are related. The semantics is also commonly treated separately as static semantics, which define well-formedness criteria, and dynamic semantics which gives meaning to models.

Metamodels can be employed to describe the abstract syntax and static semantics of a language. Moreover, there are  tools often provide support for the construction of concrete syntax and their mapping to a metamodel. However, there are not yet widely accepted methods for describing the dynamic semantics of DSMLs \cite{Kurtev:2006:MDF:1176617.1176632}. Current methods usually rely on transformations from the DSML metamodel to another language with well-defined semantics or modeling the operational behavior associated to language constructs.
% Both approaches can be implemented by code in general-purpose languages
%There are standardized languages for defining both transformations and operational semantics, but they tend to be generic in a way that sometimes they do not provide greater advantage than the use of a general-purpose language.

\subsection{Communication Virtual Machine}

% refer to CVM papers that describe the approach based on identifying the differences between models (chapter and Runtime models to support...)

The Communication Virtual Machine (CVM) is an execution engine designed for the creation and realization of user-centric communication  \cite{Deng20081640}. CVM works by processing models described in a very high-level domain-specific modeling language called Communication Modeling Language (CML). A CML model describes a communication scenario by defining and associating elements of the communication domain such as connections, participants, media types and attached devices. 

Once a CML model is fed into the CVM, it is capable to realize the described service independently, abstracting from the user details involved in the negotiation of capabilities or selection of communication technologies. CML models can also be changed at runtime and reprocessed in the CVM, that identifies the differences between the models and executes the operations needed to meet the new requirements \cite{Wang}.

CVM is built on a layered architecture that lies between the user and the underlying communication frameworks. The first layer, called \emph{User Communication Interface} (UCI) provides an interface for interacting with the CVM and an environment for the construction and management of CML models. Models received by the UCI are transformed into an internal XML representation and sent to the \emph{Synthesis Engine} (SE) layer. The primary responsibility of SE is to identify changes in an executing model (or new models) and synthesize an executable communication control script. \emph{User-centric Communication Middleware} (UCM) executes the communication control script and assures that desired policies are enforced. Finally, the \emph{Network Communication Broker} layer provides a technology independent interface that masks the heterogeneity of the communication frameworks available for the realization of the communication services. 

\section{Generic Architecture of the Execution Engine}
\label{sec:approach}

%% TODO: After writing the section, find a way to mention the two point-of-views of the model of execution engine: modeling the dynamic (operational) semantics or modeling the behavioral aspects
%% ALSO: The combination of models of the layers can be viewed as a megamodel??? e.g. in fact the model of the platform is a mega-model composed by the models of the layers. the whole environment may also be a megamodel that composes the DSML metamodel, and the execution engine model


%- Like we introduced, in order to get the benefits of MDE (including m@rt) we need DSMLs and their execution engine
%- While the syntax and static semantics of a DSML can be described by a  metamodel, their dynamic semantics is embeded in the execution engine
As introduced before, in order to leverage MDE to enable the use of high-level models for the development and runtime adaptation of applications, the construction of DSMLs and their execution engines is needed. While the abstract syntax and static semantics of a DSML can be described by a  metamodel, its dynamic semantics are usually embedded in the execution engine.
%Therefore, from a language viewpoint the modeling of an execution engine can be viewed as a way to describe its DSML dynamic semantics.
%Still, these execution engines are also designed for processing models that can be created and changed at runtime.



%% Describe the overall design without going into details of the  metamodel.
%Overview of the approach:
%- Integrate a  metamodel that describes the abstract syntax and static semantics of a DSML to a model that describes the execution engine for that language (that on its turn encapsulates the static semantics... it was described in the background) 
%- While there are several tools that can be used to define the metamodel and concrete syntaxes for DSMLs, there is little support for defining the dynamic semantics that the execution engine embedded.

We propose the integration of the  metamodel of a DSML with a model that describes its execution engine as a way to create platforms targeted at the development of applications using high-level models that can be created and changed at runtime.
While there are several standardized tools that employ modeling techniques for the construction of  metamodels, support for the definition of dynamic semantics is still limited.
%Dada uma DSML previamente definida, podemos definir um execution engine que vai executar instancias dessa DSML
%Como benefício temos:
%- Futuras mudanças no execution engine podem ser para atender mudanças na linguagem (e.g. novas construções) ou para atender requisitos de diferentes ambientes
%ligação entre linguagem e plataforma não é formalizado (mencionar como limitação/future work)
We expect that by extending the use of MDE techniques to the definition of execution engines we can not only simplify the construction of execution engines, but also make it easier to evolve them to support changes in their DSML or in the implementation platform. 
%The ability to manipulate the execution engine also enables the modification of the behavior...

\begin{figure}
 \centering
 \includegraphics[width=0.3\textwidth]{overall}
 %% Structure the description around a block diagram. Diagrama de blocos do fluxo para empregar a abordagem
%Figure showing: {DSML  metamodel (abstract syntax [mof], static semantics [ocl]) + concrete syntax [gmf] + dynamic semantics [?]} composing an environment for the development of applications and show a M@RT being fed into this environment
% \includegraphics[width=0.40\textwidth]{./fig/uvm}
 \caption{An execution engine described by a model is used to execute DSML application models}
 \label{fig:overall}
\end{figure}

%%Emphasize the separation between the domain-independent aspect of model execution and the definition of the DSML (and how you link a particular execution engine definition to its respective DSML).
Despite differences in the dynamic semantics of different DSMLs, they quite often rely on a common set of operations regardless of the application domain.
The processing of runtime models usually requires from the execution engine capabilities for model analysis and negotiation, transformation of models into different representations, as well as for runtime adaptation, among others.

In order to enable the construction and manipulation of models that represent an execution engine, we need a language for that. This language needs to be powerful enough to allow the description of virtual machines for different application domains, like the ones described above. Still, this language should not be very generic, as this could make model manipulation as difficult as writing code in a general-purpose language.
Therefore, this language should be made up of constructs related to the domain independent aspects of execution engines designed for providing high-level services described in a DSML. Thus, such a language can be regarded as a domain-specific language for the technical domain that encompasses the technical aspects involved in the use of a heterogeneous set of resources for the realization of high-level services described in a DSML.
% MAYBE: procurar referencia que linguagem precisa ser de domínio específico para se tornar realizável
% ref sobre domíno técnico também, ou mencionado no background


%%Discuss the general application of the approach in CVM-like architectures, but limit it to the broker layer for the purposes of scoping the current work.
%- based on the solutions employed by CVM/MGridVM, i.e. layered architecture with separation of responsibilities; 
%- a model based way of specializing this generic architecture i.e. employing a  metamodel and instances that specialize
Our approach builds on the solutions employed in the development of execution engines for communication and microgrid energy management. We aim to identify a generic architecture that can be specialized to produce execution engines for any given DSML. This domain independent architecture is structured in the following layers:

\begin{itemize}

\item  \emph{User Interface}, that provides an external interface for interacting with the execution engine. This layer also supports the construction and management of models by users;

\item \emph{Synthesis Engine}, whose main task is to transform a declarative model received from the user interface into a control script to be executed at the next layer; 

\item \emph{Middleware}, that besides executing the synthesized scripts, also manages the services under provision and applies constraints related to security and quality of service among other domain specific concerns;

\item \emph{Broker}, that is responsible for the management of resources. This layer provides to  the upper layer a uniform interface that abstracts not just the differences between resources, but also all details involved in their setup, monitoring, and selection, among other resource management operations.
\end{itemize}

Based on this architecture, we propose its specialization by the construction of  models that represent the mentioned layers in a given domain. Each of these models should be constructed in conformance to a  metamodel that provides abstractions related to the responsibilities of the layer as described by the generic architecture. Therefore, an execution engine for a given model is constructed by creating models for each of the layers just described.

In this paper, we will limit our discussions to the Broker layer which was the primary focus of this phase of the work. The Broker layer is responsible for the management of the resources that will ultimately be used to realize a requested service. Therefore, we build a  metamodel that provides abstractions for the definition of the behavior expected to meet the responsibilities of a broker layer. These comprise the provision of a uniform interface over its managed resources, shielding the middleware layer from setup and configuration details of resources, and the self-management of the layer in order to offer the best service according to its policies and environment constraints.

%O Intermediador de Serviço é a camada da arquitetura proposta que é responsável pelo gerenciamento dos recursos que serão efetivamente utilizados para prover o serviço solicitado. Cabe à esta camada disponibilizar uma interface de serviços que abstraia as especificidades dos recursos gerenciados para a camada superior. Além disso, o SB deve possuir capacidade de auto gerenciamento, ocultando os detalhes envolvidos na seleção, monitoramento e preparação dos recursos sob sua gerência.

%Como uma interface de serviços, o SB se comunica com o UM através de chamadas que podem ser invocadas e eventos que podem ser gerados sinalizando alguma situação. Assim sendo, ao definirmos o comportamento dessa camada, precisamos descrever como serão tratadas as chamadas realizadas pela camada superior, e em que situações serão gerados determinados eventos. Mas além disso, também precisamos descrever como outras tarefas serão realizadas, incluindo o monitoramento e seleção de recursos, manutenção de informações, adaptação da camada, entre outros.

%Com isto em mente, neste trabalho, construímos um  metamodelo que possibilita a modelagem do comportamento necessário para atender as responsabilidades definidas para a camada de intermediação de serviço da arquitetura proposta. O  metamodelo em questão contempla a descrição dos seguintes  aspectos envolvidos no cumprimento destas responsabilidades:

\section{Metamodel for the broker lay-er}
\label{sec: metamodel}
% Show the class diagram and describe elements of the  metamodel. May structure the section based on the major blocks of the  metamodel.

As mentioned in the preceding section, a broker layer is responsible for providing an independent interface upon its set of managed resources. A broker should also be able to monitor its resources and decide which actions may need to be taken in order to meet the requests received from its interface. Thus, the proposed  metamodel contains abstractions for the description of the interface, managed resources and internal state maintained by the layer. It also enables the description of autonomic behavior and policies for the selection of resources.

The  metamodel for the broker layer was designed using the Eclipse Modeling Framework (EMF) which provides support for the construction and processing of the  metamodel instances. The  metamodel is structured around a class called \textsf{Manager} that defines a context for the management of resources and aggregates elements for describing the main aspects of the layer. Figure ~\ref{fig:metamodel} shows a class diagram of the  metamodel displaying the main classes and their relationships.

\begin{figure*}
 \centering
 \includegraphics[width=0.90\textwidth]{metamodel2}
 \caption{Overall view of the  metamodel for the definition of a broker layer}
 \label{fig:metamodel}
\end{figure*}


An instance of a \textsf{Manager} has an interface and can also be viewed as a resource by other managers, facilitating the modularization of the layer and the reuse of specialized resource managers as building blocks for higher-level managers. Therefore a broker layer may encapsulate a hierarchy of managers where the top-level manager defines the interface of the layer.


\subsection{Interface}
In the proposed metamodel, the interface for the use of a manager is defined by provided calls and events that may be signaled to the upper layers. The class \textsf{Interface} is used to describe the interface of managers and resources. This class groups a set of calls and events that are respectively described by classes \textsf{Call} and \textsf{Event} which inherit from class \textsf{Signal}. A \textsf{Signal} in turn has a name and a set of named parameters defined by the class \textsf{Parameter}. Since a broker layer is defined in terms of its top-level manager, their interfaces are also the same and therefore the interaction between layers follows the same approach based on provided calls and signaled events.

\subsection{Signal handling}
The actual behavior of a broker layer is defined by what it does when it is called from the upper layer or when a given event is generated by the resources underneath. In the broker  metamodel, this is done by defining which action should be taken as a response to a given signal. 
When a signal, which may be either a call or an event, is received, the corresponding action is executed. %This approach draws inspiration from event-driven architecture

In this  metamodel, \textsf{Signal}, \textsf{Handler} and \textsf{Action} are the main classes used to define the signal handling of a given manager. While signals are described as part of an interface, actions and handlers are directly grouped in the manager. An action represents some operation that can be executed and is defined by the abstract class \textsf{Action} which has the following subclasses:

\begin{itemize}

\item  \textsf{MacroAction}: allows the user to define a Java class that implements the intended action

\item \textsf{CallAction}: defines a call to be enqueued or executed in the managed resources or in the manager itself

\item \textsf{EventAction}: defines an event to be generated to the upper layers

\item \textsf{SequenceAction}: combines a list of actions to be executed in a sequence

\end{itemize}

To define a handler, the modeler needs to indicate the signal that it handles, whether it is enabled, and the action that will be taken.
In addition, it is necessary to define how the parameter values that come with a given call or event should be mapped into the context needed for the execution of the corresponding \textsf{Action}. This binding is mediated by a class named \textsf{ActionExecution} which groups a set of \textsf{ParameterBinding}s. A parameter may be bound to a fixed value, a parameter value, an expression, or even the result of a call to another action. This latter option, together with the use of sequence actions, enables the definition of elaborate actions that can be used to handle a signal.

% we look forward to extend the types of actions specializing into new operations that are currently only realized through macroactions such as querying/storing data in state management


\subsection{Resource management}
The \textsf{ResourceManager} in the  metamodel has the goal of describing the interface of the managed resources and how they will be obtained at runtime. The interfaces of resources are described in the same way as the manager interface, i.e., by employing the class \textsf{Interface}. The way the resources are obtained, in turn, is defined according to the subtypes of \textsf{ResourceManager}. The current  metamodel includes a class named \textsf{InstanceResourceManager} which may be used to describe a fixed set of resources that are created by instantiating an implementation class. Other subtypes that define more elaborate ways of obtaining resources, such as from distributed objects repositories, may be easily defined.

An instance resource manager groups a set of instances defined by the type \textsf{Instance}. An \textsf{Instance} specifies the actual implementation class of a resource, which will be instantiated at runtime. \textsf{Instance} is also a subtype of \textsf{Annotable}, making it possible to define meta-data describing features and properties associated to the resource, which may be eventually employed in the selection of resources. 

\subsection{State management}

In a significant number of cases, the processing of a given call or event may depend upon signals that were previously received by the layer. A given signal can be processed differently according to the parameters of a preceding call, the simple occurrence of an event, the result of the processing of a signal, etc. In order to support the variability in signal processing, the layer should be able to keep state between occurrences of signals.

The class \textsf{StateManager} provides a way to define the data types that need to be kept by a given manager at runtime. Data types are defined through the class \textsf{State} by a simple structure, where a type is defined in terms of its attributes and subtypes. Subtypes are also defined as instances of \textsf{State} and therefore may have the same features.  Also, as in a relational model, the definition of a type requires the selection of a key attribute that uniquely identifies a register of a given data type.

\subsection{Autonomic computing}

Besides abstracting the differences in capabilities and interfacing of resources, a broker layer should also mask from the upper layers the dynamics involved in the utilization of the resources. By doing so, the layer is capable of providing an interface that keeps the upper layers oblivious of the details of selection, setup and maintenance of resources, thereby reducing the complexity of the modeling in the upper layers.

The signal handling provided by the  metamodel enables to a certain degree the handling of events (generated by resources) and calls (received from the upper layer). These constructs, associated with state management, make it possible to define how resources and requests will be monitored in order to identify a variety of scenarios that require an action to be taken.
Nonetheless, these abstractions are not appropriate for the description of more complex situations that may involve many resources, the current layer state, and data from received calls, among others.

To facilitate the definition of the self-management of the layer, the proposed  metamodel includes a group of abstractions inspired by the IBM autonomic computing architecture \cite{ac}. This architecture suggests the use of a control loop called MAPE-K, which executes the MAPE (Monitor, Analyze, Plan, Execute) functions and use Knowledge.
%- Em tal arquitetura o gerenciamento se dá através de um control loop MAPE-K
% Explicar MAPE e Knowledge, que inclui os sintomas, change requests, change plans
%The Autonomic Computing Architectural Blueprint (see Resources for a link) describes an autonomic manager as: an implementation that automates some management function and externalizes this function according to the behavior defined by management interfaces. The autonomic manager is a component that implements the control loop ... For a system component to be self-managing, it must have an automated method to collect the details it needs from the system; to analyze those details to determine if something needs to change; to create a plan, or sequence of actions, that specifies the necessary changes; and to perform those actions. When these functions can be automated, an intelligent control loop is formed.

The constructs in the  metamodel allow for the description of rules that define the creation and transmission of knowledge between the MAPE functions. Thus, during the modeling of the layer, rules for the detection of symptoms, identification of change requests and selection of change plans need to be defined. At runtime, the monitor function makes use of these rules to identify the occurrence of a symptom and transmit this knowledge to the next function. The analyzer and planner functions work in a similar way, by evaluating its rules against knowledge received from previous functions.

The class \textsf{AutonomicManager} groups the elements that are related to the autonomic management of resources. These elements describe the rules for the generation of knowledge, such as symptoms, change requests and change plans. The class \textsf{Symptom} defines a set of conditions for the detection of a given symptom. At runtime, the resources and the state kept by the layer are continuously monitored, and when all conditions of a symptom are met, an occurrence of the symptom is generated and sent to the analyzer.

The conditions that define a symptom are described using expressions. Therefore, in addition to the conditions, the class \textsf{Symptom} defines the context for evaluation of these expressions. The context is defined through the class \textsf{Binding}, which is used to map a name used in the expression to an instance of the type \textsf{Bindable}. The interface \textsf{Bindable}, in turn, is implemented by the classes \textsf{Signal} and \textsf{State}. This structure allows for the definition of conditions that combine data from calls and events, as well as from the state kept by the layer.

The \textsf{ChangeRequest} class is used to specify that a change request needs to be generated at runtime when a given symptom is detected. A change plan, defined as an instance of the class \textsf{ChangePlan}, associates a change request to an action to be executed. An action, in turn, may be any of the \textsf{Action} subtypes.

% Enquanto a função de planejamento pode empregar algoritmos complexos que geram dinâmicamente planos  de mudança que podem envolver um workflow completo de execução, no trabalho em questão optamos por uma abordagem simples, onde um plano é diretamente associado a uma solicitação de mudança

\subsection{Policies}
In the proposed  metamodel policies are employed to drive the selection of resources. The class \textsf{PolicyManager} groups abstractions related to the definition of policies and their evaluation. These comprise \textsf{Policy}, which identifies a policy, \textsf{PolicyEvaluationPoint}, which defines when policies should be evaluated, and \textsf{PolicyEvaluationHandler}, which defines how the policy evaluation result should be handled. Besides that, the  metamodel also includes auxiliary constructs for establishing links between these main elements.

%As mentioned earlier, resources may be annotated with their features and properties.
%A policy specifies a condition over a feature that may be present in resources, and the business value that is associated to the reaching of this condition.
%At runtime, the resource that achieves the highest accumulated business value is selected among the available resources.

An evaluation point is defined by specifying a signal which triggers the evaluation of policies, and the policy evaluation handler that will be executed after the evaluation to handle its result. A policy evaluation point is linked to its handler by an instance of \textsf{PolicyEvaluationRequest}, which is responsible for defining the parameter mapping between the context of the signal that initiated the evaluation, and the parameters required for the evaluation itself. Finally, a policy evaluation handler defines an implementation class (similar to the macro action) that is executed on the results of the policy evaluation process.
%The scope of the policies is implicitly defined as the set of resources associated to the same manager.


\section{Execution Environment}
\label{sec:runtime}

% Describe the execution engine based on EMF. This section corresponds to the implementation section that goes in most papers. Make it clear in the text that it is the implementation.

%% Describe why the execution environment is needed
%- The  metamodel allows for us to define a Broker layer...
%- but in order to execute it so that it is capable of handling requests from the middleware layer ...
%- we developed an execution engine (that therefore provides dynamic semantics to the  metamodel)
Though the  metamodel provides abstractions that enable the description of a broker layer, it is not enough to have an executable layer, capable of handling requests at runtime. In order to fill in this gap, we developed an execution environment that loads a broker layer model and behaves accordingly, therefore providing operational semantics for the proposed  metamodel.


%% MAKE IT CLEAR that the execution engine loads the XMI models defined by using EMF
%- The execution environment loads a Broker layer model defined as an EMF XMI file.
%- Based on this model, the execution environment initializes a Broker layer for a DSML execution engine.
%- It uses the classes generated by EMF from the  metamodel to process the model.
The provided execution environment was developed in the Java platform and comprises components for executing a broker layer model and a library for interfacing with the resources to be managed by the layer. It loads a model described in EMF XMI 2.0 and initializes a broker layer for a DSML execution engine.

% Introduction to understand the following paragraphs
%in this section we deal with the actual implementation that actually process the requests driven by a given Broker model
%- The name of the classes are overloaded (always refer to the implementation exception when mentioned)
%- The architecture resembles the  metamodel
In this section, we describe the implementation of this execution environment, including its main components and how they interact in order to provide the behavior described by the model loaded in it. Though the names employed for describing these components may be the same used for elements of the  metamodel they are not the same. The components described here are part of the actual Java implementation but are related to their homonymous in the  metamodel.

% Describe the overall flow of the execution environment
Under the implemented execution environment, a broker layer constantly waits for calls from the upper layer or events from resources, that once arrived are enqueued for later processing. In order to process a signal, the appropriate handler is found and executed. In accordance with the model, the handler executes the associated action that may interact with resources and manipulate the state maintained by the layer. Specialized handlers are also set up for handling signals that may activate self-management functions.

The figure ~\ref{fig:environment} illustrates the
%flow of control for 
main elements that compose
a broker layer at runtime. The \emph{Broker Manager} is the main element of the execution environment which is the responsible for controlling the flow of execution. It is a runtime object that realizes a \textsf{Manager} described in the  metamodel.
%Therefore, at runtime a \emph{Broker Manager] may also be used as a resource for another \emph{Broker Manager}  and so on

\begin{figure*}
 \centering
 \includegraphics[width=0.7\textwidth]{environment}
 \caption{Execution environment for the broker layer}
 \label{fig:environment}
\end{figure*}

A \emph{Broker Manager} serializes the handling of signals by enqueueing them and afterwards processing them one at a time. Once a signal is dequeued, it is processed by the \emph{Signal Handler Manager} that identifies and executes the correct handler for the given signal. The \emph{Signal Handler Manager} maintains a registry of \emph{Signal Handlers} and searches for the first that is capable of handling the given signal. \emph{Signal Handlers} in the registry are loaded from the handlers and actions defined in the executing model, in conformance to the equivalent  metamodel constructs mentioned earlier.

%signals/events
%handlers registered into the SignalHandlerManager
Besides those, the specialized \emph{Autonomic Signal Handler} and \emph{Policy Evaluation Signal Handler} are also set up for monitoring signals that may be of interest for self-management. \emph{Autonomic Signal Handler} checks if a signal is related to any of the symptoms that are to be monitored and if positive sends the signal information to the \emph{Autonomic Manager} that may then execute its functions. The \emph{Policy Evaluation Signal Handler}, in turn, verifies if a signal is defined as a policy evaluation point and requests the \emph{Policy Manager} to start the policy evaluation process. Regardless of their result, these specialized handlers leave the signal flagged as not handled, so that it can be handled by an action defined in the model. An action


The \emph{Resource Manager} provides an interface for querying and obtaining its managed resources. These resources are returned as instances of \textsf{Resource}. \textsf{ManagedResource} is a subtype of \textsf{Resource} and wraps the actual resource along with its metadata. \textsf{BrokerManager} is the other subtype of \textsf{Resource}, which allows a \emph{Broker Manager} to be employed as a resource.
In order to be managed by a broker layer, resources should implement the \textsf{Manageable} interface and annotate their provided calls with a \textsf{@Call} annotation. Resources should also use the provided class \textsf{Event} to signal an event to be handled by the layer. The \emph{Resource Manager} interacts with a resources through a touchpoint which serializes calls to a resource and handles the events signaled by resources.
% Also expose the setEventListener method
% Main manager registers into the resource manager as a listener of the resource events

In a similar way, the \emph{State Manager} provides an interface for creating and querying registers for the data types described in the  metamodel. A data register is represented by the class \textsf{StateHolder} that provides methods for obtaining the values for its attributes and children.
% autonomic manager registers into the state manager as a listener of state changes

%Both state and resource managers are made available to macro actions, so that such actions can query and change the layer state and interact with the resources.

The \emph{Autonomic Manager} encapsulates the MAPE functions and may be activated by signals filtered by the \emph{Autonomic Signal Handler} or state changes notified by the \emph{State Manager}. Once one of these events occur, the \emph{Monitor} function identify the related symptom definitions and reevaluate their conditions.
If the conditions are met the \emph{Monitor} notifies the \emph{Analyzer} of the symptoms that were detected. Along with the notification it also sends the context in which the conditions for a symptom were evaluated as true such as the source and parameters of signals, and data registers which made the conditions true. Based on the detected symptoms, the \emph{Analyzer} looks up the associated change request defined in the layer model and sends to the planner a change request along with the data from symptoms that triggered this request. Next the \emph{Planner} identifies the change plan associated with the change request and sends it to the \emph{Executor} that obtains the action defined in this plan and executes it.

In a similar fashion, \emph{Policy Manager} is activated by the \emph{Policy Evaluation Signal Handler}. It works by evaluating the set of available resources against the policies and selecting the resource which leads to the highest business value. It then forwards the selected resource to the associated policy evaluation handler that calls the implementation class described in the model.

\section{Example in the Communication Domain}
\label{sec:instance}

% Present the NCB instance (model) . Describe its use: how it is instantiated (i.e., put to run in the form of an execution engine) and how it interprets a user-derived model at runtime (describe the model that is seen by the NCB layer, i.e., based on the commands available at its interface with the UCM layer).
In order to demonstrate the usage of the proposed  metamodel along with the provided execution environment, we designed a model that describes the behavior present in the NCB layer of the CVM. The existing CVM implementation of NCB was analyzed and used as a reference for the construction of this model. In order to verify its accuracy we designed a set of automated test scenarios that simulate requests from the middleware layer.
These tests were executed both in the existing NCB implementation, and in the modeled NCB loaded in the execution engine, leading to same expected results. 
%[Refers to Andrew's NCB implementation] 

\begin{figure*}
 \centering
 \includegraphics[width=0.9\textwidth]{instance}
 \caption{Instance of the broker layer  metamodel that describes a Network Communication Broker for the CVM}
 \label{fig:instance}
\end{figure*}


Figure ~\ref{fig:instance} shows an object diagram that illustrates a reduced part of the model designed. This diagram omits some relationships and objects due to space limitations. In this diagram, It is possible to outline how the main elements of the  metamodel are instantiated.

\section{Related Work}

% Related work should be in the area of runtime model interpretation and execution engines for DSMLs. Must present them and compare with your approach.
Quais as áreas relacionadas, e trabalhos relacionados
- Outras abordagens de construção de execution engines de DSMLs


A developing trend in this area is to remove the
steps involved in model translation, and to instead execute the
models directly. To achieve this, one requires a semantically
rich environment capable of interpreting these models. The
use of an Interpreted Domain-Speci?c Modeling Language
execution engine is one such environment [2]


P. J. Clarke, Y. Wu, A. A. Allen, F. Hernandez, M. Allison, and
R. France, Towards Dynamic Semantics for Synthesizing DomainSpeci?c Models, ch. 9. IGI Global, 2012.


\section{Concluding Remarks}
% TODO: MAKE IT CONFORMANT TO THE ABSTRACT/INTRODUCTION/GENERIC ARCHITECTURE
% TODO: It needs to mention that it is an step towards the use of models for adaptative execution engines

% Summarize the contributions and discuss limitations and future work.

%- Brief review: approach for the construction (and usage) of DSML execution engines for models@rt
The use of MDE and DSMLs certainly brings benefits to the development and maintenance of complex applications by providing abstractions closer to the application domain. Meanwhile, the development of execution engines for DSMLs still requires substantial effort and is largely based on code-centric approaches.

In this paper we have presented a model-driven approach towards the development and usage of execution engines for DSMLs aimed at the construction of high-level services upon a set of heterogeneous resources.
This approach relies on a generic architecture that addresses issues involved in the execution of models that are described in these DSMLs and that can be created and changed at runtime.
Hence we proposed the use of MDE techniques to specialize this architecture into domain-specific execution engines.
We then designed a  metamodel that captures domain-independent aspects of a broker layer of the proposed architecture and demonstrated its use by modeling a Network Communication Broker for the Communication Virtual Machine.
By doing so, we look after a way to simplify the development of execution engines for DSMLs, extending the benefits of MDE beyond the construction of applications to the construction of their execution engines.

% NOTE: OTHER PHRASES THAT I THOUGHT ABOUT BEFORE
% leverages solutions identified in the development of execution engines for communication and microgrid management domains.
%to propose a generic architecture that addresses issues involved in the execution of models described in these DSMLs and that can be created and changed at runtime. Based on that, we proposed the use of MDE techniques to specialize this architecture into domain-specific execution engines. 

%- Contributions: 
%Argue in favor of the generality (domain independence) of this approach
%- Simplify the development of execution engines for DSMLs by extending the use of MDE from the construction of applications to the construction of the execution engine that process a model.
%- We look after the common aspects involved in the processing of domain-specific models at runtime.
%- We propose a systematic way of applying the solutions acquired in the experience with the CVM to other domains

%- Limitations: 
%no formal link between DSML  metamodel and the execution engine definition
%- Future work: extend to other layers; enable changes to the execution engine model at runtime; experiment the concept in other application domains

However, there are several areas that have not been covered by our work and still lack investigation. 
As future work, we plan to advance in the construction of  metamodels for the description of other layers of the proposed archicture. This task requires identifying domain-independent aspects related to the responsibilities of a layer and creating abstractions that enables the description of the functionality.
Moreover, we need to evaluate the application of the proposed approach in other application domains and reach a better comprehension of its applicability.
Further research also needs to be conducted towards the integration between the models of each layer and the  metamodel for the DSML. Other research direction is towards the manipulation of execution engine models at runtime which may bring new unexploited possibilities to adaptation at runtime.

\bibliographystyle{abbrv}
\bibliography{GustavoMRT2012}

\end{document}
