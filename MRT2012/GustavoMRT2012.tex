\documentclass{sig-alternate}

\usepackage{graphicx}

\begin{document}

\conferenceinfo{Models@Run.Time}{'12 Innsbruck, Austria}

\title{Model-Driven Generation of DSML Execution Engines\titlenote{This work was partly supported by the Capes Foundation, Brazil, Proc. 0759-11-2}}

\numberofauthors{2}

\author{
\alignauthor Gustavo C. M. Sousa \\ F{\'a}bio M. Costa\\
       \affaddr{Instituto de Inform{\'a}tica}\\
       \affaddr{Universidade Federal de Goi{\'a}s}\\
       \affaddr{Goi{\^a}nia-GO, Brazil}\\
       \email{\{gustavo|fmc\}@inf.ufg.br}
%\alignauthor F{\'a}bio M. Costa\\
%       \affaddr{Instituto de Inform{\'a}tica}\\
%       \affaddr{Universidade Federal de Goi{\'a}s}\\
%       \affaddr{Goi{\^a}nia-GO, Brazil}\\
%       \email{fmc@inf.ufg.br}
\alignauthor Peter J. Clarke\\
       \affaddr{School of Computing and\\ Information Sciences}\\
       \affaddr{Florida International University}\\
       \affaddr{Miami-FL, USA}\\
       \email{clarkep@cis.fiu.edu}
}

\date{July 2012}

\maketitle

\begin{abstract}
The combination of domain-specific modeling languages and model-driven engineering techniques hold the promise of a breakthrough in the way applications are developed. 
By raising the level of abstraction and specializing in building blocks that are familiar in a particular domain, it has the potential to turn domain experts into application developers. 
Applications are developed as models, which in turn are interpreted at runtime by a specialized execution engine in order to produce the intended behavior. 
% are interpreted or may be interpreted?
This approach has been successfully applied in different domains, such as communication and smart grid management. 
However, each time the approach has to be realized in a different domain, substantial re-implementation has to take place in order to put together an execution engine for the respective DSML. 
In this paper, we present our work towards a generalization of the approach in the form of a meta-model and its respective execution environment, which capture the domain-independent aspects of runtime model interpretation and allow the definition of domain-specific execution engines as instances of the meta-model. 
We present an initial validation of the approach in the context of the Communication Virtual Machine project, by realizing part of the execution engine architecture in the form of an instance of the proposed meta-model. 
\end{abstract}

\category{D.2.11} {Software Engineering}{Software Architectures}[domain-specific architectures, languages]

\keywords{Models at Runtime, Model-Driven Engineering, Domain-Specific Modeling Languages, Metamodeling, Middleware}

%Research in model-driven software development (MDD)and domain-specific modeling languages (DSMLs) focuses on how models that provide good abstractions of complex software behaviors can be used to significantly improve software productivity and quality.

\section{Introduction}
%% Tell the whole story: problem, proposed approach to solution, results. 

%%TODO: FOR THE WHOLE SECTION... TRY TO FOCUS MORE ON THE MODELS@RUNTIME. I MEAN, I NEED TO MAKE MORE EXPLICIT THE RELATIONSHIP BETWEEN THE WORK AND MODELS@RUNTIME
%Model driven engineering is being proposed as an approach to deal with the growing complexity involved in the development of modern applications.
%These applications commonly operate in a distributed and heterogeneous environment and must behave in a dependable manner. 
%These applications also often need to adapt at runtime to comply with changing requirements and environment.
%In order to achieve these goals the developers need to employ a variety of strategies to 

Model-driven engineering (MDE) proposes the use of models as a way to deal with the increasingly complexity of contemporary applications. These applications usually operate in a distributed and heterogeneous environment and must be able to dynamically adapt in order to meet changes in the requirements and operational environment. Their development and maintenance using traditional approaches may require a huge effort due to the limitation of abstractions based on the implementation platform. % to deal with the large number of details
% traditional: (computer/technological centric) 
% limitations: (too generic/distant from the problem)

%MDE proposes to simplify the development of applications.
%By employing models built upon abstractions of the problem domain.
%MDE looks forward reducing the complexity due to the the technical details in the translation from domain concepts to platform concepts.

%% OBS: First we introduce the MDE approach of using DSMLs and automated processing
%In order to reduce this complexity, MDE relies on DSMLs and automated processing of models.
%Models can be either transformed or interpreted.
By employing models built upon abstractions that are closer to the problem at hand, model-driven approaches looks forward to abstract details of the implementation platform, thus simplifying the development and maintenance of these applications. Models are usually described in a domain-specific modeling language (DSML) and are automatedly processed by tools that either translate models into artifacts of the target implementation platform or directly interpret models.

% Maybe move these phrases into the preceding paragraph?
The use of high-level graphical DSMLs may enable domain experts, or even end users to create applications right from their requirements. 
Moreover, models may be used during development to construct new applications or at runtime to dynamically change an executing system. The use of execution engines that directly process models eases the usage of models that may be created and changed at runtime.
%%By employing this approach models can be as high-level as to be created by domain experts or even end users

%% OBS: Then we discuss about the DSML
%The use of high level (and maybe graphical) DSMLs?
%Making it possible for domain experts, or even end users to create applications from their requirements.

% OBS: And next we discuss about the automated processing as an interpreter (exeution engine)

%%Besides allowing the development of applications, these software also enables the users to adapt applications during their runtime by manipulating models. These virtual machines are execution engines for DSMLs named CML and MGridML respectively.
Communication Virtual Machine (CVM) and MicroGrid Virtual Machine (MGridVM) are examples of software that employ MDE techniques to allow users to create complex applications using high-level graphical DSMLs. 
% They provide a high level service upon a heterogenous set of resources
%These virtual machines are execution engines for DSMLs named CML and MGridML respectively.
Their execution engines are capable of processing models described in their respective DSML and realize the service described by them. Such models can also be changed at runtime, triggering adaptations to achieve the newly described requirements. 

%%Don't forget to mention that its not only applications, but complex applications
% TODO: make the concept of execution engine clearer
% TODO: MAKE IT CLEAR THAT THE MODELS PROCESSED BY THESE ARE MODELS@RUNTIME

% QUESTION: maybe change the order of ideas introducing the need to embody knowledge into the DSML and execution engine before the CVM and MGridVM
% QUESTION: maybe introduce it not in terms of CVM/MGridVM
% QUESTION: While mentioning CVM should we mention here that it works by analyzing changes in the model and synthesizing scripts? Or should we delay it to the Background?
%ALTERNATIVE: State that the use of an interpreter (herein called execution engine) enables the use of models to also change the runtime behavior using constructs closer to the problem domain


%to allow the above (user built applications)?
%DSMLs, along with the mechanisms for their processing embed concepts and semantics of the domain.
%Once we have a DSML and the mechanism for processing it, users can directly develop applications in that DSML.

To enable users to directly create and execute applications in a DSML, much of the knowledge of the application domain must be embedded into the DSML and the execution engine. While this approach simplifies the development of applications in these domains, the same is often not true regarding the execution engines that interpret these DSMLs. These engines are commonly developed in general purpose language and are often built from scratch for an specific DSML.


%While the development of applications in these domains employing their respective DSMLs is quite simple, the same is not true when talking about the execution engine that interprets their languages. These mechanisms are commonly developed in general purpose language and are subject to all the technical complexities involved in the traditional software development.

%Despite that, these execution engines share a lot of commonalities.
%Their applications basically provide a high-level service upon a set of heterogeneous resources.
%In order to do that, the runtime engine may need to execute many operations related to the processing of models, negotiation of configurations, synthesis of commands, evaluation of policies, runtime adaptation, and etc.

Despite that, execution engines of CVM and MGridVM share a lot of commonalities as both of them are focused towards providing a high-level service upon a heterogeneous set of resources. Both of them need to deal with operations related to the processing of models, negotiation of configurations, synthesis of commands, evaluation of policies, runtime adaptation, and etc. Considering this, both CVM and MGridVM were built upon a layered architecture, in which each layer has a set of well-defined responsibilities.

%TODO: Give a better look at how the chapter about the CVM mentions these features and the similarity between these VMs
%%Both CVM and MGridVM are built upon a layered architecture, in which each layer has well defined responsibilities.
%Although the communication domain is the focus of this chapter, we are currently applying the approach to other domains, such as the microgrid energy management applications (Allison, Allen, Yang, & Clarke, 2011). That is, we are in the process of developing the Microgrid Modeling Language (MGridML) and the Microgrid Virtual Machine (MGridVM) using the approach describe here. By applying our approach to multiple domains, we hope to eventually show how the approach can be generalized as a new way for defining semantics for i-DSMLs that can be directly executed by a virtual machine.

Therefore, we envision an approach to generalize the construction of these execution engines, that are targeted at the processing of DSMLs related to the provision of services upon a set of resources, and capable to transparently execute models created or changed at runtime.

Taking that into account, we propose a model-driven approach to the construction of these execution engines that stems from the solutions employed in the development of CVM and MGridVM. Doing so, we look forward a way to assist the construction of these DSML execution engines. Our proposal relies on the a generic layered architecture and the use of modeling as a way to specialize these architecture into an execution engine for a given DSML.

%Taking that into consideration, we propose a model-driven approach to the construction of execution engines for the provision of high-level services described by DSMLs upon a set of resources. Doing so, we look forward a way to assist the construction of DSML execution engines. 
%%Generalization of approach. The long-term goal of this research project is to generalize the approach on developing i-DSMLs. We expect to create an infrastructure that can be used to assist with developing the i-DSML (see Figure 1), capturing the domain-specific behavior (maybe using LTSs e.g., Tables 4 and 5), and generating the domain specific VM (transformation shown in Figure 4).
%Such an infrastructure would require: (1) defining a set of domain characteristics that are well suited for these i-DSMLs, (2) a meta-metamodel that can be used to define both the i-DSML and its interpreter, (3) a method for capturing the domain-specific behavior and integrating it into the interpreter.

We illustrate our approach by presenting a meta-model designed for the construction of one of the layers of the proposed architecture. Next, we demonstrate how this meta-model can be used to create a model that describes the same behavior of the equivalent layer in CVM.

%Our approach relies on the experience acquired in the development of CVM and MGridVM to propose a generic architecture and the use of modeling as a way to specialize it.
%We illustrate this approach by presenting a meta-model designed to describe one of the layers of the proposed architecture.
%Next, we create an instance of this meta-model that describes the same behavior expected from the correspondent layer in the CVM.

In section ~\ref{sec:background} we review the concepts involved in this work, section ~\ref{sec:approach} we describe our proposed approach. Section ~\ref{sec:meta-model} describes the meta-model of part of the architecture and ~\ref{sec:runtime} explains the runtime environment needed to process the models descbribed using the proposed meta-model.


\section{Background}
\label{sec:background}

% MDE, DSMLs and models at runtime; analogy with the distinction between structural reflection (modeling of the language) and behavioral reflection (modeling of the execution engine);

models@runtime são uma forma de autorepresentação com causalidade i.e. reflexão mais próxima do domínio

\section{Generic Architecture of the Execution Engine}

% TODO: After writing the section, find a way to mention the two point-of-views of the model of execution engine: modeling the dynamic (operational) semantics or modeling the behavioral aspects
% ALSO: The combination of models of the layers can be viewed as a megamodel??? e.g. in fact the model of the platform is a mega-model composed by the models of the layers. the whole environment may also be a megamodel that composes the DSML metamodel, and the execution engine model


- Like we introduced, in order to get the benefits of MDE (including m@rt) we need DSMLs and their execution engine
- While the syntax and static semantics of a DSML can be described by a meta-model, their dynamic semantics is embeded in the execution engine


% Describe the overall design without going into details of the meta-model.
Overview of the approach:
- Integrate a meta-model that describes the abstract syntax and static semantics of a DSML to a model that describes the execution engine for that language (that on its turn encapsulates the static semantics... it was described in the background) 
- While there are several tools that can be used to define the metamodel and concrete syntaxes for DSMLs, there is little support for defining the dynamic semantics that the execution engine embedded.

% Structure the description around a block diagram. Diagrama de blocos do fluxo para empregar a abordagem
Figure showing: {DSML meta-model (abstract syntax [mof], static semantics [ocl]) + concrete syntax [gmf] + dynamic semantics [?]} composing an environment for the development of applications and show a M@RT being fed into this environment

%Emphasize the separation between the domain-independent aspect of model execution and the definition of the DSML (and how you link a particular execution engine definition to its respective DSML).
Dada uma DSML previamente definida, podemos definir um execution engine que vai executar instancias dessa DSML
Como benefício temos:
%It would ease the construction of custom virtual machine configurations suited for specific platforms. In this way, a CVM implementation on a mobile phone could use a simpler provider selection method while a PC-based implementation could employ a more sophisticated approach. Other benefit would be the possibility to change the CVM to support new language constructs or even a specific language for another domain.
- Futuras mudanças no execution engine podem ser para atender mudanças na linguagem (e.g. novas construções) ou para atender requisitos de diferentes ambientes
%ligação entre linguagem e plataforma não é formalizado (mencionar como limitação/future work)

Even though different domains require different semantics their realization quite often rely on a common set of operations. The processing of runtime models usually requires of the execution engine capabilities of model analysis and negotiation, transformation of models into different representations, adaptation of the internal arrangement of the execution engine among others.

In order to enable the construction and manipulation of models that represent the behavior of a virtual machine we need a specific language (that is, a meta-model) for that. This language needs to be powerful enough to allow the description of virtual machines for different business domains, like the ones described above. Still, this language should not be too generic, as this could make model manipulation as difficult as writing code in a general-purpose language.

%Justify the reduction of scope to the broker
Considerando isto, essa linguagem deve conter construções capazes de descrever os aspectos comportamentais que independem do domínio de negócio e que estão envolvidos no fornecimento de serviços de alto nível descritos a partir de modelos construídos diretamente pelo usuário.
Esses aspectos, que englobam tarefas como transformações de modelos, negociação de configurações apropriadas, monitoramento do ambiente, seleção e configuração de recursos, entre outros, podem ser tratados como um domínio técnico. Deste modo, tal linguagem pode ser considerada uma linguagem específica de um domínio que abrange os aspectos técnicos envolvidos na realização de serviços transparentes de alto nível a partir de um conjunto heterogêneo de recursos.
% procurar referencia que linguagem precisa ser de domínio específico para se tornar realizável
% e domíno técnico também


%Discuss the general application of the approach in CVM-like architectures, but limit it to the broker layer for the purposes of scoping the current work.

- based on the solutions employed by CVM/MGridVM, i.e. layered architecture with separation of responsibilities; 
- a model based way of specializing this generic architecture i.e. employing a meta-model and instances that specialize

Tendo em vista estas necessidades, propomos uma arquitetura genérica para a definição dessa categoria de máquinas virtuais dirigidas por modelos centrados no usuário.
% baseado na experiencia obtida na CVM (ver uma boa forma de dizer isso)
Assim como a CVM, tal arquitetura também se baseia em camadas com responsabilidades bem definidas. 
Na abordagem proposta, as camadas desta arquitetura são definidas através de modelos cujas construções estão relacionadas às responsabilidades relativas à cada camada. A Figura \ref{fig:uvm} ilustra esta arquitetura de Máquinas Virtuais centradas no Usuário (\emph{User-centric Virtual Machine} - UVM) onde temos as seguintes camadas:


\begin{itemize}

\item  Interface com o Usuário (\emph{User Interface} - UI), que provê uma interface externa para utilização da plataforma. Além disso, esta camada possibilita a definição e gerenciamento de modelos;

\item Mecanismo de Síntese (\emph{Synthesis Engine} - SE), que possui como principal responsabilidade a transformação de um modelo declarativo fornecido pela UI em uma representação algorítmica a ser executada pela camada inferior;

\item \emph{Middleware} Centrado no Usuário (\emph{User-centric middleware} - UM), que além de executar as requisições geradas pelo Mecanismo de Síntese,  também gerencia os serviços providos pela máquina virtual e as tarefas em execução. Essa também é a camada responsável pela aplicação de restrições de segurança, qualidade de serviço, entre outras específicas do domínio de negócio. 

\item Intermediador de Serviço (\emph{Service Broker} - SB), que é a camada responsável pelo gerenciamento dos recursos. Assim sendo, essa camada tem como objetivo prover uma interface de acesso aos recursos de forma independente da tecnologia empregada por estes, provendo um serviço transparente à camada UM.

\end{itemize}

\begin{figure}
 \centering
 \includegraphics[width=0.40\textwidth]{./fig/uvm}
 \caption{Arquitetura proposta para esta categoria de Máquinas Virtuais centradas no Usuário.}
 \label{fig:uvm}
\end{figure}

Ao imitar a arquitetura da CVM, nos aproveitamos do conhecimento adquirido em relação à separação de responsabilidades necessárias para a realização de serviços no domínio técnico identificado. No entanto, apesar de apresentar a mesma estrutura, a arquitetura proposta se difere por ser independente do domínio de negócio.
Além disso, na abordagem proposta, cada camada é descrita através de um modelo. Este modelo, por sua vez, é construído em conformidade com um meta-modelo da camada que contém elementos associados às responsabilidades da camada.
%Estamos instanciando uma máquina virtual 
Assim sendo, a abordagem dirigida por modelos é empregada para a definição e manipulação de cada camada da plataforma.

O Intermediador de Serviço é a camada da arquitetura proposta que é responsável pelo gerenciamento dos recursos que serão efetivamente utilizados para prover o serviço solicitado. Cabe à esta camada disponibilizar uma interface de serviços que abstraia as especificidades dos recursos gerenciados para a camada superior. Além disso, o SB deve possuir capacidade de auto gerenciamento, ocultando os detalhes envolvidos na seleção, monitoramento e preparação dos recursos sob sua gerência.

Como uma interface de serviços, o SB se comunica com o UM através de chamadas que podem ser invocadas e eventos que podem ser gerados sinalizando alguma situação. Assim sendo, ao definirmos o comportamento dessa camada, precisamos descrever como serão tratadas as chamadas realizadas pela camada superior, e em que situações serão gerados determinados eventos. Mas além disso, também precisamos descrever como outras tarefas serão realizadas, incluindo o monitoramento e seleção de recursos, manutenção de informações, adaptação da camada, entre outros.

Com isto em mente, neste trabalho, construímos um meta-modelo que possibilita a modelagem do comportamento necessário para atender as responsabilidades definidas para a camada de intermediação de serviço da arquitetura proposta. O meta-modelo em questão contempla a descrição dos seguintes  aspectos envolvidos no cumprimento destas responsabilidades:

\section{Meta-model for Broker layer}

As mentioned in the preceding section, a Broker layer is responsible for providing an independent interface upon its set of managed resources. A Broker should also be able to monitor its resources and decide which actions may need to be taken in order to meet the requests received from its interface. Thus, the proposed meta-model contains abstractions for the description of the interface, managed resources and internal state maintained by the layer. It also enables the description of autonomic behavior and policies for the selection of resources.

The meta-model for the Broker layer was designed using the Eclipse Modeling Framework (EMF) which provides support for the construction and processing of the meta-model instances. The meta-model is structured around a class called \textsf{Manager} that defines a context for the management of resources and aggregates elements for describing the main aspects of the layer.  The figure ~\ref{fig:meta-model} shows an overall view of the meta-model... in this figure...

\begin{figure}
 \centering
 \includegraphics[width=0.90\textwidth]{metamodel}
 \caption{Overall view of the meta-model for the definition of a Broker layer}
 \label{fig:metamodel}
\end{figure}


An instance of a \textsf{Manager} has an interface and can also be viewed as a resource for other managers, facilitating the modularization of the layer and the reuse of specialized resource managers as building blocks for higher-level managers. Therefore a Broker layer may encapsulate an hierarchy of managers where the top-level manager defines the interface of the layer.

% Show the class diagram and describe elements of the meta-model. May structure the section based on the major blocks of the meta-model.

\subsection{Interface}
In the proposed meta-model, the interface for the usage of a manager is defined by provided calls and events that may be signaled to the upper layers. The class \textsf{Interface} is used to describe the interface of managers and resources. This class groups a set of calls and events that are respectively described by classes \textsf{Call} and \textsf{Event} that inherit from the class \textsf{Signal}. A \textsf{Signal} by its turn has a name and a set of named parameters defined by the class \textsf{Parameter}. Since a Broker layer is defined on terms of its top-level manager, their interfaces are also the same and therefore the interaction between layers follow the same approach based on provided calls and signaled events.

\subsection{Signal handling}
The actual behavior of a Broker layer is defined by what it does when its called from the upper layers or when a given event is generated by its resources. In the Broker meta-model, this is done by defining which action should be taken as a response to a given signal. 
When a signal, that may be either a call or an event, is signaled at runtime the corresponding action is executed. %This approach draws inspiration from event-driven architecture

In this meta-model, \textsf{Signal}, \textsf{Handler} and \textsf{Action} are the main classes used to define the signal handling of a given manager. While signals are described as part of an interface, actions and handlers are directly grouped in the manager. An action represents some operation that can be executed and is defined by the abstract class \textsf{Action} that currently have the following subclasses:

\begin{itemize}

\item  \textsf{MacroAction} that allows the user to define a Java class that implements the intended action

\item \textsf{CallAction} that defines a call to be enqueued or executed in the managed resources or in the manager itself

\item \textsf{EventAction} that defines an event to be generated to the upper layers

\item \textsf{SequenceAction} that combines a list of actions to be executed in a sequence

\end{itemize}

To define a handler, the modeler needs to indicate the signal that it handles, whether it is enabled and the action that will be taken. Besides that, it is also needed to define how the parameter values that come from a given call or event will be mapped into the context needed for the execution of the corresponding. This binding is mediated by a class named \textsf{ActionExecution} that groups a set of \textsf{ParameterBinding}. A parameter may be bound to a fixed value, a parameter value, an expression, or event the result of a call to an other action. This latter option, together with the use of sequence actions, enables the definition of elaborate actions that can be used to handle a signal.

% we look forward to extend the types of actions specializing into new operations that are currently only realized through macroactions such as querying/storing data in state management


\subsection{Resource management}
The \textsf{ResourceManager} in the meta-model has the goal of describing the interface of the managed resources and how they will be obtained at runtime. The interfaces are described in the same way as the manager interface by employing the class \textsf{Interface}. The way the resources are obtained, in its turn, is defined according to the subtypes of \textsf{ResourceManager}. The current meta-model includes a class named \textsf{InstanceResourceManager} that may be used to describe a fixed set of resources that are created by instantiating an implementation class. Other subtypes that define more elaborate ways of obtaining resources such as from distributed objects repositories may be easily defined.

An instance resource manager groups a set of instances defined by the type \textsf{Instance} that is defined in terms of its implementation class. \textsf{Instance} is also a subtype of \textsf{Annotable}, making it possible to define meta-data associated to the resource that may be eventually employed in the selection of resources. 

\subsection{State management}

In a great number of occasions, the processing of a given call or event may depend upon signals that were previously received by the layer. A given signal may have a different processing according to the parameters of a preceding call, the simple occurrence of an event or the result of the processing of a signal. In order to make it possible, the layer should be able to keep state between occurrences of signals.

The class \textsf{StateManager} provides a way to define the data types that will need to be kept by a given manager at runtime. Data types are defined through the class \textsf{State} by a simple structure where a type is defined in terms of its properties and subtypes. Subtypes are also defined as instances of \textsf{State} and therefore may have the same features.  Also, as in a relational model the definition of a type requires the definition of a key property that uniquely identifies a register of a given datatype.

\subsection{Autonomic computing}

Besides abstracting the differences in capabilities and interfacing of resources, the Broker layer should also mask to the upper layers the dynamics involved in the utilization of the resources. By doing so, the Broker layer is capable of providing an interface that keeps the upper layers oblivious of the details of selection, setup and maintenance of resources.

The signal handling provided by the meta-model enables to a certain degree the handling of events generated by resources and calls received from the upper layers. These constructs associated to state management makes it possible to define how resources and requests will be monitored in order to identify a variety of scenarios that require an action to be taken.
Nonetheless, these abstractions are not appropriate for the description of more complex situations that may involve many resources, the current layer state, data from received calls among others.

To facilitate the definition of the self-management of the layer, the proposed meta-model includes a group of abstractions inspired by the IBM autonomic computing architecture.
%- Em tal arquitetura o gerenciamento se dá através de um control loop MAPE-K
% Explicar MAPE e Knowledge, que inclui os sintomas, change requests, change plans
%The Autonomic Computing Architectural Blueprint (see Resources for a link) describes an autonomic manager as: an implementation that automates some management function and externalizes this function according to the behavior defined by management interfaces. The autonomic manager is a component that implements the control loop ... For a system component to be self-managing, it must have an automated method to collect the details it needs from the system; to analyze those details to determine if something needs to change; to create a plan, or sequence of actions, that specifies the necessary changes; and to perform those actions. When these functions can be automated, an intelligent control loop is formed.

The constructions in the meta-model allows for the description of rules that define the creation and transmission of knowledge between the MAPE functions. Thus, during the modeling of the layer, rules for the detection of symptoms, identification of change requests and selection of change plans. At runtime, the monitor function makes use of these rules to identify the occurrence of a symptom and transmit this knowledge to the next function. The analyzer and planner functions work in a similar way, acting by evaluating its rules against knowledge received from previous functions.

The class \textsf{AutonomicManager} groups the elements that are related to the autonomic management of resources. These elements describe the rules for the generation of knowledge such as symptoms, change requests and change plans. The class \textsf{Symptom} defines a set of conditions for the detection of a given symptom. At runtime, the resources and the state kept by the layer are continuously monitored, and when all conditions of a symptom are met an occurrence of the symptom is generated and sent to the analyzer.

The conditions that define a symptom are described by using expressions. Thus, in addition to the conditions, the class \textsf{Symptom} also defines the context for evaluation of these expressions. The class \textsf{Binding} is used to map a name to be used in the expression to an instance of the type \textsf{Bindable}. The interface \textsf{Bindable}, on its turn, is implemented by the classes \textsf{Signal} and \textsf{State}. This structure allows for the definition of conditions that combine data from calls, events and state kept by the layer.

The \textsf{ChangeRequest} class is used to specify that a change request needs to be generated at runtime when a given symptom is detected. A change plan, defined as an instance of the class \textsf{ChangePlan}, associates a change request to an action to be executed. An action, on its turn, may be any of the aforementioned \textsf{Action} subtypes.

% Enquanto a função de planejamento pode empregar algoritmos complexos que geram dinâmicamente planos  de mudança que podem envolver um workflow completo de execução, no trabalho em questão optamos por uma abordagem simples, onde um plano é diretamente associado a uma solicitação de mudança

\subsection{Policies}

\section{Execution Environment}

% Describe the execution engine based on EMF. This section corresponds to the implementation section that goes in most papers. Make it clear in the text that it is the implementation.

\section{Example in the Communication Domain}

% Present the NCB instance (model) . Describe its use: how it is instantiated (i.e., put to run in the form of an execution engine) and how it interprets a user-derived model at runtime (describe the model that is seen by the NCB layer, i.e., based on the commands available at its interface with the UCM layer).

\section{Related Work}
Quais as áreas relacionadas, e trabalhos relacionados
- Outras abordagens de construção de execution engines de DSMLs

% Related work should be in the area of runtime model interpretation and execution engines for DSMLs. Must present them and compare with your approach.

\section{Concluding Remarks}

% Summarize the contributions and discuss limitations and future work.

\section{References}

\bibliographystyle{abbrv}
\bibliography{GustavoMRT2012}

\end{document}
