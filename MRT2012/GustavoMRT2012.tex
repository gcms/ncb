\documentclass{sig-alternate}

\usepackage{graphicx}

\begin{document}

\conferenceinfo{Models@Run.Time}{'12 Innsbruck, Austria}

\title{Model-Driven Development of DSML Execution Engines\titlenote{This work was partly supported by the Capes Foundation, Brazil, Proc. 0759-11-2, and by FAPEG}}

\numberofauthors{3}

\author{
\alignauthor Gustavo C. M. Sousa \\ F{\'a}bio M. Costa\\
       \affaddr{Instituto de Inform{\'a}tica}\\
       \affaddr{Universidade Federal de Goi{\'a}s}\\
       \affaddr{Goi{\^a}nia-GO, Brazil}\\
       \email{\{gustavo|fmc\}@inf.ufg.br}
%\alignauthor F{\'a}bio M. Costa\\
%       \affaddr{Instituto de Inform{\'a}tica}\\
%       \affaddr{Universidade Federal de Goi{\'a}s}\\
%       \affaddr{Goi{\^a}nia-GO, Brazil}\\
%       \email{fmc@inf.ufg.br}
\alignauthor Peter J. Clarke\\
       \affaddr{School of Computing and\\ Information Sciences}\\
       \affaddr{Florida International University}\\
       \affaddr{Miami-FL, USA}\\
       \email{clarkep@cis.fiu.edu}
\alignauthor Andrew A. Allen\\
       \affaddr{Computer Sciences Department}\\
       \affaddr{Georgia Southern University}\\
       \affaddr{Statesboro-GA, USA}\\
       \email{andrewallen\\@georgiasouthern.edu}
}

\date{July 2012}

\maketitle

\begin{abstract}
The combination of domain-specific modeling languages and model-driven engineering techniques hold the promise of a breakthrough in the way applications are developed. 
By raising the level of abstraction and specializing in building blocks that are familiar in a particular domain, it has the potential to turn domain experts into application developers. 
Applications are developed as models, which in turn are interpreted at runtime by a specialized execution engine in order to produce the intended behavior. 
This approach has been successfully applied in different domains, such as communication and smart grid management to execute applications described by models that can be created and changed at runtime.
However, each time the approach has to be realized in a different domain, substantial re-implementation has to take place in order to put together an execution engine for the respective DSML. 
In this paper, we present our work towards a generalization of the approach in the form of a  metamodel which captures the domain-independent aspects of runtime model interpretation and allow the definition of domain-specific execution engines. 
%We present an initial validation of the approach in the context of the Communication Virtual Machine project, by realizing part of the execution engine architecture in the form of an instance of the proposed  metamodel. 
\end{abstract}

%To cope with the ever-present problem of growing soft- ware complexity MDE researchers need to develop tech- nologies that developers can use to generate domain- specific software development environments. These envi- ronments should consist of languages and tools that are tai- lored to the target classes of applications. Developing such technologies requires codifying knowledge that reflects a deep understanding of the common and variable aspects of the gap bridging process. Such an understanding can be gained only through costly experimentation and systematic accumulation and examination of experience. Developing such technologies is thus a wicked problem.
%\cite{FranceEtAl}

\category{D.2.11} {Software Engineering}{Software Architectures}[domain-specific architectures, languages]

\keywords{Models@Run.Time, Model-Driven Engineering, \\Domain-Specific Modeling Languages, Metamodeling}

%Research in model-driven software development (MDD)and domain-specific modeling languages (DSMLs) focuses on how models that provide good abstractions of complex software behaviors can be used to significantly improve software productivity and quality.

\section{Introduction}
%% Tell the whole story: problem, proposed approach to solution, results. 

%%TODO: FOR THE WHOLE SECTION... TRY TO FOCUS MORE ON THE MODELS@RUNTIME. I MEAN, I NEED TO MAKE MORE EXPLICIT THE RELATIONSHIP BETWEEN THE WORK AND MODELS@RUNTIME
%Model driven engineering is being proposed as an approach to deal with the growing complexity involved in the development of modern applications.
%These applications commonly operate in a distributed and heterogeneous environment and must behave in a dependable manner. 
%These applications also often need to adapt at runtime to comply with changing requirements and environment.
%In order to achieve these goals the developers need to employ a variety of strategies to 

Model-driven engineering (MDE) proposes the use of models as a way to deal with the increasing complexity of contemporary software applications \cite{FranceEtAl}. These applications usually operate in a distributed and heterogeneous environment and must be able to dynamically adapt in order to meet changes in the requirements and operational environment. Their development and maintenance using traditional approaches often require a huge effort due to the limitation of abstractions based on the implementation platform. % to deal with the large number of details
% traditional: (computer/technological centric) 
% limitations: (too generic/distant from the problem)

%MDE proposes to simplify the development of applications.
%By employing models built upon abstractions of the problem domain.
%MDE looks forward reducing the complexity due to the the technical details in the translation from domain concepts to platform concepts.

%% OBS: First we introduce the MDE approach of using DSMLs and automated processing
%In order to reduce this complexity, MDE relies on DSMLs and automated processing of models.
%Models can be either transformed or interpreted.
By employing models built upon abstractions that are closer to the problem at hand, model-driven approaches seek to abstract details of the implementation platform, thus simplifying the development and maintenance of these applications. Models are usually described in a domain-specific modeling language (DSML) and are automatically processed by tools that either translate the models into artifacts of the target implementation platform or directly interpret them.

% Maybe move these phrases into the preceding paragraph?
The use of high-level graphical DSMLs may enable domain experts, or even end users to create applications directly from their requirements. 
Moreover, models may be used during development to construct new applications or at runtime to dynamically change an executing system. The use of execution engines that directly process models eases the usage of models that may be created and changed at runtime.
%%By employing this approach models can be as high-level as to be created by domain experts or even end users

%% OBS: Then we discuss about the DSML
%The use of high level (and maybe graphical) DSMLs?
%Making it possible for domain experts, or even end users to create applications from their requirements.

% OBS: And next we discuss about the automated processing as an interpreter (exeution engine)

%%Besides allowing the development of applications, these software also enables the users to adapt applications during their runtime by manipulating models. These virtual machines are execution engines for DSMLs named CML and MGridML respectively.
The Communication Virtual Machine (CVM) \cite{Deng20081640} and the MicroGrid Virtual Machine (MGridVM) \cite{DBLP:conf/seke/AllisonAYC11} are examples of software that employ MDE techniques to allow users to create complex applications using high-level graphical DSMLs. 
% They provide a high level service upon a heterogenous set of resources
%These virtual machines are execution engines for DSMLs named CML and MGridML respectively.
Their execution engines are capable of processing models and realizing the services they describe. Such models can also be changed at runtime, triggering adaptations to achieve the newly described requirements. 

%%Don't forget to mention that its not only applications, but complex applications
% TODO: make the concept of execution engine clearer
% TODO: MAKE IT CLEAR THAT THE MODELS PROCESSED BY THESE ARE MODELS@RUNTIME

% QUESTION: maybe change the order of ideas introducing the need to embody knowledge into the DSML and execution engine before the CVM and MGridVM
% QUESTION: maybe introduce it not in terms of CVM/MGridVM
% QUESTION: While mentioning CVM should we mention here that it works by analyzing changes in the model and synthesizing scripts? Or should we delay it to the Background?
%ALTERNATIVE: State that the use of an interpreter (herein called execution engine) enables the use of models to also change the runtime behavior using constructs closer to the problem domain


%to allow the above (user built applications)?
%DSMLs, along with the mechanisms for their processing embed concepts and semantics of the domain.
%Once we have a DSML and the mechanism for processing it, users can directly develop applications in that DSML.

To enable users to directly create and execute applications in a DSML, much of the knowledge of the application domain must be embedded into the DSML and the execution engine. While this simplifies the development of applications in these domains, the same is often not true regarding the execution engines that interpret these DSMLs. These engines are commonly developed in general purpose languages and are usually built from scratch for an specific DSML.


%While the development of applications in these domains employing their respective DSMLs is quite simple, the same is not true when talking about the execution engine that interprets their languages. These mechanisms are commonly developed in general purpose language and are subject to all the technical complexities involved in the traditional software development.

%Despite that, these execution engines share a lot of commonalities.
%Their applications basically provide a high-level service upon a set of heterogeneous resources.
%In order to do that, the runtime engine may need to execute many operations related to the processing of models, negotiation of configurations, synthesis of commands, evaluation of policies, runtime adaptation, and etc.

%Despite being tailored for different DSMLs, execution engines of CVM and MGridVM share a lot of commonalities as both of them are focused on providing high-level services on the top of a heterogeneous set of resources. Both of these engines need to deal with operations related to the processing of models, negotiation of configurations, synthesis of commands, evaluation of policies, runtime adaptation, etc. Both CVM and MGridVM were built upon a layered architecture, in which each layer has a set of well-defined responsibilities.

Despite being tailored for different DSMLs, the execution engines of CVM and MGridVM share a lot of commonalities as both are focused on providing high-level services described by models that can be created or changed at runtime. 
The services they provide are built on top of a heterogeneous set of resources, and both need to deal with operations related to the processing of models, negotiation of configurations, synthesis of commands, evaluation of policies, runtime adaptation, etc. Also, both CVM and MGridVM were built upon a layered architecture, in which each layer has a set of well-defined responsibilities.

%TODO: Give a better look at how the chapter about the CVM mentions these features and the similarity between these VMs
%%Both CVM and MGridVM are built upon a layered architecture, in which each layer has well defined responsibilities.
%Although the communication domain is the focus of this chapter, we are currently applying the approach to other domains, such as the microgrid energy management applications (Allison, Allen, Yang, & Clarke, 2011). That is, we are in the process of developing the Microgrid Modeling Language (MGridML) and the Microgrid Virtual Machine (MGridVM) using the approach describe here. By applying our approach to multiple domains, we hope to eventually show how the approach can be generalized as a new way for defining semantics for i-DSMLs that can be directly executed by a virtual machine.

In this work, we envision an approach to generalize the construction of execution engines that fit into this category. Therefore our work focuses on execution engines for DSMLs related to the provision of services upon a set of resources and capable of transparently executing models created or changed at runtime.

We propose a model-driven approach to the construction of these execution engines that stems from the solutions employed in the development of CVM and MGridVM. 
By doing so, we expect to assist the construction of DSML execution engines for other application domains that share similar requirements.
Our approach relies on a generic layered architecture and the use of modeling as a way to specialize these architectures into an execution engine for a given DSML.

%Taking that into consideration, we propose a model-driven approach to the construction of execution engines for the provision of high-level services described by DSMLs upon a set of resources. Doing so, we look forward a way to assist the construction of DSML execution engines. 
%%Generalization of approach. The long-term goal of this research project is to generalize the approach on developing i-DSMLs. We expect to create an infrastructure that can be used to assist with developing the i-DSML (see Figure 1), capturing the domain-specific behavior (maybe using LTSs e.g., Tables 4 and 5), and generating the domain specific VM (transformation shown in Figure 4).
%Such an infrastructure would require: (1) defining a set of domain characteristics that are well suited for these i-DSMLs, (2) a meta-metamodel that can be used to define both the i-DSML and its interpreter, (3) a method for capturing the domain-specific behavior and integrating it into the interpreter.

We illustrate our approach by presenting a metamodel designed for the construction of one of the layers of the proposed architecture. Next, we demonstrate how this metamodel can be used to create a model that describes the same behavior of the equivalent layer in CVM.

%Our approach relies on the experience acquired in the development of CVM and MGridVM to propose a generic architecture and the use of modeling as a way to specialize it.
%We illustrate this approach by presenting a  metamodel designed to describe one of the layers of the proposed architecture.
%Next, we create an instance of this  metamodel that describes the same behavior expected from the correspondent layer in the CVM.

In Section~\ref{sec:background} we review the main concepts used in this work. Section~\ref{sec:approach} describes the proposed approach. Section~\ref{sec: metamodel} describes the  metamodel of a layer of the architecture and Section~\ref{sec:runtime} explains the environment provided to process the models 
described using the proposed  metamodel. 
Section~\ref{sec:instance} presents how the proposed metamodel was used  to describe a layer of the CVM.
%Section~\ref{sec:instance} shows how the metamodel was used  to describe a layer of the CVM.


\section{Background}
\label{sec:background}
% MDE, DSMLs and models at runtime; analogy with the distinction between structural reflection (modeling of the language) and behavioral reflection (modeling of the execution engine);

%In this section, we review the principles of model-driven engineering and domain-specific modeling languages. We also introduce the Communication Virtual Machine.

\subsection{Model-Driven Engineering}

The term Model-Driven Engineering is commonly used to describe a set of software engineering approaches that employ models as their primary artifacts. In these approaches, the use of models is not restricted to the documentation or design of software, but may extend throughout the software engineering process.
%By employing models based on abstractions closer to the problem to be solved, model-driven approaches seek to abstract technical details of the underlying platform, therefore simplifying the engineering of software. To make it feasible, these approaches rely on automated tools for the processing of models into constructs of the implementation platform.

Models are usually described in domain-specific modeling languages (DSMLs), and processed by automated tools into constructs of the implementation platform \cite{Schmidt}.
Domains can be categorized as technical domains, such as persistency, graphical user interface, databases, or as business domains, such as insurance, telecommunication, banking.
% CITE mdsd
% Domain-specific modeling: enabling full code generation
% Model driven software development Markus Völter
%Still, this separation is sometimes blurry and the proper delimitation of a domain should be defined according to the problem at hand.

%Domain-specific modeling languages provide constructs that are directly related to the concepts of a given problem domain. 
%Through the use of appropriate concepts and notations, DSMLs may enable domain experts or even end users to create applications.
% CITE end user programming
Unlike general-purpose languages, that may be employed for a large set of tasks over multiple domains, DSMLs are usually restricted to a limited set of tasks in a particular domain. Nevertheless, domain-specific languages offer a greater expressive power on their focused domain \cite{Mernik:2005:DDL:1118890.1118892, vanDeursen:2000:DLA:352029.352035}.

%Nonetheless, automation in the processing of high-level models into software implementation requires encoding substantial domain-specific knowledge into the language and processing tools

Similar to other languages, a DSML may be defined in terms of its syntax and semantics. The syntax of a DSML may be further divided in concrete syntax, which represents the textual or graphical notations of the language, and abstract syntax, which represents the concepts available in the language and how they are related. The semantics is also commonly treated separately as static semantics, which define well-formedness criteria, and dynamic semantics which gives meaning to models.

The abstract syntax and static semantics of a DSML is described using a  metamodel, which is itself a model that defines the abstractions available in the domain and how they interrelate. Metamodeling techniques have been standardized by the OMG Meta-Object Facility \cite{Omg_2006}, and there are several tools, such as the Eclipse Modeling Framework \cite{emf}, that provide metamodeling capabilities.
Moreover, there are  tools that provide support for the specification of concrete syntax and its mapping to a metamodel.
However, there are not yet widely accepted methods for describing the dynamic semantics of DSMLs \cite{Kurtev:2006:MDF:1176617.1176632}. Current methods usually rely on transformations from the DSML metamodel to another language with well-defined semantics, or on the modeling of operational behavior associated to language constructs.

Domain-specific models may be transformed into artifacts of the implementation platform or directly executed by a model interpreter. The use of model interpreters has the potential of facilitating the processing of models at runtime in order to adapt a running application. This usage of models has been proposed as an alternative to deal with the growing complexity of contemporary software \cite{FranceEtAl}.

The use of models at runtime seeks to use better abstractions for manipulating and inspecting a running system. Models at runtime bear a certain resemblance with reflection in which both deal with self-representations of a system that are causally connected. However, models at runtime use representations that are closer to the problem domain, in contrast with reflection, whose representations tend to be based on the implementation platform \cite{Blair2009}.

\subsection{Communication Virtual Machine}
\label{sec:cvm}

% refer to CVM papers that describe the approach based on identifying the differences between models (chapter and Runtime models to support...)

The Communication Virtual Machine (CVM) is an execution engine designed for the creation and realization of user-centric communication  \cite{Deng20081640}. CVM works by processing models described in a very high-level domain-specific modeling language called Communication Modeling Language (CML). A CML model describes a communication scenario by defining and associating elements of the communication domain such as connections, participants, media types and attached devices. 


Once a CML model is fed into the CVM, it is capable of realizing the described service automatically. CML models can also be changed at runtime and reprocessed in the CVM, which identifies the differences between the current and previous version of the model and executes the operations needed to meet the new requirements \cite{Wang}.

CVM is built on a layered architecture that lies between the user and the underlying communication frameworks that provide primitive communication services. 
The first layer, called \emph{User Communication Interface} (UCI) provides an interface for interacting with the CVM and an environment for the construction and management of CML models. Models received by the UCI are transformed into an internal XML representation and sent to the \emph{Synthesis Engine} (SE) layer. The primary responsibility of SE is to identify changes in an executing model and synthesize executable communication control scripts. The \emph{User-centric Communication Middleware} (UCM) executes the communication control script and assures that desired policies are enforced. Finally, the \emph{Network Communication Broker} layer provides a technology-independent interface that masks the heterogeneity of the communication frameworks. 

\section{Generic Architecture of the \\Execution Engine}
\label{sec:approach}

%% TODO: After writing the section, find a way to mention the two point-of-views of the model of execution engine: modeling the dynamic (operational) semantics or modeling the behavioral aspects
%% ALSO: The combination of models of the layers can be viewed as a megamodel??? e.g. in fact the model of the platform is a mega-model composed by the models of the layers. the whole environment may also be a megamodel that composes the DSML metamodel, and the execution engine model


%- Like we introduced, in order to get the benefits of MDE (including m@rt) we need DSMLs and their execution engine
%- While the syntax and static semantics of a DSML can be described by a  metamodel, their dynamic semantics is embeded in the execution engine
As introduced before, in order to leverage MDE to enable the use of high-level models for the development and runtime adaptation of applications, the construction of DSMLs and their execution engines is needed. While the abstract syntax and static semantics of a DSML can be described by a  metamodel, its dynamic semantics is usually embedded in the execution engine.

%Therefore, from a language viewpoint the modeling of an execution engine can be viewed as a way to describe its DSML dynamic semantics.
%Still, these execution engines are also designed for processing models that can be created and changed at runtime.



%% Describe the overall design without going into details of the  metamodel.
%Overview of the approach:
%- Integrate a  metamodel that describes the abstract syntax and static semantics of a DSML to a model that describes the execution engine for that language (that on its turn encapsulates the static semantics... it was described in the background) 
%- While there are several tools that can be used to define the metamodel and concrete syntaxes for DSMLs, there is little support for defining the dynamic semantics that the execution engine embedded.

We propose the integration of the  metamodel of a DSML with a model that describes its execution engine as a way to create platforms targeted at the development of applications using high-level models that can be created and changed at runtime.
While there are several standardized tools that employ modeling techniques for the construction of  metamodels, support for the definition of dynamic semantics is still limited.
%Dada uma DSML previamente definida, podemos definir um execution engine que vai executar instancias dessa DSML
%Como benefício temos:
%- Futuras mudanças no execution engine podem ser para atender mudanças na linguagem (e.g. novas construções) ou para atender requisitos de diferentes ambientes
%ligação entre linguagem e plataforma não é formalizado (mencionar como limitação/future work)
We expect that by extending the use of MDE techniques to the definition of execution engines we can not only simplify the construction of execution engines, but also make it easier to evolve them to support changes in their DSML or in the implementation platform. 
%The ability to manipulate the execution engine also enables the modification of the behavior...

%\begin{figure}
% \centering
% \includegraphics[width=0.3\textwidth]{overall}
% \caption{An execution engine described by a model is used to execute DSML application models}
% \label{fig:overall}
%\end{figure}

%%Emphasize the separation between the domain-independent aspect of model execution and the definition of the DSML (and how you link a particular execution engine definition to its respective DSML).
Despite differences in the dynamic semantics of different DSMLs, they often rely on a common set of operations regardless of the application domain.
The processing of runtime models usually requires from the execution engine capabilities for model analysis and negotiation, transformation of models into different representations, as well as for runtime adaptation, among others.

In order to enable the construction and manipulation of models that represent an execution engine, we need a modeling language that captures these common capabilities.
This language needs to be powerful enough to allow the description of execution engines for different application domains, but not be very generic, as this could make model creation and manipulation as difficult as writing code in a general-purpose language.
%Therefore, this language should be made up of constructs related to the domain-independent aspects of execution engines designed for providing high-level services described using a DSML. 
Therefore, this language should be made up of constructs that are independent of the application domain, but related to aspects of execution engines designed for providing high-level services described using a DSML. 

Such a language can be regarded as a domain-specific language for the technical domain that encompasses the technical aspects involved in the use of a heterogeneous set of resources for the realization of high-level services described by a model. By delimiting the scope of modeling to a given set of concerns we seek to leverage MDE techniques to construct execution engines belonging to the described category. 

% MAYBE: procurar referencia que linguagem precisa ser de domínio específico para se tornar realizável
% ref sobre domíno técnico também, ou mencionado no background


%%Discuss the general application of the approach in CVM-like architectures, but limit it to the broker layer for the purposes of scoping the current work.
%- based on the solutions employed by CVM/MGridVM, i.e. layered architecture with separation of responsibilities; 
%- a model based way of specializing this generic architecture i.e. employing a  metamodel and instances that specialize
Our approach builds on the solutions employed in the development of execution engines for communication \cite{Deng20081640} and microgrid energy management \cite{DBLP:conf/seke/AllisonAYC11}. 
We propose a generic architecture that can be specialized to produce execution engines for any given DSML whose execution semantics conforms to the above described technical domain.
This architecture is a generalization of the layered architecture of CVM and MGridVM.
Its layers are named \emph{User Interface}, \emph{Synthesis Engine}, \emph{Middleware} and \emph{Broker}.


%Fabio:Based on this architecture, we propose the definition of this generic architecture in the form of a metamodel that can be used to construct models that represent the mentioned layers in different application domains.

%Me: Based on this generic architecture, we propose the use of models as a method to define specializations of this generic architecture into domain-specific execution engines. 

Based on this generic architecture, we propose the construction of a metamodel that could be used to create models that represent specializations of this generic architecture into domain-specific execution engines. This metamodel should encompass constructs related to the concerns identified for the mentioned layers.

In this paper, we will limit our discussions to part of this metamodel, related to the concerns of the \emph{Broker} layer. In order to fully realize the proposed vision, future work must be conducted to deal with concerns of the other layers.
%In this paper, we will limit our discussions to the \emph{Broker} layer, which was the primary focus of the initial phase of the work.
In the proposed architecture, the Broker layer is responsible for the management of the resources that will ultimately be used to realize a requested service.
This layer provides to the upper layer a uniform interface that abstracts not just the differences between resources, but also all details involved in their setup, monitoring, selection, and other resource management operations.
In the next section, we describe a metamodel for the Broker layer that provides abstractions that are directly related to these responsibilities.

%O Intermediador de Serviço é a camada da arquitetura proposta que é responsável pelo gerenciamento dos recursos que serão efetivamente utilizados para prover o serviço solicitado. Cabe à esta camada disponibilizar uma interface de serviços que abstraia as especificidades dos recursos gerenciados para a camada superior. Além disso, o SB deve possuir capacidade de auto gerenciamento, ocultando os detalhes envolvidos na seleção, monitoramento e preparação dos recursos sob sua gerência.

%Como uma interface de serviços, o SB se comunica com o UM através de chamadas que podem ser invocadas e eventos que podem ser gerados sinalizando alguma situação. Assim sendo, ao definirmos o comportamento dessa camada, precisamos descrever como serão tratadas as chamadas realizadas pela camada superior, e em que situações serão gerados determinados eventos. Mas além disso, também precisamos descrever como outras tarefas serão realizadas, incluindo o monitoramento e seleção de recursos, manutenção de informações, adaptação da camada, entre outros.

%Com isto em mente, neste trabalho, construímos um  metamodelo que possibilita a modelagem do comportamento necessário para atender as responsabilidades definidas para a camada de intermediação de serviço da arquitetura proposta. O  metamodelo em questão contempla a descrição dos seguintes  aspectos envolvidos no cumprimento destas responsabilidades:

\section{Broker layer metamodel}
\label{sec: metamodel}
% Show the class diagram and describe elements of the  metamodel. May structure the section based on the major blocks of the  metamodel.

As mentioned in the preceding section, a broker layer is responsible for providing to the upper layer a uniform interface upon the managed resources. A broker should also be able to monitor its resources and decide which actions may need to be taken in order to meet the requests received through its interface with the above layer. Thus, the proposed  metamodel contains abstractions for the description of the provided interface, the managed resources and the internal state maintained by the layer. It also enables the description of autonomic behavior and policies for the selection of resources.

The  metamodel for the broker layer was designed using the Eclipse Modeling Framework \cite{emf}, which provides support for the construction and processing of models. The  metamodel is structured around a class called \textsf{Manager} which defines a context for the management of resources and aggregates elements that describe the main aspects of the layer. Figure~\ref{fig:metamodel} shows the class diagram of the metamodel, depicting its main classes and relationships.

\begin{figure*}
 \centering
 \includegraphics[width=1\textwidth]{mrt3}
 \caption{Overall view of the  metamodel for the definition of a broker layer}
 \label{fig:metamodel}
\end{figure*}

An instance of a \textsf{Manager} has an interface and can also be viewed as a resource by other managers, facilitating the modularization of the layer and the reuse of specialized managers as building blocks for higher-level managers. Therefore a broker layer may encapsulate a hierarchy of managers where the top-level manager defines the interface of the layer.


\subsection{Interface}

%In the proposed metamodel, the interface of a manager is defined by provided calls as well as events that may be signaled to the upper layer. The class \textsf{Interface} is used to describe the interface of managers and resources. This class groups a set of calls and events that are respectively described by classes \textsf{Call} and \textsf{Event}, which inherit from class \textsf{Signal}. A \textsf{Signal} in turn has a name and a set of named parameters defined by class \textsf{Parameter}. 
In the proposed metamodel, the class \textsf{Interface} is used to describe the interface of managers and resources. This class groups a set of provided calls and events that may be signaled. These are respectively described by classes \textsf{Call} and \textsf{Event}, which inherit from class \textsf{Signal}. A \textsf{Signal} has a name and a set of named parameters defined by class \textsf{Parameter}. 
%Since a broker layer is defined in terms of its top-level manager, its interface is also the same and therefore the interaction with the above layer follows the same approach based on provided calls and signaled events.

\subsection{Signal handling}
The actual behavior of a broker layer is defined by what it does when it is called from the upper layer or when a given event is generated by the resources underneath. In the broker  metamodel, this is done by defining which action should be taken as a response to a given signal. 
When a signal, which may be either a call or an event, is received, the corresponding action is executed. %This approach draws inspiration from event-driven architecture

In the  metamodel, \textsf{Signal}, \textsf{Handler} and \textsf{Action} are the main classes used to define the signal handling of a given manager. An action represents some operation that can be executed and is defined by the abstract class \textsf{Action}.
%\textsf{Action} subclasses may describe a macro to be executed, a call to be enqueued or executed, an event to be generated, or any combination of these.
Finally, a handler is used to indicate an action that will be executed when a given signal is identified.

\subsection{Resource management}
The \textsf{ResourceManager} in the  metamodel has the goal of describing the interface of the managed resources and how they will be obtained at runtime. The interfaces of resources are described in the same way as the manager interface, i.e., by class \textsf{Interface}. The way the resources are obtained, in turn, is defined according to the subtypes of \textsf{ResourceManager}. The current  metamodel includes a class named \textsf{InstanceResourceManager}, which may be used to describe a fixed set of resources that are defined by class \textsf{Instance}. Other subtypes that define more elaborate ways of obtaining resources, such as from distributed object repositories, can be easily added to the metamodel.

%An instance resource manager groups a set of instances defined by type \textsf{Instance}. An \textsf{Instance} specifies the actual implementation class of a resource, which will be instantiated at runtime.
%\textsf{Instance} is also a subtype of \textsf{Annotable}, making it possible to define meta-data describing features and properties associated to the resource, which may be eventually employed in the selection of resources. 

\subsection{State management}

In a significant number of cases, the processing of a given call or event may depend upon signals that were previously received by the layer. A given signal may require different processing depending on the parameters of a preceding call, the occurrence of an event, the result of processing a signal, etc. In order to make it possible, the layer should be able to keep state between occurrences of signals.

Class \textsf{StateManager} provides a way to define the data types that need to be kept by a given manager at runtime. Data types are defined by class \textsf{State} using a simple structure, where a type consists of attributes and subtypes. Subtypes are also defined as instances of \textsf{State} and therefore may have the same features.  Also, as in a relational model, the definition of a type requires the selection of a key attribute that uniquely identifies a data register of a given data type.

\subsection{Autonomic computing}

Besides abstracting the differences in capabilities and interfacing of resources, a broker layer should also mask from the upper layers the dynamics involved in the utilization of the resources. By doing so, the layer is capable of providing an interface that keeps the upper layers oblivious of the details of selection, setup and maintenance of resources, thereby reducing the complexity of the modeling in the upper layers.

%The signal handling provided by the  metamodel enables to a certain degree the handling of events (generated by resources) and calls (received from the upper layer). These constructs, associated with state management, make it possible to define how resources and requests will be monitored in order to identify a variety of scenarios that require an action to be taken.
%Nonetheless, the use of more appropriate abstractions would facilitate the treatment of complex situations that involve many resources, the current layer state, data from received calls, etc.

Though signal handling constructs enables a certain degree of self-management, they are not appropriate to deal with more complex situations that involve many resources, the current layer state, data from received calls, etc. To facilitate the definition of the self-management of the layer, the proposed  metamodel includes a group of abstractions inspired by the IBM autonomic computing architecture \cite{ac}. This architecture suggests the use of a control loop called MAPE-K, which executes the MAPE (Monitor, Analyze, Plan, Execute) functions and uses a Knowledge base.
%- Em tal arquitetura o gerenciamento se dá através de um control loop MAPE-K
% Explicar MAPE e Knowledge, que inclui os sintomas, change requests, change plans
%The Autonomic Computing Architectural Blueprint (see Resources for a link) describes an autonomic manager as: an implementation that automates some management function and externalizes this function according to the behavior defined by management interfaces. The autonomic manager is a component that implements the control loop ... For a system component to be self-managing, it must have an automated method to collect the details it needs from the system; to analyze those details to determine if something needs to change; to create a plan, or sequence of actions, that specifies the necessary changes; and to perform those actions. When these functions can be automated, an intelligent control loop is formed.

The available constructs enable the description of rules that define the creation and communication of knowledge between the MAPE functions.
Thus, a broker layer model should define rules for the detection of symptoms, identification of change requests and selection of change plans.
%At runtime, the MAPE functions will be driven by these rules.

%the monitor function makes use of these rules to identify the occurrence of a symptom and transmit this knowledge to the next function. The analyzer and planner functions work in a similar way, by evaluating its rules against knowledge received from previous functions.

As shown in figure~\ref{fig:metamodel}, the class \textsf{AutonomicManager} groups the elements that are related to the autonomic management of resources. These elements describe rules for knowledge generation, such as symptoms, change requests and change plans. The \textsf{Symptom} class defines a set of conditions for the detection of a given symptom.
The \textsf{ChangeRequest} class is used to specify that a change request needs to be generated when a given symptom is detected. A change plan, defined as an instance of class \textsf{ChangePlan}, associates a change request to an action to be executed.
%At runtime, the resources and the state kept by the layer are continuously monitored, and when all conditions of a symptom are met, an occurrence of the symptom is generated and sent to the analyzer.

%The conditions that define a symptom are described using expressions. Therefore, in addition to the conditions, the class \textsf{Symptom} defines the context for evaluation of these expressions. The context is defined through the class \textsf{Binding}, which is used to map a name used in the expression to an instance of the type \textsf{Bindable}. The interface \textsf{Bindable}, in turn, is implemented by the classes \textsf{Signal} and \textsf{State}. This structure allows for the definition of conditions that combine data from calls and events, as well as from the state kept by the layer.

%The \textsf{ChangeRequest} class is used to specify that a change request needs to be generated when a given symptom is detected. A change plan, defined as an instance of class \textsf{ChangePlan}, associates a change request to an action to be executed. %An action, in turn, may be any of the \textsf{Action} subtypes.

% Enquanto a função de planejamento pode empregar algoritmos complexos que geram dinâmicamente planos  de mudança que podem envolver um workflow completo de execução, no trabalho em questão optamos por uma abordagem simples, onde um plano é diretamente associado a uma solicitação de mudança

\subsection{Policies}
In the proposed  metamodel policies are employed to drive the selection of resources. The class \textsf{PolicyManager} groups abstractions related to the definition of policies and their evaluation. These comprise \textsf{Policy}, which identifies a policy, \textsf{PolicyEvaluationPoint}, which defines when policies should be evaluated, and \textsf{PolicyEvaluationHandler}, which defines how the policy evaluation result should be handled. 
%Besides that, the  metamodel also includes auxiliary constructs for establishing links between these main elements.

%As mentioned earlier, resources may be annotated with their features and properties.
A policy specifies a condition over the resources, and the business value that is associated to the reaching of this condition.
At runtime, resources are classified according to their accumulated business value.

An evaluation point defines the moment at which policies should be evaluated by specifying a call or event that triggers the policy evaluation process. Associated to an evaluation point is an evaluation handler that defines an implementation class that is executed on the results of the policy evaluation process.
%The scope of the policies is implicitly defined as the set of resources associated to the same manager.


\section{Execution Environment}
\label{sec:runtime}

% Describe the execution engine based on EMF. This section corresponds to the implementation section that goes in most papers. Make it clear in the text that it is the implementation.

\begin{figure*}
 \centering
 \includegraphics[width=0.8\textwidth]{environment}
 \caption{Execution environment for the broker layer}
 \label{fig:environment}
\end{figure*}


%% Describe why the execution environment is needed
%- The  metamodel allows for us to define a Broker layer...
%- but in order to execute it so that it is capable of handling requests from the middleware layer ...
%- we developed an execution engine (that therefore provides dynamic semantics to the  metamodel)

The metamodel described in the preceding section provides abstractions to enable the definition of a broker layer for a DSML execution engine. Nevertheless, a model that defines a broker layer is not enough to make an executable layer, capable of handling calls and events at runtime. In order to fill in this gap, we developed an execution environment that loads a broker layer model and behaves accordingly, therefore providing operational semantics for the above proposed  metamodel.

%% MAKE IT CLEAR that the execution engine loads the XMI models defined by using EMF
%- The execution environment loads a Broker layer model defined as an EMF XMI file.
%- Based on this model, the execution environment initializes a Broker layer for a DSML execution engine.
%- It uses the classes generated by EMF from the  metamodel to process the model.
%The provided execution environment was developed in the Java platform and comprises components for executing a broker layer model, as well as a library for interfacing with the resources to be managed by the layer. It loads a model described in EMF XMI 2.0 and initializes an executable broker layer for a DSML execution engine.

% Introduction to understand the following paragraphs
%in this section we deal with the actual implementation that actually process the requests driven by a given Broker model
%- The name of the classes are overloaded (always refer to the implementation exception when mentioned)
%- The architecture resembles the  metamodel
In this section, we briefly describe the implementation of this execution environment, including its main components and how they interact in order to provide the behavior described by the model loaded in it. 
%Though the names of these components may be the same used for elements of the  metamodel they do not represent the same entities. 
The components described here are part of the actual implementation, and represent the runtime infrastructure to process a broker layer model. 
%As other elements of this work, the execution environment stems from existing work in the Network Communication Broker layer for CVM \cite{Allen:2009:AFU:1723028.1723052}.

% Describe the overall flow of the execution environment
%Under the implemented execution environment, a broker layer constantly waits for calls from the upper layer or events from resources that, once arrived, are enqueued for later processing. In order to process such signals, the appropriate handler is found and executed. In accordance with the broker layer model, the handler executes the associated action that may interact with resources and manipulate the state maintained by the layer. Specialized handlers are also set up for handling signals that may activate self-management functions. Figure ~\ref{fig:environment} illustrates the main elements that compose a broker layer at runtime and how they interact.

 Figure~\ref{fig:environment} illustrates the main elements that compose a broker layer at runtime and how they interact. The \emph{Broker Manager} is the main element of the execution environment and is the responsible for controlling the flow of execution.
It serializes the handling of signals by enqueueing and subsequently processing them one at a time. Once a signal is dequeued, it is processed by the \emph{Signal Handler Manager}, which identifies and executes the correct handler for the given signal.
The \emph{Signal Handler Manager} maintains a registry of \emph{Signal Handlers}, loaded from the executing broker layer model, and searches for the first one that is capable of handling the given signal.
An \emph{Action}, in turn, can manipulate resources and state through the \emph{Resource Manager} and \emph{State manager}.
 Figure~\ref{fig:environment} illustrates the main elements that compose a broker layer at runtime and how they interact.
%It is a runtime object that realizes a \textsf{Manager} described in the  metamodel.
%Therefore, at runtime a \emph{Broker Manager] may also be used as a resource for another \emph{Broker Manager}  and so on

%signals/events
%handlers registered into the SignalHandlerManager
Besides those, the specialized \emph{Autonomic Signal Handler} and \emph{Policy Evaluation Signal Handler} are  set up for monitoring signals that may be of interest for self-management. As shown in figure~\ref{fig:environment}, these specialized handlers may activate respectively the \emph{Autonomic Manager}, that will execute the MAPE control loop, or the \emph{Policy Manager}, that will start the policy evaluation process.
%\emph{Autonomic Signal Handler} checks if a signal is related to any of the symptoms that are to be monitored and if positive sends the signal information to the \emph{Autonomic Manager} that may then execute its functions.
%The \emph{Policy Evaluation Signal Handler}, in turn, verifies if a signal is defined as a policy evaluation point and requests the \emph{Policy Manager} to start the policy evaluation process. Regardless of their result, these specialized handlers leave the signal flagged as not handled, so that it can be handled by an action defined in the model. An action


%The \emph{Resource Manager} provides an interface for querying and obtaining its managed resources. These resources are returned as instances of \textsf{Resource}. \textsf{ManagedResource} is a subtype of \textsf{Resource} and wraps the actual resource along with its metadata. \textsf{BrokerManager} is the other subtype of \textsf{Resource}, which allows a \emph{Broker Manager} to be employed as a resource.
%In order to be managed by a broker layer, resources should implement the \textsf{Manageable} interface and annotate their provided calls with a \textsf{@Call} annotation. Resources should also use the provided class \textsf{Event} to signal an event to be handled by the layer. The \emph{Resource Manager} interacts with a resources through a touchpoint which serializes calls to a resource and handles the events signaled by resources.
% Also expose the setEventListener method
% Main manager registers into the resource manager as a listener of the resource events

%In a similar way, the \emph{State Manager} provides an interface for creating and querying registers for the data types described in the  metamodel. A data register is represented by the class \textsf{StateHolder} that provides methods for obtaining the values for its attributes and subtypes.
% autonomic manager registers into the state manager as a listener of state changes

%Both state and resource managers are made available to macro actions, so that such actions can query and change the layer state and interact with the resources.

%The \emph{Autonomic Manager} encapsulates the MAPE functions and may be activated by signals filtered by the \emph{Autonomic Signal Handler} or state changes notified by the \emph{State Manager}. Once one of these events occur, the \emph{Monitor} function identify the related symptom definitions and reevaluate their conditions.
%If the conditions are met the \emph{Monitor} notifies the \emph{Analyzer} of the symptoms that were detected. Along with the notification it also sends the context in which the conditions for a symptom were evaluated as true such as the source and parameters of signals, and data registers which made the conditions true. Based on the detected symptoms, the \emph{Analyzer} looks up the associated change request defined in the layer model and sends to the planner a change request along with the data from symptoms that triggered this request. Next the \emph{Planner} identifies the change plan associated with the change request and sends it to the \emph{Executor} that obtains the action defined in this plan and executes it.

%In a similar fashion, \emph{Policy Manager} is activated by the \emph{Policy Evaluation Signal Handler}. It works by evaluating the set of available resources against the policies and selecting the resource which leads to the highest business value. It then forwards the selected resource to the associated policy evaluation handler that calls the implementation class described in the model.

\section{Example in the Communication Domain}
\label{sec:instance}

% Present the NCB instance (model) . Describe its use: how it is instantiated (i.e., put to run in the form of an execution engine) and how it interprets a user-derived model at runtime (describe the model that is seen by the NCB layer, i.e., based on the commands available at its interface with the UCM layer).
To demonstrate the use of the proposed  metamodel along with the provided execution environment, we designed a model that describes the behavior of the NCB layer of the CVM. The existing CVM implementation of NCB \cite{Allen:2009:AFU:1723028.1723052} was analyzed and used as a reference for to construct this model.

In order to validate the behavior of the modeled layer against the existing NCB implementation, we designed automated test cases for a set of scenarios.
The proposed scenarios are 1) communication between two parties using one media type; 2) communication between two parties using two media types; 3) failure of a framework in use; 4) failure of all available frameworks; 5) communication initiated by other parties; 6) login failure; 7) communication between three parties. Each of these scenarios is described by a valid sequence of calls that could be generated by the upper layer, or events that could be generated by resources. 

We set up the existing NCB implementation with a set of simulated resources, and executed all the proposed scenarios to obtain a log of calls generated by the NCB to the underlying simulated resources, as well as events generated to the upper layer. 
This information was then used to create automated black box test cases to validate a model-based broker layer against this behavior.

While modeling NCB based on the proposed metamodel, the test cases were ran to validate its equivalence to the existing NCB implementation. 
Table~\ref{tab:scenario} shows scenario 3, where an audio communication is initially established using  \emph{Mock Resource 1} and later switched to \emph{Mock Resource 2}, after a failure is simulated in \emph{Mock Resource 1}.
In this table, the first column shows the sequence of commands issued by the simulator of the upper layer, and the later columns show the calls made by NCB to the simulated resources.
Calls to establish a communication into \emph{Mock Resource 2} are only sent after the failure of \emph{Mock Resource 1}.

%Table~\ref{tab:scenario} shows scenario 3, where the framework in use fails during an audio communication between two parties. NCB receives requests from upper layer and initially establishes the communication into  \emph{Mock Resource 1}. A failure is then simulated in \emph{Mock Resource 1}, which causes the NCB to finalize the ongoing communication into \emph{Mock Resource 1} and reestablish it into \emph{Mock Resource 2}.



%Table~\ref{tab:scenario} shows a scenario where the used framework fails during communication between two parties. 
%The first column shows the sequence of commands issued by the simulator of the upper layer, and the later columns show the calls made by NCB to the simulated resources.
%In this scenario an audio communication is initially established using \emph{Mock Resource 1}, and later switched to \emph{Mock Resource 2}, when a failure is simulated in the initial resource. 

Finally, all the proposed scenarios were executed in the existing NCB implementation, and in the modeled NCB. As expected, both implementations generated the same output when provided the same inputs.
%[Refers to Andrew's NCB implementation] 

\begin{table*}\scriptsize
\centering
\caption{Results of executing a scenario of framework failure during a communication}
\begin{tabular}{|l|l|l|} \hline

NCB & Mock Resource 1 & Mock Resource 2\\ \hline

\parbox{5.4cm}{
login("Andrew", "password") \\
createSession("101")\\
sendSchema("101", "Yali", "101 Audio Yali Andrew", null) \\
addParty("101", "Yali") \\
enableMedium("101", "Audio"); \\
mock1.markAsFailed("Audio")}
&
\parbox{5.4cm}{
login() \\
sendSchema("101", "Audio Yali Andrew", "Yali") \\
createSession("101") \\
addParticipant("101", "Yali") \\
enableMedium("101", "Audio") \\
destroySession("101") }
&
\parbox{5.4cm}{
login() \\
sendSchema("101", "Audio Yali Andrew", "Yali") \\
createSession("101") \\
addParticipant("101", "Yali") \\
enableMedium("101", "Audio")}
\\ \hline
\end{tabular}
\label{tab:scenario}
\end{table*}

%\begin{figure*}
% \centering
% \includegraphics[width=0.9\textwidth]{instance}
% \caption{Instance of the broker layer  metamodel that describes a Network Communication Broker for the CVM}
% \label{fig:instance}
%\end{figure*}
%

%Figure ~\ref{fig:instance} shows an object diagram that illustrates a reduced part of the model designed. This diagram omits some relationships and objects due to space limitations. In this diagram, It is possible to outline how the main elements of the  metamodel are instantiated.

\section{Related Work}

% Related work should be in the area of runtime model interpretation and execution engines for DSMLs. Must present them and compare with your approach.

Most work related to model-driven development of execution engines for DSMLs is associated to the definition of DSML dynamic semantics, as it is usually viewed as a way to enable the automatic generation of tools for DSMLs \cite{ChallengesSemantics}.

%- Model Driven Language Engineering with Kermeta. generation of tools (interpreters, compilers, etc) by weaving behavior: action languages close to 3rd generation GPLs
Kermeta \cite{Jezequel:2009:MDL:1949925.1949931} promotes weaving behavior into the metamodels as a way to specify operational semantics for a language and thereby to generate interpreters, compilers and other tools for them.
%XMF-Mosaic offers similar capabilities through the xOCL action language.
It differs from our approach in that semantics are described using an action language whose constructions are similar to those found in third generation of general-purpose programming languages.

The use of graph rewriting and transformations has been proposed in \cite{1240339} as a suitable specification for developing DSML tools. The use of semantic mappings between the metamodel and behavioral semantic units is also proposed in \cite{amma, Chen:2005:TSA:1086228.1086236} as a way to formalize dynamic semantics for DSMLs. 
%Though these approaches can be potentially used to create DSML interpreters, they are not directly focused on interpreters for models that can be created and changed at runtime.
%While these approaches can be used to formalize semantics for virtually any DSML, their constructs are very primitive and are not directly related to the operations involved in the execution of models at runtime.
While these approaches can be used to formalize semantics for virtually any DSML, their constructs are very primitive and are not directly related to the operations involved in the execution of models at runtime.
%Still, these approaches are very useful for dealing with concerns that arise when interpreting models at runtime and could be used to describe some aspects of other layers of the proposed architecture, such as the synthesis engine.
%Still, these approaches are part of the

%Automatic Generation of Language-based Tools using the LISA system,``Attribute grammars have proved to be very useful in specifying the semantics of programming languages, in automatic construction of compilers/interpreters, and in specifying and generating interactive programming environments [9]. The approach presented in this
%ASM and semantic actions, (Semantic actions are similar to the actions in the metamodel)
%Other approaches that may be used but that the related work just mentions the transformation into artifacts, i.e. compilers not interpreters
%Also, none of the identified approaches are focused on the construction of interpreters for models that can be created and changed at runtime. 

\section{Concluding Remarks}
% TODO: MAKE IT CONFORMANT TO THE ABSTRACT/INTRODUCTION/GENERIC ARCHITECTURE
% TODO: It needs to mention that it is an step towards the use of models for adaptative execution engines

% Summarize the contributions and discuss limitations and future work.

%- Brief review: approach for the construction (and usage) of DSML execution engines for models@rt
%The use of MDE and DSMLs certainly brings benefits to the development and maintenance of complex applications by providing abstractions closer to the application domain. Meanwhile, the development of execution engines for DSMLs still requires substantial effort and is largely based on code-centric approaches.

In this paper we have presented a model-driven approach towards the development and usage of execution engines for DSMLs aimed at the construction of high-level services upon a set of heterogeneous resources.
This approach relies on a generic architecture that addresses issues involved in the execution of models that are described in these DSMLs and that can be created and changed at runtime.
Hence we proposed the use of MDE techniques to specialize this architecture into domain-specific execution engines.
We then designed a  metamodel that captures domain-independent aspects of a broker layer of the proposed architecture and demonstrated its use by modeling a Network Communication Broker for the Communication Virtual Machine.
By doing so, we look for a way to simplify the development of execution engines for DSMLs, extending the benefits of MDE beyond the construction of applications to the construction of their execution engines.

% NOTE: OTHER PHRASES THAT I THOUGHT ABOUT BEFORE
% leverages solutions identified in the development of execution engines for communication and microgrid management domains.
%to propose a generic architecture that addresses issues involved in the execution of models described in these DSMLs and that can be created and changed at runtime. Based on that, we proposed the use of MDE techniques to specialize this architecture into domain-specific execution engines. 

%- Contributions: 
%Argue in favor of the generality (domain independence) of this approach
%- Simplify the development of execution engines for DSMLs by extending the use of MDE from the construction of applications to the construction of the execution engine that process a model.
%- We look after the common aspects involved in the processing of domain-specific models at runtime.
%- We propose a systematic way of applying the solutions acquired in the experience with the CVM to other domains

%- Limitations: 
%no formal link between DSML  metamodel and the execution engine definition
%- Future work: extend to other layers; enable changes to the execution engine model at runtime; experiment the concept in other application domains

However, there are several areas that have not been covered by our work and still lack investigation. 
As future work, we plan to advance into the construction of  metamodels for the description of other layers of the proposed architecture. This task requires identifying domain-independent aspects related to the responsibilities of a layer and creating abstractions that enables the description of the functionality.
Moreover, we need to evaluate the application of the proposed approach in other application domains and reach a better comprehension of its applicability.
Further research also needs to be conducted towards the integration between the models of each layer and the  metamodel for the DSML. Other research direction is towards the manipulation of execution engine models at runtime which may bring new unexploited possibilities to adaptation at runtime.

\bibliographystyle{abbrv}
\bibliography{GustavoMRT2012}

\end{document}
